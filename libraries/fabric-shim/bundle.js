/*
 * Copyright IBM Corp. All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.Empty = (function() {
    
                /**
                 * Properties of an Empty.
                 * @memberof google.protobuf
                 * @interface IEmpty
                 */
    
                /**
                 * Constructs a new Empty.
                 * @memberof google.protobuf
                 * @classdesc Represents an Empty.
                 * @implements IEmpty
                 * @constructor
                 * @param {google.protobuf.IEmpty=} [properties] Properties to set
                 */
                function Empty(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new Empty instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {google.protobuf.IEmpty=} [properties] Properties to set
                 * @returns {google.protobuf.Empty} Empty instance
                 */
                Empty.create = function create(properties) {
                    return new Empty(properties);
                };
    
                /**
                 * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Empty.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Empty.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Empty message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Empty} Empty
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Empty.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Empty message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.Empty} Empty
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Empty.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Empty message.
                 * @function verify
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Empty.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an Empty message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.Empty} Empty
                 */
                Empty.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.Empty)
                        return object;
                    return new $root.google.protobuf.Empty();
                };
    
                /**
                 * Creates a plain object from an Empty message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.Empty
                 * @static
                 * @param {google.protobuf.Empty} message Empty
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Empty.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this Empty to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.Empty
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Empty.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Empty;
            })();
    
            protobuf.Timestamp = (function() {
    
                /**
                 * Properties of a Timestamp.
                 * @memberof google.protobuf
                 * @interface ITimestamp
                 * @property {number|Long|null} [seconds] Timestamp seconds
                 * @property {number|null} [nanos] Timestamp nanos
                 */
    
                /**
                 * Constructs a new Timestamp.
                 * @memberof google.protobuf
                 * @classdesc Represents a Timestamp.
                 * @implements ITimestamp
                 * @constructor
                 * @param {google.protobuf.ITimestamp=} [properties] Properties to set
                 */
                function Timestamp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Timestamp seconds.
                 * @member {number|Long} seconds
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 */
                Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Timestamp nanos.
                 * @member {number} nanos
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 */
                Timestamp.prototype.nanos = 0;
    
                /**
                 * Creates a new Timestamp instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp=} [properties] Properties to set
                 * @returns {google.protobuf.Timestamp} Timestamp instance
                 */
                Timestamp.create = function create(properties) {
                    return new Timestamp(properties);
                };
    
                /**
                 * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                    return writer;
                };
    
                /**
                 * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Timestamp message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.seconds = reader.int64();
                            break;
                        case 2:
                            message.nanos = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Timestamp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Timestamp message.
                 * @function verify
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Timestamp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                            return "seconds: integer|Long expected";
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        if (!$util.isInteger(message.nanos))
                            return "nanos: integer expected";
                    return null;
                };
    
                /**
                 * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.Timestamp} Timestamp
                 */
                Timestamp.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.Timestamp)
                        return object;
                    var message = new $root.google.protobuf.Timestamp();
                    if (object.seconds != null)
                        if ($util.Long)
                            (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                        else if (typeof object.seconds === "string")
                            message.seconds = parseInt(object.seconds, 10);
                        else if (typeof object.seconds === "number")
                            message.seconds = object.seconds;
                        else if (typeof object.seconds === "object")
                            message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                    if (object.nanos != null)
                        message.nanos = object.nanos | 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.Timestamp
                 * @static
                 * @param {google.protobuf.Timestamp} message Timestamp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Timestamp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.seconds = options.longs === String ? "0" : 0;
                        object.nanos = 0;
                    }
                    if (message.seconds != null && message.hasOwnProperty("seconds"))
                        if (typeof message.seconds === "number")
                            object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                        else
                            object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                    if (message.nanos != null && message.hasOwnProperty("nanos"))
                        object.nanos = message.nanos;
                    return object;
                };
    
                /**
                 * Converts this Timestamp to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.Timestamp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Timestamp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Timestamp;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();
    
    $root.msp = (function() {
    
        /**
         * Namespace msp.
         * @exports msp
         * @namespace
         */
        var msp = {};
    
        msp.MSPConfig = (function() {
    
            /**
             * Properties of a MSPConfig.
             * @memberof msp
             * @interface IMSPConfig
             * @property {number|null} [type] MSPConfig type
             * @property {Uint8Array|null} [config] MSPConfig config
             */
    
            /**
             * Constructs a new MSPConfig.
             * @memberof msp
             * @classdesc Represents a MSPConfig.
             * @implements IMSPConfig
             * @constructor
             * @param {msp.IMSPConfig=} [properties] Properties to set
             */
            function MSPConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MSPConfig type.
             * @member {number} type
             * @memberof msp.MSPConfig
             * @instance
             */
            MSPConfig.prototype.type = 0;
    
            /**
             * MSPConfig config.
             * @member {Uint8Array} config
             * @memberof msp.MSPConfig
             * @instance
             */
            MSPConfig.prototype.config = $util.newBuffer([]);
    
            /**
             * Creates a new MSPConfig instance using the specified properties.
             * @function create
             * @memberof msp.MSPConfig
             * @static
             * @param {msp.IMSPConfig=} [properties] Properties to set
             * @returns {msp.MSPConfig} MSPConfig instance
             */
            MSPConfig.create = function create(properties) {
                return new MSPConfig(properties);
            };
    
            /**
             * Encodes the specified MSPConfig message. Does not implicitly {@link msp.MSPConfig.verify|verify} messages.
             * @function encode
             * @memberof msp.MSPConfig
             * @static
             * @param {msp.IMSPConfig} message MSPConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.config != null && message.hasOwnProperty("config"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.config);
                return writer;
            };
    
            /**
             * Encodes the specified MSPConfig message, length delimited. Does not implicitly {@link msp.MSPConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.MSPConfig
             * @static
             * @param {msp.IMSPConfig} message MSPConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MSPConfig message from the specified reader or buffer.
             * @function decode
             * @memberof msp.MSPConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.MSPConfig} MSPConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.MSPConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.config = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MSPConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.MSPConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.MSPConfig} MSPConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MSPConfig message.
             * @function verify
             * @memberof msp.MSPConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MSPConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.config != null && message.hasOwnProperty("config"))
                    if (!(message.config && typeof message.config.length === "number" || $util.isString(message.config)))
                        return "config: buffer expected";
                return null;
            };
    
            /**
             * Creates a MSPConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.MSPConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.MSPConfig} MSPConfig
             */
            MSPConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.MSPConfig)
                    return object;
                var message = new $root.msp.MSPConfig();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.config != null)
                    if (typeof object.config === "string")
                        $util.base64.decode(object.config, message.config = $util.newBuffer($util.base64.length(object.config)), 0);
                    else if (object.config.length)
                        message.config = object.config;
                return message;
            };
    
            /**
             * Creates a plain object from a MSPConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.MSPConfig
             * @static
             * @param {msp.MSPConfig} message MSPConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MSPConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    if (options.bytes === String)
                        object.config = "";
                    else {
                        object.config = [];
                        if (options.bytes !== Array)
                            object.config = $util.newBuffer(object.config);
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.config != null && message.hasOwnProperty("config"))
                    object.config = options.bytes === String ? $util.base64.encode(message.config, 0, message.config.length) : options.bytes === Array ? Array.prototype.slice.call(message.config) : message.config;
                return object;
            };
    
            /**
             * Converts this MSPConfig to JSON.
             * @function toJSON
             * @memberof msp.MSPConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MSPConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return MSPConfig;
        })();
    
        msp.FabricMSPConfig = (function() {
    
            /**
             * Properties of a FabricMSPConfig.
             * @memberof msp
             * @interface IFabricMSPConfig
             * @property {string|null} [name] FabricMSPConfig name
             * @property {Array.<Uint8Array>|null} [rootCerts] FabricMSPConfig rootCerts
             * @property {Array.<Uint8Array>|null} [intermediateCerts] FabricMSPConfig intermediateCerts
             * @property {Array.<Uint8Array>|null} [admins] FabricMSPConfig admins
             * @property {Array.<Uint8Array>|null} [revocationList] FabricMSPConfig revocationList
             * @property {msp.ISigningIdentityInfo|null} [signingIdentity] FabricMSPConfig signingIdentity
             * @property {Array.<msp.IFabricOUIdentifier>|null} [organizationalUnitIdentifiers] FabricMSPConfig organizationalUnitIdentifiers
             * @property {msp.IFabricCryptoConfig|null} [cryptoConfig] FabricMSPConfig cryptoConfig
             * @property {Array.<Uint8Array>|null} [tlsRootCerts] FabricMSPConfig tlsRootCerts
             * @property {Array.<Uint8Array>|null} [tlsIntermediateCerts] FabricMSPConfig tlsIntermediateCerts
             * @property {msp.IFabricNodeOUs|null} [fabricNodeOus] FabricMSPConfig fabricNodeOus
             */
    
            /**
             * Constructs a new FabricMSPConfig.
             * @memberof msp
             * @classdesc Represents a FabricMSPConfig.
             * @implements IFabricMSPConfig
             * @constructor
             * @param {msp.IFabricMSPConfig=} [properties] Properties to set
             */
            function FabricMSPConfig(properties) {
                this.rootCerts = [];
                this.intermediateCerts = [];
                this.admins = [];
                this.revocationList = [];
                this.organizationalUnitIdentifiers = [];
                this.tlsRootCerts = [];
                this.tlsIntermediateCerts = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FabricMSPConfig name.
             * @member {string} name
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.name = "";
    
            /**
             * FabricMSPConfig rootCerts.
             * @member {Array.<Uint8Array>} rootCerts
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.rootCerts = $util.emptyArray;
    
            /**
             * FabricMSPConfig intermediateCerts.
             * @member {Array.<Uint8Array>} intermediateCerts
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.intermediateCerts = $util.emptyArray;
    
            /**
             * FabricMSPConfig admins.
             * @member {Array.<Uint8Array>} admins
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.admins = $util.emptyArray;
    
            /**
             * FabricMSPConfig revocationList.
             * @member {Array.<Uint8Array>} revocationList
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.revocationList = $util.emptyArray;
    
            /**
             * FabricMSPConfig signingIdentity.
             * @member {msp.ISigningIdentityInfo|null|undefined} signingIdentity
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.signingIdentity = null;
    
            /**
             * FabricMSPConfig organizationalUnitIdentifiers.
             * @member {Array.<msp.IFabricOUIdentifier>} organizationalUnitIdentifiers
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.organizationalUnitIdentifiers = $util.emptyArray;
    
            /**
             * FabricMSPConfig cryptoConfig.
             * @member {msp.IFabricCryptoConfig|null|undefined} cryptoConfig
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.cryptoConfig = null;
    
            /**
             * FabricMSPConfig tlsRootCerts.
             * @member {Array.<Uint8Array>} tlsRootCerts
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.tlsRootCerts = $util.emptyArray;
    
            /**
             * FabricMSPConfig tlsIntermediateCerts.
             * @member {Array.<Uint8Array>} tlsIntermediateCerts
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.tlsIntermediateCerts = $util.emptyArray;
    
            /**
             * FabricMSPConfig fabricNodeOus.
             * @member {msp.IFabricNodeOUs|null|undefined} fabricNodeOus
             * @memberof msp.FabricMSPConfig
             * @instance
             */
            FabricMSPConfig.prototype.fabricNodeOus = null;
    
            /**
             * Creates a new FabricMSPConfig instance using the specified properties.
             * @function create
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {msp.IFabricMSPConfig=} [properties] Properties to set
             * @returns {msp.FabricMSPConfig} FabricMSPConfig instance
             */
            FabricMSPConfig.create = function create(properties) {
                return new FabricMSPConfig(properties);
            };
    
            /**
             * Encodes the specified FabricMSPConfig message. Does not implicitly {@link msp.FabricMSPConfig.verify|verify} messages.
             * @function encode
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {msp.IFabricMSPConfig} message FabricMSPConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricMSPConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.rootCerts != null && message.rootCerts.length)
                    for (var i = 0; i < message.rootCerts.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rootCerts[i]);
                if (message.intermediateCerts != null && message.intermediateCerts.length)
                    for (var i = 0; i < message.intermediateCerts.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.intermediateCerts[i]);
                if (message.admins != null && message.admins.length)
                    for (var i = 0; i < message.admins.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.admins[i]);
                if (message.revocationList != null && message.revocationList.length)
                    for (var i = 0; i < message.revocationList.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.revocationList[i]);
                if (message.signingIdentity != null && message.hasOwnProperty("signingIdentity"))
                    $root.msp.SigningIdentityInfo.encode(message.signingIdentity, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.organizationalUnitIdentifiers != null && message.organizationalUnitIdentifiers.length)
                    for (var i = 0; i < message.organizationalUnitIdentifiers.length; ++i)
                        $root.msp.FabricOUIdentifier.encode(message.organizationalUnitIdentifiers[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.cryptoConfig != null && message.hasOwnProperty("cryptoConfig"))
                    $root.msp.FabricCryptoConfig.encode(message.cryptoConfig, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.tlsRootCerts != null && message.tlsRootCerts.length)
                    for (var i = 0; i < message.tlsRootCerts.length; ++i)
                        writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.tlsRootCerts[i]);
                if (message.tlsIntermediateCerts != null && message.tlsIntermediateCerts.length)
                    for (var i = 0; i < message.tlsIntermediateCerts.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.tlsIntermediateCerts[i]);
                if (message.fabricNodeOus != null && message.hasOwnProperty("fabricNodeOus"))
                    $root.msp.FabricNodeOUs.encode(message.fabricNodeOus, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FabricMSPConfig message, length delimited. Does not implicitly {@link msp.FabricMSPConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {msp.IFabricMSPConfig} message FabricMSPConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricMSPConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FabricMSPConfig message from the specified reader or buffer.
             * @function decode
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.FabricMSPConfig} FabricMSPConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricMSPConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.FabricMSPConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.rootCerts && message.rootCerts.length))
                            message.rootCerts = [];
                        message.rootCerts.push(reader.bytes());
                        break;
                    case 3:
                        if (!(message.intermediateCerts && message.intermediateCerts.length))
                            message.intermediateCerts = [];
                        message.intermediateCerts.push(reader.bytes());
                        break;
                    case 4:
                        if (!(message.admins && message.admins.length))
                            message.admins = [];
                        message.admins.push(reader.bytes());
                        break;
                    case 5:
                        if (!(message.revocationList && message.revocationList.length))
                            message.revocationList = [];
                        message.revocationList.push(reader.bytes());
                        break;
                    case 6:
                        message.signingIdentity = $root.msp.SigningIdentityInfo.decode(reader, reader.uint32());
                        break;
                    case 7:
                        if (!(message.organizationalUnitIdentifiers && message.organizationalUnitIdentifiers.length))
                            message.organizationalUnitIdentifiers = [];
                        message.organizationalUnitIdentifiers.push($root.msp.FabricOUIdentifier.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.cryptoConfig = $root.msp.FabricCryptoConfig.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.tlsRootCerts && message.tlsRootCerts.length))
                            message.tlsRootCerts = [];
                        message.tlsRootCerts.push(reader.bytes());
                        break;
                    case 10:
                        if (!(message.tlsIntermediateCerts && message.tlsIntermediateCerts.length))
                            message.tlsIntermediateCerts = [];
                        message.tlsIntermediateCerts.push(reader.bytes());
                        break;
                    case 11:
                        message.fabricNodeOus = $root.msp.FabricNodeOUs.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FabricMSPConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.FabricMSPConfig} FabricMSPConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricMSPConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FabricMSPConfig message.
             * @function verify
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FabricMSPConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.rootCerts != null && message.hasOwnProperty("rootCerts")) {
                    if (!Array.isArray(message.rootCerts))
                        return "rootCerts: array expected";
                    for (var i = 0; i < message.rootCerts.length; ++i)
                        if (!(message.rootCerts[i] && typeof message.rootCerts[i].length === "number" || $util.isString(message.rootCerts[i])))
                            return "rootCerts: buffer[] expected";
                }
                if (message.intermediateCerts != null && message.hasOwnProperty("intermediateCerts")) {
                    if (!Array.isArray(message.intermediateCerts))
                        return "intermediateCerts: array expected";
                    for (var i = 0; i < message.intermediateCerts.length; ++i)
                        if (!(message.intermediateCerts[i] && typeof message.intermediateCerts[i].length === "number" || $util.isString(message.intermediateCerts[i])))
                            return "intermediateCerts: buffer[] expected";
                }
                if (message.admins != null && message.hasOwnProperty("admins")) {
                    if (!Array.isArray(message.admins))
                        return "admins: array expected";
                    for (var i = 0; i < message.admins.length; ++i)
                        if (!(message.admins[i] && typeof message.admins[i].length === "number" || $util.isString(message.admins[i])))
                            return "admins: buffer[] expected";
                }
                if (message.revocationList != null && message.hasOwnProperty("revocationList")) {
                    if (!Array.isArray(message.revocationList))
                        return "revocationList: array expected";
                    for (var i = 0; i < message.revocationList.length; ++i)
                        if (!(message.revocationList[i] && typeof message.revocationList[i].length === "number" || $util.isString(message.revocationList[i])))
                            return "revocationList: buffer[] expected";
                }
                if (message.signingIdentity != null && message.hasOwnProperty("signingIdentity")) {
                    var error = $root.msp.SigningIdentityInfo.verify(message.signingIdentity);
                    if (error)
                        return "signingIdentity." + error;
                }
                if (message.organizationalUnitIdentifiers != null && message.hasOwnProperty("organizationalUnitIdentifiers")) {
                    if (!Array.isArray(message.organizationalUnitIdentifiers))
                        return "organizationalUnitIdentifiers: array expected";
                    for (var i = 0; i < message.organizationalUnitIdentifiers.length; ++i) {
                        var error = $root.msp.FabricOUIdentifier.verify(message.organizationalUnitIdentifiers[i]);
                        if (error)
                            return "organizationalUnitIdentifiers." + error;
                    }
                }
                if (message.cryptoConfig != null && message.hasOwnProperty("cryptoConfig")) {
                    var error = $root.msp.FabricCryptoConfig.verify(message.cryptoConfig);
                    if (error)
                        return "cryptoConfig." + error;
                }
                if (message.tlsRootCerts != null && message.hasOwnProperty("tlsRootCerts")) {
                    if (!Array.isArray(message.tlsRootCerts))
                        return "tlsRootCerts: array expected";
                    for (var i = 0; i < message.tlsRootCerts.length; ++i)
                        if (!(message.tlsRootCerts[i] && typeof message.tlsRootCerts[i].length === "number" || $util.isString(message.tlsRootCerts[i])))
                            return "tlsRootCerts: buffer[] expected";
                }
                if (message.tlsIntermediateCerts != null && message.hasOwnProperty("tlsIntermediateCerts")) {
                    if (!Array.isArray(message.tlsIntermediateCerts))
                        return "tlsIntermediateCerts: array expected";
                    for (var i = 0; i < message.tlsIntermediateCerts.length; ++i)
                        if (!(message.tlsIntermediateCerts[i] && typeof message.tlsIntermediateCerts[i].length === "number" || $util.isString(message.tlsIntermediateCerts[i])))
                            return "tlsIntermediateCerts: buffer[] expected";
                }
                if (message.fabricNodeOus != null && message.hasOwnProperty("fabricNodeOus")) {
                    var error = $root.msp.FabricNodeOUs.verify(message.fabricNodeOus);
                    if (error)
                        return "fabricNodeOus." + error;
                }
                return null;
            };
    
            /**
             * Creates a FabricMSPConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.FabricMSPConfig} FabricMSPConfig
             */
            FabricMSPConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.FabricMSPConfig)
                    return object;
                var message = new $root.msp.FabricMSPConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.rootCerts) {
                    if (!Array.isArray(object.rootCerts))
                        throw TypeError(".msp.FabricMSPConfig.rootCerts: array expected");
                    message.rootCerts = [];
                    for (var i = 0; i < object.rootCerts.length; ++i)
                        if (typeof object.rootCerts[i] === "string")
                            $util.base64.decode(object.rootCerts[i], message.rootCerts[i] = $util.newBuffer($util.base64.length(object.rootCerts[i])), 0);
                        else if (object.rootCerts[i].length)
                            message.rootCerts[i] = object.rootCerts[i];
                }
                if (object.intermediateCerts) {
                    if (!Array.isArray(object.intermediateCerts))
                        throw TypeError(".msp.FabricMSPConfig.intermediateCerts: array expected");
                    message.intermediateCerts = [];
                    for (var i = 0; i < object.intermediateCerts.length; ++i)
                        if (typeof object.intermediateCerts[i] === "string")
                            $util.base64.decode(object.intermediateCerts[i], message.intermediateCerts[i] = $util.newBuffer($util.base64.length(object.intermediateCerts[i])), 0);
                        else if (object.intermediateCerts[i].length)
                            message.intermediateCerts[i] = object.intermediateCerts[i];
                }
                if (object.admins) {
                    if (!Array.isArray(object.admins))
                        throw TypeError(".msp.FabricMSPConfig.admins: array expected");
                    message.admins = [];
                    for (var i = 0; i < object.admins.length; ++i)
                        if (typeof object.admins[i] === "string")
                            $util.base64.decode(object.admins[i], message.admins[i] = $util.newBuffer($util.base64.length(object.admins[i])), 0);
                        else if (object.admins[i].length)
                            message.admins[i] = object.admins[i];
                }
                if (object.revocationList) {
                    if (!Array.isArray(object.revocationList))
                        throw TypeError(".msp.FabricMSPConfig.revocationList: array expected");
                    message.revocationList = [];
                    for (var i = 0; i < object.revocationList.length; ++i)
                        if (typeof object.revocationList[i] === "string")
                            $util.base64.decode(object.revocationList[i], message.revocationList[i] = $util.newBuffer($util.base64.length(object.revocationList[i])), 0);
                        else if (object.revocationList[i].length)
                            message.revocationList[i] = object.revocationList[i];
                }
                if (object.signingIdentity != null) {
                    if (typeof object.signingIdentity !== "object")
                        throw TypeError(".msp.FabricMSPConfig.signingIdentity: object expected");
                    message.signingIdentity = $root.msp.SigningIdentityInfo.fromObject(object.signingIdentity);
                }
                if (object.organizationalUnitIdentifiers) {
                    if (!Array.isArray(object.organizationalUnitIdentifiers))
                        throw TypeError(".msp.FabricMSPConfig.organizationalUnitIdentifiers: array expected");
                    message.organizationalUnitIdentifiers = [];
                    for (var i = 0; i < object.organizationalUnitIdentifiers.length; ++i) {
                        if (typeof object.organizationalUnitIdentifiers[i] !== "object")
                            throw TypeError(".msp.FabricMSPConfig.organizationalUnitIdentifiers: object expected");
                        message.organizationalUnitIdentifiers[i] = $root.msp.FabricOUIdentifier.fromObject(object.organizationalUnitIdentifiers[i]);
                    }
                }
                if (object.cryptoConfig != null) {
                    if (typeof object.cryptoConfig !== "object")
                        throw TypeError(".msp.FabricMSPConfig.cryptoConfig: object expected");
                    message.cryptoConfig = $root.msp.FabricCryptoConfig.fromObject(object.cryptoConfig);
                }
                if (object.tlsRootCerts) {
                    if (!Array.isArray(object.tlsRootCerts))
                        throw TypeError(".msp.FabricMSPConfig.tlsRootCerts: array expected");
                    message.tlsRootCerts = [];
                    for (var i = 0; i < object.tlsRootCerts.length; ++i)
                        if (typeof object.tlsRootCerts[i] === "string")
                            $util.base64.decode(object.tlsRootCerts[i], message.tlsRootCerts[i] = $util.newBuffer($util.base64.length(object.tlsRootCerts[i])), 0);
                        else if (object.tlsRootCerts[i].length)
                            message.tlsRootCerts[i] = object.tlsRootCerts[i];
                }
                if (object.tlsIntermediateCerts) {
                    if (!Array.isArray(object.tlsIntermediateCerts))
                        throw TypeError(".msp.FabricMSPConfig.tlsIntermediateCerts: array expected");
                    message.tlsIntermediateCerts = [];
                    for (var i = 0; i < object.tlsIntermediateCerts.length; ++i)
                        if (typeof object.tlsIntermediateCerts[i] === "string")
                            $util.base64.decode(object.tlsIntermediateCerts[i], message.tlsIntermediateCerts[i] = $util.newBuffer($util.base64.length(object.tlsIntermediateCerts[i])), 0);
                        else if (object.tlsIntermediateCerts[i].length)
                            message.tlsIntermediateCerts[i] = object.tlsIntermediateCerts[i];
                }
                if (object.fabricNodeOus != null) {
                    if (typeof object.fabricNodeOus !== "object")
                        throw TypeError(".msp.FabricMSPConfig.fabricNodeOus: object expected");
                    message.fabricNodeOus = $root.msp.FabricNodeOUs.fromObject(object.fabricNodeOus);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FabricMSPConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.FabricMSPConfig
             * @static
             * @param {msp.FabricMSPConfig} message FabricMSPConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FabricMSPConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.rootCerts = [];
                    object.intermediateCerts = [];
                    object.admins = [];
                    object.revocationList = [];
                    object.organizationalUnitIdentifiers = [];
                    object.tlsRootCerts = [];
                    object.tlsIntermediateCerts = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.signingIdentity = null;
                    object.cryptoConfig = null;
                    object.fabricNodeOus = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.rootCerts && message.rootCerts.length) {
                    object.rootCerts = [];
                    for (var j = 0; j < message.rootCerts.length; ++j)
                        object.rootCerts[j] = options.bytes === String ? $util.base64.encode(message.rootCerts[j], 0, message.rootCerts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.rootCerts[j]) : message.rootCerts[j];
                }
                if (message.intermediateCerts && message.intermediateCerts.length) {
                    object.intermediateCerts = [];
                    for (var j = 0; j < message.intermediateCerts.length; ++j)
                        object.intermediateCerts[j] = options.bytes === String ? $util.base64.encode(message.intermediateCerts[j], 0, message.intermediateCerts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.intermediateCerts[j]) : message.intermediateCerts[j];
                }
                if (message.admins && message.admins.length) {
                    object.admins = [];
                    for (var j = 0; j < message.admins.length; ++j)
                        object.admins[j] = options.bytes === String ? $util.base64.encode(message.admins[j], 0, message.admins[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.admins[j]) : message.admins[j];
                }
                if (message.revocationList && message.revocationList.length) {
                    object.revocationList = [];
                    for (var j = 0; j < message.revocationList.length; ++j)
                        object.revocationList[j] = options.bytes === String ? $util.base64.encode(message.revocationList[j], 0, message.revocationList[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.revocationList[j]) : message.revocationList[j];
                }
                if (message.signingIdentity != null && message.hasOwnProperty("signingIdentity"))
                    object.signingIdentity = $root.msp.SigningIdentityInfo.toObject(message.signingIdentity, options);
                if (message.organizationalUnitIdentifiers && message.organizationalUnitIdentifiers.length) {
                    object.organizationalUnitIdentifiers = [];
                    for (var j = 0; j < message.organizationalUnitIdentifiers.length; ++j)
                        object.organizationalUnitIdentifiers[j] = $root.msp.FabricOUIdentifier.toObject(message.organizationalUnitIdentifiers[j], options);
                }
                if (message.cryptoConfig != null && message.hasOwnProperty("cryptoConfig"))
                    object.cryptoConfig = $root.msp.FabricCryptoConfig.toObject(message.cryptoConfig, options);
                if (message.tlsRootCerts && message.tlsRootCerts.length) {
                    object.tlsRootCerts = [];
                    for (var j = 0; j < message.tlsRootCerts.length; ++j)
                        object.tlsRootCerts[j] = options.bytes === String ? $util.base64.encode(message.tlsRootCerts[j], 0, message.tlsRootCerts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsRootCerts[j]) : message.tlsRootCerts[j];
                }
                if (message.tlsIntermediateCerts && message.tlsIntermediateCerts.length) {
                    object.tlsIntermediateCerts = [];
                    for (var j = 0; j < message.tlsIntermediateCerts.length; ++j)
                        object.tlsIntermediateCerts[j] = options.bytes === String ? $util.base64.encode(message.tlsIntermediateCerts[j], 0, message.tlsIntermediateCerts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsIntermediateCerts[j]) : message.tlsIntermediateCerts[j];
                }
                if (message.fabricNodeOus != null && message.hasOwnProperty("fabricNodeOus"))
                    object.fabricNodeOus = $root.msp.FabricNodeOUs.toObject(message.fabricNodeOus, options);
                return object;
            };
    
            /**
             * Converts this FabricMSPConfig to JSON.
             * @function toJSON
             * @memberof msp.FabricMSPConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FabricMSPConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FabricMSPConfig;
        })();
    
        msp.FabricCryptoConfig = (function() {
    
            /**
             * Properties of a FabricCryptoConfig.
             * @memberof msp
             * @interface IFabricCryptoConfig
             * @property {string|null} [signatureHashFamily] FabricCryptoConfig signatureHashFamily
             * @property {string|null} [identityIdentifierHashFunction] FabricCryptoConfig identityIdentifierHashFunction
             */
    
            /**
             * Constructs a new FabricCryptoConfig.
             * @memberof msp
             * @classdesc Represents a FabricCryptoConfig.
             * @implements IFabricCryptoConfig
             * @constructor
             * @param {msp.IFabricCryptoConfig=} [properties] Properties to set
             */
            function FabricCryptoConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FabricCryptoConfig signatureHashFamily.
             * @member {string} signatureHashFamily
             * @memberof msp.FabricCryptoConfig
             * @instance
             */
            FabricCryptoConfig.prototype.signatureHashFamily = "";
    
            /**
             * FabricCryptoConfig identityIdentifierHashFunction.
             * @member {string} identityIdentifierHashFunction
             * @memberof msp.FabricCryptoConfig
             * @instance
             */
            FabricCryptoConfig.prototype.identityIdentifierHashFunction = "";
    
            /**
             * Creates a new FabricCryptoConfig instance using the specified properties.
             * @function create
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {msp.IFabricCryptoConfig=} [properties] Properties to set
             * @returns {msp.FabricCryptoConfig} FabricCryptoConfig instance
             */
            FabricCryptoConfig.create = function create(properties) {
                return new FabricCryptoConfig(properties);
            };
    
            /**
             * Encodes the specified FabricCryptoConfig message. Does not implicitly {@link msp.FabricCryptoConfig.verify|verify} messages.
             * @function encode
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {msp.IFabricCryptoConfig} message FabricCryptoConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricCryptoConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signatureHashFamily != null && message.hasOwnProperty("signatureHashFamily"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.signatureHashFamily);
                if (message.identityIdentifierHashFunction != null && message.hasOwnProperty("identityIdentifierHashFunction"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.identityIdentifierHashFunction);
                return writer;
            };
    
            /**
             * Encodes the specified FabricCryptoConfig message, length delimited. Does not implicitly {@link msp.FabricCryptoConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {msp.IFabricCryptoConfig} message FabricCryptoConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricCryptoConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FabricCryptoConfig message from the specified reader or buffer.
             * @function decode
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.FabricCryptoConfig} FabricCryptoConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricCryptoConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.FabricCryptoConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signatureHashFamily = reader.string();
                        break;
                    case 2:
                        message.identityIdentifierHashFunction = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FabricCryptoConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.FabricCryptoConfig} FabricCryptoConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricCryptoConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FabricCryptoConfig message.
             * @function verify
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FabricCryptoConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.signatureHashFamily != null && message.hasOwnProperty("signatureHashFamily"))
                    if (!$util.isString(message.signatureHashFamily))
                        return "signatureHashFamily: string expected";
                if (message.identityIdentifierHashFunction != null && message.hasOwnProperty("identityIdentifierHashFunction"))
                    if (!$util.isString(message.identityIdentifierHashFunction))
                        return "identityIdentifierHashFunction: string expected";
                return null;
            };
    
            /**
             * Creates a FabricCryptoConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.FabricCryptoConfig} FabricCryptoConfig
             */
            FabricCryptoConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.FabricCryptoConfig)
                    return object;
                var message = new $root.msp.FabricCryptoConfig();
                if (object.signatureHashFamily != null)
                    message.signatureHashFamily = String(object.signatureHashFamily);
                if (object.identityIdentifierHashFunction != null)
                    message.identityIdentifierHashFunction = String(object.identityIdentifierHashFunction);
                return message;
            };
    
            /**
             * Creates a plain object from a FabricCryptoConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.FabricCryptoConfig
             * @static
             * @param {msp.FabricCryptoConfig} message FabricCryptoConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FabricCryptoConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.signatureHashFamily = "";
                    object.identityIdentifierHashFunction = "";
                }
                if (message.signatureHashFamily != null && message.hasOwnProperty("signatureHashFamily"))
                    object.signatureHashFamily = message.signatureHashFamily;
                if (message.identityIdentifierHashFunction != null && message.hasOwnProperty("identityIdentifierHashFunction"))
                    object.identityIdentifierHashFunction = message.identityIdentifierHashFunction;
                return object;
            };
    
            /**
             * Converts this FabricCryptoConfig to JSON.
             * @function toJSON
             * @memberof msp.FabricCryptoConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FabricCryptoConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FabricCryptoConfig;
        })();
    
        msp.IdemixMSPConfig = (function() {
    
            /**
             * Properties of an IdemixMSPConfig.
             * @memberof msp
             * @interface IIdemixMSPConfig
             * @property {string|null} [name] IdemixMSPConfig name
             * @property {Uint8Array|null} [ipk] IdemixMSPConfig ipk
             * @property {msp.IIdemixMSPSignerConfig|null} [signer] IdemixMSPConfig signer
             * @property {Uint8Array|null} [revocationPk] IdemixMSPConfig revocationPk
             * @property {number|Long|null} [epoch] IdemixMSPConfig epoch
             */
    
            /**
             * Constructs a new IdemixMSPConfig.
             * @memberof msp
             * @classdesc Represents an IdemixMSPConfig.
             * @implements IIdemixMSPConfig
             * @constructor
             * @param {msp.IIdemixMSPConfig=} [properties] Properties to set
             */
            function IdemixMSPConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * IdemixMSPConfig name.
             * @member {string} name
             * @memberof msp.IdemixMSPConfig
             * @instance
             */
            IdemixMSPConfig.prototype.name = "";
    
            /**
             * IdemixMSPConfig ipk.
             * @member {Uint8Array} ipk
             * @memberof msp.IdemixMSPConfig
             * @instance
             */
            IdemixMSPConfig.prototype.ipk = $util.newBuffer([]);
    
            /**
             * IdemixMSPConfig signer.
             * @member {msp.IIdemixMSPSignerConfig|null|undefined} signer
             * @memberof msp.IdemixMSPConfig
             * @instance
             */
            IdemixMSPConfig.prototype.signer = null;
    
            /**
             * IdemixMSPConfig revocationPk.
             * @member {Uint8Array} revocationPk
             * @memberof msp.IdemixMSPConfig
             * @instance
             */
            IdemixMSPConfig.prototype.revocationPk = $util.newBuffer([]);
    
            /**
             * IdemixMSPConfig epoch.
             * @member {number|Long} epoch
             * @memberof msp.IdemixMSPConfig
             * @instance
             */
            IdemixMSPConfig.prototype.epoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new IdemixMSPConfig instance using the specified properties.
             * @function create
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {msp.IIdemixMSPConfig=} [properties] Properties to set
             * @returns {msp.IdemixMSPConfig} IdemixMSPConfig instance
             */
            IdemixMSPConfig.create = function create(properties) {
                return new IdemixMSPConfig(properties);
            };
    
            /**
             * Encodes the specified IdemixMSPConfig message. Does not implicitly {@link msp.IdemixMSPConfig.verify|verify} messages.
             * @function encode
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {msp.IIdemixMSPConfig} message IdemixMSPConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IdemixMSPConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.ipk != null && message.hasOwnProperty("ipk"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ipk);
                if (message.signer != null && message.hasOwnProperty("signer"))
                    $root.msp.IdemixMSPSignerConfig.encode(message.signer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.revocationPk != null && message.hasOwnProperty("revocationPk"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.revocationPk);
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.epoch);
                return writer;
            };
    
            /**
             * Encodes the specified IdemixMSPConfig message, length delimited. Does not implicitly {@link msp.IdemixMSPConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {msp.IIdemixMSPConfig} message IdemixMSPConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IdemixMSPConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an IdemixMSPConfig message from the specified reader or buffer.
             * @function decode
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.IdemixMSPConfig} IdemixMSPConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IdemixMSPConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.IdemixMSPConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.ipk = reader.bytes();
                        break;
                    case 3:
                        message.signer = $root.msp.IdemixMSPSignerConfig.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.revocationPk = reader.bytes();
                        break;
                    case 5:
                        message.epoch = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an IdemixMSPConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.IdemixMSPConfig} IdemixMSPConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IdemixMSPConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an IdemixMSPConfig message.
             * @function verify
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IdemixMSPConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.ipk != null && message.hasOwnProperty("ipk"))
                    if (!(message.ipk && typeof message.ipk.length === "number" || $util.isString(message.ipk)))
                        return "ipk: buffer expected";
                if (message.signer != null && message.hasOwnProperty("signer")) {
                    var error = $root.msp.IdemixMSPSignerConfig.verify(message.signer);
                    if (error)
                        return "signer." + error;
                }
                if (message.revocationPk != null && message.hasOwnProperty("revocationPk"))
                    if (!(message.revocationPk && typeof message.revocationPk.length === "number" || $util.isString(message.revocationPk)))
                        return "revocationPk: buffer expected";
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    if (!$util.isInteger(message.epoch) && !(message.epoch && $util.isInteger(message.epoch.low) && $util.isInteger(message.epoch.high)))
                        return "epoch: integer|Long expected";
                return null;
            };
    
            /**
             * Creates an IdemixMSPConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.IdemixMSPConfig} IdemixMSPConfig
             */
            IdemixMSPConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.IdemixMSPConfig)
                    return object;
                var message = new $root.msp.IdemixMSPConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.ipk != null)
                    if (typeof object.ipk === "string")
                        $util.base64.decode(object.ipk, message.ipk = $util.newBuffer($util.base64.length(object.ipk)), 0);
                    else if (object.ipk.length)
                        message.ipk = object.ipk;
                if (object.signer != null) {
                    if (typeof object.signer !== "object")
                        throw TypeError(".msp.IdemixMSPConfig.signer: object expected");
                    message.signer = $root.msp.IdemixMSPSignerConfig.fromObject(object.signer);
                }
                if (object.revocationPk != null)
                    if (typeof object.revocationPk === "string")
                        $util.base64.decode(object.revocationPk, message.revocationPk = $util.newBuffer($util.base64.length(object.revocationPk)), 0);
                    else if (object.revocationPk.length)
                        message.revocationPk = object.revocationPk;
                if (object.epoch != null)
                    if ($util.Long)
                        (message.epoch = $util.Long.fromValue(object.epoch)).unsigned = false;
                    else if (typeof object.epoch === "string")
                        message.epoch = parseInt(object.epoch, 10);
                    else if (typeof object.epoch === "number")
                        message.epoch = object.epoch;
                    else if (typeof object.epoch === "object")
                        message.epoch = new $util.LongBits(object.epoch.low >>> 0, object.epoch.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from an IdemixMSPConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.IdemixMSPConfig
             * @static
             * @param {msp.IdemixMSPConfig} message IdemixMSPConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IdemixMSPConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    if (options.bytes === String)
                        object.ipk = "";
                    else {
                        object.ipk = [];
                        if (options.bytes !== Array)
                            object.ipk = $util.newBuffer(object.ipk);
                    }
                    object.signer = null;
                    if (options.bytes === String)
                        object.revocationPk = "";
                    else {
                        object.revocationPk = [];
                        if (options.bytes !== Array)
                            object.revocationPk = $util.newBuffer(object.revocationPk);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.epoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.epoch = options.longs === String ? "0" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.ipk != null && message.hasOwnProperty("ipk"))
                    object.ipk = options.bytes === String ? $util.base64.encode(message.ipk, 0, message.ipk.length) : options.bytes === Array ? Array.prototype.slice.call(message.ipk) : message.ipk;
                if (message.signer != null && message.hasOwnProperty("signer"))
                    object.signer = $root.msp.IdemixMSPSignerConfig.toObject(message.signer, options);
                if (message.revocationPk != null && message.hasOwnProperty("revocationPk"))
                    object.revocationPk = options.bytes === String ? $util.base64.encode(message.revocationPk, 0, message.revocationPk.length) : options.bytes === Array ? Array.prototype.slice.call(message.revocationPk) : message.revocationPk;
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    if (typeof message.epoch === "number")
                        object.epoch = options.longs === String ? String(message.epoch) : message.epoch;
                    else
                        object.epoch = options.longs === String ? $util.Long.prototype.toString.call(message.epoch) : options.longs === Number ? new $util.LongBits(message.epoch.low >>> 0, message.epoch.high >>> 0).toNumber() : message.epoch;
                return object;
            };
    
            /**
             * Converts this IdemixMSPConfig to JSON.
             * @function toJSON
             * @memberof msp.IdemixMSPConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IdemixMSPConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return IdemixMSPConfig;
        })();
    
        msp.IdemixMSPSignerConfig = (function() {
    
            /**
             * Properties of an IdemixMSPSignerConfig.
             * @memberof msp
             * @interface IIdemixMSPSignerConfig
             * @property {Uint8Array|null} [cred] IdemixMSPSignerConfig cred
             * @property {Uint8Array|null} [sk] IdemixMSPSignerConfig sk
             * @property {string|null} [organizationalUnitIdentifier] IdemixMSPSignerConfig organizationalUnitIdentifier
             * @property {number|null} [role] IdemixMSPSignerConfig role
             * @property {string|null} [enrollmentId] IdemixMSPSignerConfig enrollmentId
             * @property {Uint8Array|null} [credentialRevocationInformation] IdemixMSPSignerConfig credentialRevocationInformation
             */
    
            /**
             * Constructs a new IdemixMSPSignerConfig.
             * @memberof msp
             * @classdesc Represents an IdemixMSPSignerConfig.
             * @implements IIdemixMSPSignerConfig
             * @constructor
             * @param {msp.IIdemixMSPSignerConfig=} [properties] Properties to set
             */
            function IdemixMSPSignerConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * IdemixMSPSignerConfig cred.
             * @member {Uint8Array} cred
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             */
            IdemixMSPSignerConfig.prototype.cred = $util.newBuffer([]);
    
            /**
             * IdemixMSPSignerConfig sk.
             * @member {Uint8Array} sk
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             */
            IdemixMSPSignerConfig.prototype.sk = $util.newBuffer([]);
    
            /**
             * IdemixMSPSignerConfig organizationalUnitIdentifier.
             * @member {string} organizationalUnitIdentifier
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             */
            IdemixMSPSignerConfig.prototype.organizationalUnitIdentifier = "";
    
            /**
             * IdemixMSPSignerConfig role.
             * @member {number} role
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             */
            IdemixMSPSignerConfig.prototype.role = 0;
    
            /**
             * IdemixMSPSignerConfig enrollmentId.
             * @member {string} enrollmentId
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             */
            IdemixMSPSignerConfig.prototype.enrollmentId = "";
    
            /**
             * IdemixMSPSignerConfig credentialRevocationInformation.
             * @member {Uint8Array} credentialRevocationInformation
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             */
            IdemixMSPSignerConfig.prototype.credentialRevocationInformation = $util.newBuffer([]);
    
            /**
             * Creates a new IdemixMSPSignerConfig instance using the specified properties.
             * @function create
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {msp.IIdemixMSPSignerConfig=} [properties] Properties to set
             * @returns {msp.IdemixMSPSignerConfig} IdemixMSPSignerConfig instance
             */
            IdemixMSPSignerConfig.create = function create(properties) {
                return new IdemixMSPSignerConfig(properties);
            };
    
            /**
             * Encodes the specified IdemixMSPSignerConfig message. Does not implicitly {@link msp.IdemixMSPSignerConfig.verify|verify} messages.
             * @function encode
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {msp.IIdemixMSPSignerConfig} message IdemixMSPSignerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IdemixMSPSignerConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cred != null && message.hasOwnProperty("cred"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.cred);
                if (message.sk != null && message.hasOwnProperty("sk"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sk);
                if (message.organizationalUnitIdentifier != null && message.hasOwnProperty("organizationalUnitIdentifier"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.organizationalUnitIdentifier);
                if (message.role != null && message.hasOwnProperty("role"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.role);
                if (message.enrollmentId != null && message.hasOwnProperty("enrollmentId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.enrollmentId);
                if (message.credentialRevocationInformation != null && message.hasOwnProperty("credentialRevocationInformation"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.credentialRevocationInformation);
                return writer;
            };
    
            /**
             * Encodes the specified IdemixMSPSignerConfig message, length delimited. Does not implicitly {@link msp.IdemixMSPSignerConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {msp.IIdemixMSPSignerConfig} message IdemixMSPSignerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IdemixMSPSignerConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an IdemixMSPSignerConfig message from the specified reader or buffer.
             * @function decode
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.IdemixMSPSignerConfig} IdemixMSPSignerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IdemixMSPSignerConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.IdemixMSPSignerConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.cred = reader.bytes();
                        break;
                    case 2:
                        message.sk = reader.bytes();
                        break;
                    case 3:
                        message.organizationalUnitIdentifier = reader.string();
                        break;
                    case 4:
                        message.role = reader.int32();
                        break;
                    case 5:
                        message.enrollmentId = reader.string();
                        break;
                    case 6:
                        message.credentialRevocationInformation = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an IdemixMSPSignerConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.IdemixMSPSignerConfig} IdemixMSPSignerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IdemixMSPSignerConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an IdemixMSPSignerConfig message.
             * @function verify
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IdemixMSPSignerConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cred != null && message.hasOwnProperty("cred"))
                    if (!(message.cred && typeof message.cred.length === "number" || $util.isString(message.cred)))
                        return "cred: buffer expected";
                if (message.sk != null && message.hasOwnProperty("sk"))
                    if (!(message.sk && typeof message.sk.length === "number" || $util.isString(message.sk)))
                        return "sk: buffer expected";
                if (message.organizationalUnitIdentifier != null && message.hasOwnProperty("organizationalUnitIdentifier"))
                    if (!$util.isString(message.organizationalUnitIdentifier))
                        return "organizationalUnitIdentifier: string expected";
                if (message.role != null && message.hasOwnProperty("role"))
                    if (!$util.isInteger(message.role))
                        return "role: integer expected";
                if (message.enrollmentId != null && message.hasOwnProperty("enrollmentId"))
                    if (!$util.isString(message.enrollmentId))
                        return "enrollmentId: string expected";
                if (message.credentialRevocationInformation != null && message.hasOwnProperty("credentialRevocationInformation"))
                    if (!(message.credentialRevocationInformation && typeof message.credentialRevocationInformation.length === "number" || $util.isString(message.credentialRevocationInformation)))
                        return "credentialRevocationInformation: buffer expected";
                return null;
            };
    
            /**
             * Creates an IdemixMSPSignerConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.IdemixMSPSignerConfig} IdemixMSPSignerConfig
             */
            IdemixMSPSignerConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.IdemixMSPSignerConfig)
                    return object;
                var message = new $root.msp.IdemixMSPSignerConfig();
                if (object.cred != null)
                    if (typeof object.cred === "string")
                        $util.base64.decode(object.cred, message.cred = $util.newBuffer($util.base64.length(object.cred)), 0);
                    else if (object.cred.length)
                        message.cred = object.cred;
                if (object.sk != null)
                    if (typeof object.sk === "string")
                        $util.base64.decode(object.sk, message.sk = $util.newBuffer($util.base64.length(object.sk)), 0);
                    else if (object.sk.length)
                        message.sk = object.sk;
                if (object.organizationalUnitIdentifier != null)
                    message.organizationalUnitIdentifier = String(object.organizationalUnitIdentifier);
                if (object.role != null)
                    message.role = object.role | 0;
                if (object.enrollmentId != null)
                    message.enrollmentId = String(object.enrollmentId);
                if (object.credentialRevocationInformation != null)
                    if (typeof object.credentialRevocationInformation === "string")
                        $util.base64.decode(object.credentialRevocationInformation, message.credentialRevocationInformation = $util.newBuffer($util.base64.length(object.credentialRevocationInformation)), 0);
                    else if (object.credentialRevocationInformation.length)
                        message.credentialRevocationInformation = object.credentialRevocationInformation;
                return message;
            };
    
            /**
             * Creates a plain object from an IdemixMSPSignerConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.IdemixMSPSignerConfig
             * @static
             * @param {msp.IdemixMSPSignerConfig} message IdemixMSPSignerConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IdemixMSPSignerConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.cred = "";
                    else {
                        object.cred = [];
                        if (options.bytes !== Array)
                            object.cred = $util.newBuffer(object.cred);
                    }
                    if (options.bytes === String)
                        object.sk = "";
                    else {
                        object.sk = [];
                        if (options.bytes !== Array)
                            object.sk = $util.newBuffer(object.sk);
                    }
                    object.organizationalUnitIdentifier = "";
                    object.role = 0;
                    object.enrollmentId = "";
                    if (options.bytes === String)
                        object.credentialRevocationInformation = "";
                    else {
                        object.credentialRevocationInformation = [];
                        if (options.bytes !== Array)
                            object.credentialRevocationInformation = $util.newBuffer(object.credentialRevocationInformation);
                    }
                }
                if (message.cred != null && message.hasOwnProperty("cred"))
                    object.cred = options.bytes === String ? $util.base64.encode(message.cred, 0, message.cred.length) : options.bytes === Array ? Array.prototype.slice.call(message.cred) : message.cred;
                if (message.sk != null && message.hasOwnProperty("sk"))
                    object.sk = options.bytes === String ? $util.base64.encode(message.sk, 0, message.sk.length) : options.bytes === Array ? Array.prototype.slice.call(message.sk) : message.sk;
                if (message.organizationalUnitIdentifier != null && message.hasOwnProperty("organizationalUnitIdentifier"))
                    object.organizationalUnitIdentifier = message.organizationalUnitIdentifier;
                if (message.role != null && message.hasOwnProperty("role"))
                    object.role = message.role;
                if (message.enrollmentId != null && message.hasOwnProperty("enrollmentId"))
                    object.enrollmentId = message.enrollmentId;
                if (message.credentialRevocationInformation != null && message.hasOwnProperty("credentialRevocationInformation"))
                    object.credentialRevocationInformation = options.bytes === String ? $util.base64.encode(message.credentialRevocationInformation, 0, message.credentialRevocationInformation.length) : options.bytes === Array ? Array.prototype.slice.call(message.credentialRevocationInformation) : message.credentialRevocationInformation;
                return object;
            };
    
            /**
             * Converts this IdemixMSPSignerConfig to JSON.
             * @function toJSON
             * @memberof msp.IdemixMSPSignerConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IdemixMSPSignerConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return IdemixMSPSignerConfig;
        })();
    
        msp.SigningIdentityInfo = (function() {
    
            /**
             * Properties of a SigningIdentityInfo.
             * @memberof msp
             * @interface ISigningIdentityInfo
             * @property {Uint8Array|null} [publicSigner] SigningIdentityInfo publicSigner
             * @property {msp.IKeyInfo|null} [privateSigner] SigningIdentityInfo privateSigner
             */
    
            /**
             * Constructs a new SigningIdentityInfo.
             * @memberof msp
             * @classdesc Represents a SigningIdentityInfo.
             * @implements ISigningIdentityInfo
             * @constructor
             * @param {msp.ISigningIdentityInfo=} [properties] Properties to set
             */
            function SigningIdentityInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SigningIdentityInfo publicSigner.
             * @member {Uint8Array} publicSigner
             * @memberof msp.SigningIdentityInfo
             * @instance
             */
            SigningIdentityInfo.prototype.publicSigner = $util.newBuffer([]);
    
            /**
             * SigningIdentityInfo privateSigner.
             * @member {msp.IKeyInfo|null|undefined} privateSigner
             * @memberof msp.SigningIdentityInfo
             * @instance
             */
            SigningIdentityInfo.prototype.privateSigner = null;
    
            /**
             * Creates a new SigningIdentityInfo instance using the specified properties.
             * @function create
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {msp.ISigningIdentityInfo=} [properties] Properties to set
             * @returns {msp.SigningIdentityInfo} SigningIdentityInfo instance
             */
            SigningIdentityInfo.create = function create(properties) {
                return new SigningIdentityInfo(properties);
            };
    
            /**
             * Encodes the specified SigningIdentityInfo message. Does not implicitly {@link msp.SigningIdentityInfo.verify|verify} messages.
             * @function encode
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {msp.ISigningIdentityInfo} message SigningIdentityInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SigningIdentityInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.publicSigner != null && message.hasOwnProperty("publicSigner"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicSigner);
                if (message.privateSigner != null && message.hasOwnProperty("privateSigner"))
                    $root.msp.KeyInfo.encode(message.privateSigner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SigningIdentityInfo message, length delimited. Does not implicitly {@link msp.SigningIdentityInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {msp.ISigningIdentityInfo} message SigningIdentityInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SigningIdentityInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SigningIdentityInfo message from the specified reader or buffer.
             * @function decode
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.SigningIdentityInfo} SigningIdentityInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SigningIdentityInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.SigningIdentityInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.publicSigner = reader.bytes();
                        break;
                    case 2:
                        message.privateSigner = $root.msp.KeyInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SigningIdentityInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.SigningIdentityInfo} SigningIdentityInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SigningIdentityInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SigningIdentityInfo message.
             * @function verify
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SigningIdentityInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.publicSigner != null && message.hasOwnProperty("publicSigner"))
                    if (!(message.publicSigner && typeof message.publicSigner.length === "number" || $util.isString(message.publicSigner)))
                        return "publicSigner: buffer expected";
                if (message.privateSigner != null && message.hasOwnProperty("privateSigner")) {
                    var error = $root.msp.KeyInfo.verify(message.privateSigner);
                    if (error)
                        return "privateSigner." + error;
                }
                return null;
            };
    
            /**
             * Creates a SigningIdentityInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.SigningIdentityInfo} SigningIdentityInfo
             */
            SigningIdentityInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.SigningIdentityInfo)
                    return object;
                var message = new $root.msp.SigningIdentityInfo();
                if (object.publicSigner != null)
                    if (typeof object.publicSigner === "string")
                        $util.base64.decode(object.publicSigner, message.publicSigner = $util.newBuffer($util.base64.length(object.publicSigner)), 0);
                    else if (object.publicSigner.length)
                        message.publicSigner = object.publicSigner;
                if (object.privateSigner != null) {
                    if (typeof object.privateSigner !== "object")
                        throw TypeError(".msp.SigningIdentityInfo.privateSigner: object expected");
                    message.privateSigner = $root.msp.KeyInfo.fromObject(object.privateSigner);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SigningIdentityInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.SigningIdentityInfo
             * @static
             * @param {msp.SigningIdentityInfo} message SigningIdentityInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SigningIdentityInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.publicSigner = "";
                    else {
                        object.publicSigner = [];
                        if (options.bytes !== Array)
                            object.publicSigner = $util.newBuffer(object.publicSigner);
                    }
                    object.privateSigner = null;
                }
                if (message.publicSigner != null && message.hasOwnProperty("publicSigner"))
                    object.publicSigner = options.bytes === String ? $util.base64.encode(message.publicSigner, 0, message.publicSigner.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicSigner) : message.publicSigner;
                if (message.privateSigner != null && message.hasOwnProperty("privateSigner"))
                    object.privateSigner = $root.msp.KeyInfo.toObject(message.privateSigner, options);
                return object;
            };
    
            /**
             * Converts this SigningIdentityInfo to JSON.
             * @function toJSON
             * @memberof msp.SigningIdentityInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SigningIdentityInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SigningIdentityInfo;
        })();
    
        msp.KeyInfo = (function() {
    
            /**
             * Properties of a KeyInfo.
             * @memberof msp
             * @interface IKeyInfo
             * @property {string|null} [keyIdentifier] KeyInfo keyIdentifier
             * @property {Uint8Array|null} [keyMaterial] KeyInfo keyMaterial
             */
    
            /**
             * Constructs a new KeyInfo.
             * @memberof msp
             * @classdesc Represents a KeyInfo.
             * @implements IKeyInfo
             * @constructor
             * @param {msp.IKeyInfo=} [properties] Properties to set
             */
            function KeyInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KeyInfo keyIdentifier.
             * @member {string} keyIdentifier
             * @memberof msp.KeyInfo
             * @instance
             */
            KeyInfo.prototype.keyIdentifier = "";
    
            /**
             * KeyInfo keyMaterial.
             * @member {Uint8Array} keyMaterial
             * @memberof msp.KeyInfo
             * @instance
             */
            KeyInfo.prototype.keyMaterial = $util.newBuffer([]);
    
            /**
             * Creates a new KeyInfo instance using the specified properties.
             * @function create
             * @memberof msp.KeyInfo
             * @static
             * @param {msp.IKeyInfo=} [properties] Properties to set
             * @returns {msp.KeyInfo} KeyInfo instance
             */
            KeyInfo.create = function create(properties) {
                return new KeyInfo(properties);
            };
    
            /**
             * Encodes the specified KeyInfo message. Does not implicitly {@link msp.KeyInfo.verify|verify} messages.
             * @function encode
             * @memberof msp.KeyInfo
             * @static
             * @param {msp.IKeyInfo} message KeyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keyIdentifier != null && message.hasOwnProperty("keyIdentifier"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyIdentifier);
                if (message.keyMaterial != null && message.hasOwnProperty("keyMaterial"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.keyMaterial);
                return writer;
            };
    
            /**
             * Encodes the specified KeyInfo message, length delimited. Does not implicitly {@link msp.KeyInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.KeyInfo
             * @static
             * @param {msp.IKeyInfo} message KeyInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KeyInfo message from the specified reader or buffer.
             * @function decode
             * @memberof msp.KeyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.KeyInfo} KeyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.KeyInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.keyIdentifier = reader.string();
                        break;
                    case 2:
                        message.keyMaterial = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KeyInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.KeyInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.KeyInfo} KeyInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KeyInfo message.
             * @function verify
             * @memberof msp.KeyInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keyIdentifier != null && message.hasOwnProperty("keyIdentifier"))
                    if (!$util.isString(message.keyIdentifier))
                        return "keyIdentifier: string expected";
                if (message.keyMaterial != null && message.hasOwnProperty("keyMaterial"))
                    if (!(message.keyMaterial && typeof message.keyMaterial.length === "number" || $util.isString(message.keyMaterial)))
                        return "keyMaterial: buffer expected";
                return null;
            };
    
            /**
             * Creates a KeyInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.KeyInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.KeyInfo} KeyInfo
             */
            KeyInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.KeyInfo)
                    return object;
                var message = new $root.msp.KeyInfo();
                if (object.keyIdentifier != null)
                    message.keyIdentifier = String(object.keyIdentifier);
                if (object.keyMaterial != null)
                    if (typeof object.keyMaterial === "string")
                        $util.base64.decode(object.keyMaterial, message.keyMaterial = $util.newBuffer($util.base64.length(object.keyMaterial)), 0);
                    else if (object.keyMaterial.length)
                        message.keyMaterial = object.keyMaterial;
                return message;
            };
    
            /**
             * Creates a plain object from a KeyInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.KeyInfo
             * @static
             * @param {msp.KeyInfo} message KeyInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.keyIdentifier = "";
                    if (options.bytes === String)
                        object.keyMaterial = "";
                    else {
                        object.keyMaterial = [];
                        if (options.bytes !== Array)
                            object.keyMaterial = $util.newBuffer(object.keyMaterial);
                    }
                }
                if (message.keyIdentifier != null && message.hasOwnProperty("keyIdentifier"))
                    object.keyIdentifier = message.keyIdentifier;
                if (message.keyMaterial != null && message.hasOwnProperty("keyMaterial"))
                    object.keyMaterial = options.bytes === String ? $util.base64.encode(message.keyMaterial, 0, message.keyMaterial.length) : options.bytes === Array ? Array.prototype.slice.call(message.keyMaterial) : message.keyMaterial;
                return object;
            };
    
            /**
             * Converts this KeyInfo to JSON.
             * @function toJSON
             * @memberof msp.KeyInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KeyInfo;
        })();
    
        msp.FabricOUIdentifier = (function() {
    
            /**
             * Properties of a FabricOUIdentifier.
             * @memberof msp
             * @interface IFabricOUIdentifier
             * @property {Uint8Array|null} [certificate] FabricOUIdentifier certificate
             * @property {string|null} [organizationalUnitIdentifier] FabricOUIdentifier organizationalUnitIdentifier
             */
    
            /**
             * Constructs a new FabricOUIdentifier.
             * @memberof msp
             * @classdesc Represents a FabricOUIdentifier.
             * @implements IFabricOUIdentifier
             * @constructor
             * @param {msp.IFabricOUIdentifier=} [properties] Properties to set
             */
            function FabricOUIdentifier(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FabricOUIdentifier certificate.
             * @member {Uint8Array} certificate
             * @memberof msp.FabricOUIdentifier
             * @instance
             */
            FabricOUIdentifier.prototype.certificate = $util.newBuffer([]);
    
            /**
             * FabricOUIdentifier organizationalUnitIdentifier.
             * @member {string} organizationalUnitIdentifier
             * @memberof msp.FabricOUIdentifier
             * @instance
             */
            FabricOUIdentifier.prototype.organizationalUnitIdentifier = "";
    
            /**
             * Creates a new FabricOUIdentifier instance using the specified properties.
             * @function create
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {msp.IFabricOUIdentifier=} [properties] Properties to set
             * @returns {msp.FabricOUIdentifier} FabricOUIdentifier instance
             */
            FabricOUIdentifier.create = function create(properties) {
                return new FabricOUIdentifier(properties);
            };
    
            /**
             * Encodes the specified FabricOUIdentifier message. Does not implicitly {@link msp.FabricOUIdentifier.verify|verify} messages.
             * @function encode
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {msp.IFabricOUIdentifier} message FabricOUIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricOUIdentifier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.certificate != null && message.hasOwnProperty("certificate"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.certificate);
                if (message.organizationalUnitIdentifier != null && message.hasOwnProperty("organizationalUnitIdentifier"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.organizationalUnitIdentifier);
                return writer;
            };
    
            /**
             * Encodes the specified FabricOUIdentifier message, length delimited. Does not implicitly {@link msp.FabricOUIdentifier.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {msp.IFabricOUIdentifier} message FabricOUIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricOUIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FabricOUIdentifier message from the specified reader or buffer.
             * @function decode
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.FabricOUIdentifier} FabricOUIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricOUIdentifier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.FabricOUIdentifier();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.certificate = reader.bytes();
                        break;
                    case 2:
                        message.organizationalUnitIdentifier = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FabricOUIdentifier message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.FabricOUIdentifier} FabricOUIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricOUIdentifier.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FabricOUIdentifier message.
             * @function verify
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FabricOUIdentifier.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.certificate != null && message.hasOwnProperty("certificate"))
                    if (!(message.certificate && typeof message.certificate.length === "number" || $util.isString(message.certificate)))
                        return "certificate: buffer expected";
                if (message.organizationalUnitIdentifier != null && message.hasOwnProperty("organizationalUnitIdentifier"))
                    if (!$util.isString(message.organizationalUnitIdentifier))
                        return "organizationalUnitIdentifier: string expected";
                return null;
            };
    
            /**
             * Creates a FabricOUIdentifier message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.FabricOUIdentifier} FabricOUIdentifier
             */
            FabricOUIdentifier.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.FabricOUIdentifier)
                    return object;
                var message = new $root.msp.FabricOUIdentifier();
                if (object.certificate != null)
                    if (typeof object.certificate === "string")
                        $util.base64.decode(object.certificate, message.certificate = $util.newBuffer($util.base64.length(object.certificate)), 0);
                    else if (object.certificate.length)
                        message.certificate = object.certificate;
                if (object.organizationalUnitIdentifier != null)
                    message.organizationalUnitIdentifier = String(object.organizationalUnitIdentifier);
                return message;
            };
    
            /**
             * Creates a plain object from a FabricOUIdentifier message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.FabricOUIdentifier
             * @static
             * @param {msp.FabricOUIdentifier} message FabricOUIdentifier
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FabricOUIdentifier.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.certificate = "";
                    else {
                        object.certificate = [];
                        if (options.bytes !== Array)
                            object.certificate = $util.newBuffer(object.certificate);
                    }
                    object.organizationalUnitIdentifier = "";
                }
                if (message.certificate != null && message.hasOwnProperty("certificate"))
                    object.certificate = options.bytes === String ? $util.base64.encode(message.certificate, 0, message.certificate.length) : options.bytes === Array ? Array.prototype.slice.call(message.certificate) : message.certificate;
                if (message.organizationalUnitIdentifier != null && message.hasOwnProperty("organizationalUnitIdentifier"))
                    object.organizationalUnitIdentifier = message.organizationalUnitIdentifier;
                return object;
            };
    
            /**
             * Converts this FabricOUIdentifier to JSON.
             * @function toJSON
             * @memberof msp.FabricOUIdentifier
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FabricOUIdentifier.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FabricOUIdentifier;
        })();
    
        msp.FabricNodeOUs = (function() {
    
            /**
             * Properties of a FabricNodeOUs.
             * @memberof msp
             * @interface IFabricNodeOUs
             * @property {boolean|null} [enable] FabricNodeOUs enable
             * @property {msp.IFabricOUIdentifier|null} [clientOuIdentifier] FabricNodeOUs clientOuIdentifier
             * @property {msp.IFabricOUIdentifier|null} [peerOuIdentifier] FabricNodeOUs peerOuIdentifier
             * @property {msp.IFabricOUIdentifier|null} [adminOuIdentifier] FabricNodeOUs adminOuIdentifier
             * @property {msp.IFabricOUIdentifier|null} [ordererOuIdentifier] FabricNodeOUs ordererOuIdentifier
             */
    
            /**
             * Constructs a new FabricNodeOUs.
             * @memberof msp
             * @classdesc Represents a FabricNodeOUs.
             * @implements IFabricNodeOUs
             * @constructor
             * @param {msp.IFabricNodeOUs=} [properties] Properties to set
             */
            function FabricNodeOUs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FabricNodeOUs enable.
             * @member {boolean} enable
             * @memberof msp.FabricNodeOUs
             * @instance
             */
            FabricNodeOUs.prototype.enable = false;
    
            /**
             * FabricNodeOUs clientOuIdentifier.
             * @member {msp.IFabricOUIdentifier|null|undefined} clientOuIdentifier
             * @memberof msp.FabricNodeOUs
             * @instance
             */
            FabricNodeOUs.prototype.clientOuIdentifier = null;
    
            /**
             * FabricNodeOUs peerOuIdentifier.
             * @member {msp.IFabricOUIdentifier|null|undefined} peerOuIdentifier
             * @memberof msp.FabricNodeOUs
             * @instance
             */
            FabricNodeOUs.prototype.peerOuIdentifier = null;
    
            /**
             * FabricNodeOUs adminOuIdentifier.
             * @member {msp.IFabricOUIdentifier|null|undefined} adminOuIdentifier
             * @memberof msp.FabricNodeOUs
             * @instance
             */
            FabricNodeOUs.prototype.adminOuIdentifier = null;
    
            /**
             * FabricNodeOUs ordererOuIdentifier.
             * @member {msp.IFabricOUIdentifier|null|undefined} ordererOuIdentifier
             * @memberof msp.FabricNodeOUs
             * @instance
             */
            FabricNodeOUs.prototype.ordererOuIdentifier = null;
    
            /**
             * Creates a new FabricNodeOUs instance using the specified properties.
             * @function create
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {msp.IFabricNodeOUs=} [properties] Properties to set
             * @returns {msp.FabricNodeOUs} FabricNodeOUs instance
             */
            FabricNodeOUs.create = function create(properties) {
                return new FabricNodeOUs(properties);
            };
    
            /**
             * Encodes the specified FabricNodeOUs message. Does not implicitly {@link msp.FabricNodeOUs.verify|verify} messages.
             * @function encode
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {msp.IFabricNodeOUs} message FabricNodeOUs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricNodeOUs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enable != null && message.hasOwnProperty("enable"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enable);
                if (message.clientOuIdentifier != null && message.hasOwnProperty("clientOuIdentifier"))
                    $root.msp.FabricOUIdentifier.encode(message.clientOuIdentifier, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.peerOuIdentifier != null && message.hasOwnProperty("peerOuIdentifier"))
                    $root.msp.FabricOUIdentifier.encode(message.peerOuIdentifier, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.adminOuIdentifier != null && message.hasOwnProperty("adminOuIdentifier"))
                    $root.msp.FabricOUIdentifier.encode(message.adminOuIdentifier, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.ordererOuIdentifier != null && message.hasOwnProperty("ordererOuIdentifier"))
                    $root.msp.FabricOUIdentifier.encode(message.ordererOuIdentifier, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FabricNodeOUs message, length delimited. Does not implicitly {@link msp.FabricNodeOUs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {msp.IFabricNodeOUs} message FabricNodeOUs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FabricNodeOUs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FabricNodeOUs message from the specified reader or buffer.
             * @function decode
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.FabricNodeOUs} FabricNodeOUs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricNodeOUs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.FabricNodeOUs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.enable = reader.bool();
                        break;
                    case 2:
                        message.clientOuIdentifier = $root.msp.FabricOUIdentifier.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.peerOuIdentifier = $root.msp.FabricOUIdentifier.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.adminOuIdentifier = $root.msp.FabricOUIdentifier.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.ordererOuIdentifier = $root.msp.FabricOUIdentifier.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FabricNodeOUs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.FabricNodeOUs} FabricNodeOUs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FabricNodeOUs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FabricNodeOUs message.
             * @function verify
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FabricNodeOUs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enable != null && message.hasOwnProperty("enable"))
                    if (typeof message.enable !== "boolean")
                        return "enable: boolean expected";
                if (message.clientOuIdentifier != null && message.hasOwnProperty("clientOuIdentifier")) {
                    var error = $root.msp.FabricOUIdentifier.verify(message.clientOuIdentifier);
                    if (error)
                        return "clientOuIdentifier." + error;
                }
                if (message.peerOuIdentifier != null && message.hasOwnProperty("peerOuIdentifier")) {
                    var error = $root.msp.FabricOUIdentifier.verify(message.peerOuIdentifier);
                    if (error)
                        return "peerOuIdentifier." + error;
                }
                if (message.adminOuIdentifier != null && message.hasOwnProperty("adminOuIdentifier")) {
                    var error = $root.msp.FabricOUIdentifier.verify(message.adminOuIdentifier);
                    if (error)
                        return "adminOuIdentifier." + error;
                }
                if (message.ordererOuIdentifier != null && message.hasOwnProperty("ordererOuIdentifier")) {
                    var error = $root.msp.FabricOUIdentifier.verify(message.ordererOuIdentifier);
                    if (error)
                        return "ordererOuIdentifier." + error;
                }
                return null;
            };
    
            /**
             * Creates a FabricNodeOUs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.FabricNodeOUs} FabricNodeOUs
             */
            FabricNodeOUs.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.FabricNodeOUs)
                    return object;
                var message = new $root.msp.FabricNodeOUs();
                if (object.enable != null)
                    message.enable = Boolean(object.enable);
                if (object.clientOuIdentifier != null) {
                    if (typeof object.clientOuIdentifier !== "object")
                        throw TypeError(".msp.FabricNodeOUs.clientOuIdentifier: object expected");
                    message.clientOuIdentifier = $root.msp.FabricOUIdentifier.fromObject(object.clientOuIdentifier);
                }
                if (object.peerOuIdentifier != null) {
                    if (typeof object.peerOuIdentifier !== "object")
                        throw TypeError(".msp.FabricNodeOUs.peerOuIdentifier: object expected");
                    message.peerOuIdentifier = $root.msp.FabricOUIdentifier.fromObject(object.peerOuIdentifier);
                }
                if (object.adminOuIdentifier != null) {
                    if (typeof object.adminOuIdentifier !== "object")
                        throw TypeError(".msp.FabricNodeOUs.adminOuIdentifier: object expected");
                    message.adminOuIdentifier = $root.msp.FabricOUIdentifier.fromObject(object.adminOuIdentifier);
                }
                if (object.ordererOuIdentifier != null) {
                    if (typeof object.ordererOuIdentifier !== "object")
                        throw TypeError(".msp.FabricNodeOUs.ordererOuIdentifier: object expected");
                    message.ordererOuIdentifier = $root.msp.FabricOUIdentifier.fromObject(object.ordererOuIdentifier);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FabricNodeOUs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.FabricNodeOUs
             * @static
             * @param {msp.FabricNodeOUs} message FabricNodeOUs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FabricNodeOUs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enable = false;
                    object.clientOuIdentifier = null;
                    object.peerOuIdentifier = null;
                    object.adminOuIdentifier = null;
                    object.ordererOuIdentifier = null;
                }
                if (message.enable != null && message.hasOwnProperty("enable"))
                    object.enable = message.enable;
                if (message.clientOuIdentifier != null && message.hasOwnProperty("clientOuIdentifier"))
                    object.clientOuIdentifier = $root.msp.FabricOUIdentifier.toObject(message.clientOuIdentifier, options);
                if (message.peerOuIdentifier != null && message.hasOwnProperty("peerOuIdentifier"))
                    object.peerOuIdentifier = $root.msp.FabricOUIdentifier.toObject(message.peerOuIdentifier, options);
                if (message.adminOuIdentifier != null && message.hasOwnProperty("adminOuIdentifier"))
                    object.adminOuIdentifier = $root.msp.FabricOUIdentifier.toObject(message.adminOuIdentifier, options);
                if (message.ordererOuIdentifier != null && message.hasOwnProperty("ordererOuIdentifier"))
                    object.ordererOuIdentifier = $root.msp.FabricOUIdentifier.toObject(message.ordererOuIdentifier, options);
                return object;
            };
    
            /**
             * Converts this FabricNodeOUs to JSON.
             * @function toJSON
             * @memberof msp.FabricNodeOUs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FabricNodeOUs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FabricNodeOUs;
        })();
    
        msp.SerializedIdentity = (function() {
    
            /**
             * Properties of a SerializedIdentity.
             * @memberof msp
             * @interface ISerializedIdentity
             * @property {string|null} [mspid] SerializedIdentity mspid
             * @property {Uint8Array|null} [idBytes] SerializedIdentity idBytes
             */
    
            /**
             * Constructs a new SerializedIdentity.
             * @memberof msp
             * @classdesc Represents a SerializedIdentity.
             * @implements ISerializedIdentity
             * @constructor
             * @param {msp.ISerializedIdentity=} [properties] Properties to set
             */
            function SerializedIdentity(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SerializedIdentity mspid.
             * @member {string} mspid
             * @memberof msp.SerializedIdentity
             * @instance
             */
            SerializedIdentity.prototype.mspid = "";
    
            /**
             * SerializedIdentity idBytes.
             * @member {Uint8Array} idBytes
             * @memberof msp.SerializedIdentity
             * @instance
             */
            SerializedIdentity.prototype.idBytes = $util.newBuffer([]);
    
            /**
             * Creates a new SerializedIdentity instance using the specified properties.
             * @function create
             * @memberof msp.SerializedIdentity
             * @static
             * @param {msp.ISerializedIdentity=} [properties] Properties to set
             * @returns {msp.SerializedIdentity} SerializedIdentity instance
             */
            SerializedIdentity.create = function create(properties) {
                return new SerializedIdentity(properties);
            };
    
            /**
             * Encodes the specified SerializedIdentity message. Does not implicitly {@link msp.SerializedIdentity.verify|verify} messages.
             * @function encode
             * @memberof msp.SerializedIdentity
             * @static
             * @param {msp.ISerializedIdentity} message SerializedIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerializedIdentity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mspid != null && message.hasOwnProperty("mspid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.mspid);
                if (message.idBytes != null && message.hasOwnProperty("idBytes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.idBytes);
                return writer;
            };
    
            /**
             * Encodes the specified SerializedIdentity message, length delimited. Does not implicitly {@link msp.SerializedIdentity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.SerializedIdentity
             * @static
             * @param {msp.ISerializedIdentity} message SerializedIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerializedIdentity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SerializedIdentity message from the specified reader or buffer.
             * @function decode
             * @memberof msp.SerializedIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.SerializedIdentity} SerializedIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerializedIdentity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.SerializedIdentity();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mspid = reader.string();
                        break;
                    case 2:
                        message.idBytes = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SerializedIdentity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.SerializedIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.SerializedIdentity} SerializedIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerializedIdentity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SerializedIdentity message.
             * @function verify
             * @memberof msp.SerializedIdentity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SerializedIdentity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mspid != null && message.hasOwnProperty("mspid"))
                    if (!$util.isString(message.mspid))
                        return "mspid: string expected";
                if (message.idBytes != null && message.hasOwnProperty("idBytes"))
                    if (!(message.idBytes && typeof message.idBytes.length === "number" || $util.isString(message.idBytes)))
                        return "idBytes: buffer expected";
                return null;
            };
    
            /**
             * Creates a SerializedIdentity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.SerializedIdentity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.SerializedIdentity} SerializedIdentity
             */
            SerializedIdentity.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.SerializedIdentity)
                    return object;
                var message = new $root.msp.SerializedIdentity();
                if (object.mspid != null)
                    message.mspid = String(object.mspid);
                if (object.idBytes != null)
                    if (typeof object.idBytes === "string")
                        $util.base64.decode(object.idBytes, message.idBytes = $util.newBuffer($util.base64.length(object.idBytes)), 0);
                    else if (object.idBytes.length)
                        message.idBytes = object.idBytes;
                return message;
            };
    
            /**
             * Creates a plain object from a SerializedIdentity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.SerializedIdentity
             * @static
             * @param {msp.SerializedIdentity} message SerializedIdentity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SerializedIdentity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.mspid = "";
                    if (options.bytes === String)
                        object.idBytes = "";
                    else {
                        object.idBytes = [];
                        if (options.bytes !== Array)
                            object.idBytes = $util.newBuffer(object.idBytes);
                    }
                }
                if (message.mspid != null && message.hasOwnProperty("mspid"))
                    object.mspid = message.mspid;
                if (message.idBytes != null && message.hasOwnProperty("idBytes"))
                    object.idBytes = options.bytes === String ? $util.base64.encode(message.idBytes, 0, message.idBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.idBytes) : message.idBytes;
                return object;
            };
    
            /**
             * Converts this SerializedIdentity to JSON.
             * @function toJSON
             * @memberof msp.SerializedIdentity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SerializedIdentity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SerializedIdentity;
        })();
    
        msp.SerializedIdemixIdentity = (function() {
    
            /**
             * Properties of a SerializedIdemixIdentity.
             * @memberof msp
             * @interface ISerializedIdemixIdentity
             * @property {Uint8Array|null} [nymX] SerializedIdemixIdentity nymX
             * @property {Uint8Array|null} [nymY] SerializedIdemixIdentity nymY
             * @property {Uint8Array|null} [ou] SerializedIdemixIdentity ou
             * @property {Uint8Array|null} [role] SerializedIdemixIdentity role
             * @property {Uint8Array|null} [proof] SerializedIdemixIdentity proof
             */
    
            /**
             * Constructs a new SerializedIdemixIdentity.
             * @memberof msp
             * @classdesc Represents a SerializedIdemixIdentity.
             * @implements ISerializedIdemixIdentity
             * @constructor
             * @param {msp.ISerializedIdemixIdentity=} [properties] Properties to set
             */
            function SerializedIdemixIdentity(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SerializedIdemixIdentity nymX.
             * @member {Uint8Array} nymX
             * @memberof msp.SerializedIdemixIdentity
             * @instance
             */
            SerializedIdemixIdentity.prototype.nymX = $util.newBuffer([]);
    
            /**
             * SerializedIdemixIdentity nymY.
             * @member {Uint8Array} nymY
             * @memberof msp.SerializedIdemixIdentity
             * @instance
             */
            SerializedIdemixIdentity.prototype.nymY = $util.newBuffer([]);
    
            /**
             * SerializedIdemixIdentity ou.
             * @member {Uint8Array} ou
             * @memberof msp.SerializedIdemixIdentity
             * @instance
             */
            SerializedIdemixIdentity.prototype.ou = $util.newBuffer([]);
    
            /**
             * SerializedIdemixIdentity role.
             * @member {Uint8Array} role
             * @memberof msp.SerializedIdemixIdentity
             * @instance
             */
            SerializedIdemixIdentity.prototype.role = $util.newBuffer([]);
    
            /**
             * SerializedIdemixIdentity proof.
             * @member {Uint8Array} proof
             * @memberof msp.SerializedIdemixIdentity
             * @instance
             */
            SerializedIdemixIdentity.prototype.proof = $util.newBuffer([]);
    
            /**
             * Creates a new SerializedIdemixIdentity instance using the specified properties.
             * @function create
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {msp.ISerializedIdemixIdentity=} [properties] Properties to set
             * @returns {msp.SerializedIdemixIdentity} SerializedIdemixIdentity instance
             */
            SerializedIdemixIdentity.create = function create(properties) {
                return new SerializedIdemixIdentity(properties);
            };
    
            /**
             * Encodes the specified SerializedIdemixIdentity message. Does not implicitly {@link msp.SerializedIdemixIdentity.verify|verify} messages.
             * @function encode
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {msp.ISerializedIdemixIdentity} message SerializedIdemixIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerializedIdemixIdentity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nymX != null && message.hasOwnProperty("nymX"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nymX);
                if (message.nymY != null && message.hasOwnProperty("nymY"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nymY);
                if (message.ou != null && message.hasOwnProperty("ou"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ou);
                if (message.role != null && message.hasOwnProperty("role"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.role);
                if (message.proof != null && message.hasOwnProperty("proof"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.proof);
                return writer;
            };
    
            /**
             * Encodes the specified SerializedIdemixIdentity message, length delimited. Does not implicitly {@link msp.SerializedIdemixIdentity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {msp.ISerializedIdemixIdentity} message SerializedIdemixIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerializedIdemixIdentity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SerializedIdemixIdentity message from the specified reader or buffer.
             * @function decode
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {msp.SerializedIdemixIdentity} SerializedIdemixIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerializedIdemixIdentity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msp.SerializedIdemixIdentity();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nymX = reader.bytes();
                        break;
                    case 2:
                        message.nymY = reader.bytes();
                        break;
                    case 3:
                        message.ou = reader.bytes();
                        break;
                    case 4:
                        message.role = reader.bytes();
                        break;
                    case 5:
                        message.proof = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SerializedIdemixIdentity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {msp.SerializedIdemixIdentity} SerializedIdemixIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerializedIdemixIdentity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SerializedIdemixIdentity message.
             * @function verify
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SerializedIdemixIdentity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nymX != null && message.hasOwnProperty("nymX"))
                    if (!(message.nymX && typeof message.nymX.length === "number" || $util.isString(message.nymX)))
                        return "nymX: buffer expected";
                if (message.nymY != null && message.hasOwnProperty("nymY"))
                    if (!(message.nymY && typeof message.nymY.length === "number" || $util.isString(message.nymY)))
                        return "nymY: buffer expected";
                if (message.ou != null && message.hasOwnProperty("ou"))
                    if (!(message.ou && typeof message.ou.length === "number" || $util.isString(message.ou)))
                        return "ou: buffer expected";
                if (message.role != null && message.hasOwnProperty("role"))
                    if (!(message.role && typeof message.role.length === "number" || $util.isString(message.role)))
                        return "role: buffer expected";
                if (message.proof != null && message.hasOwnProperty("proof"))
                    if (!(message.proof && typeof message.proof.length === "number" || $util.isString(message.proof)))
                        return "proof: buffer expected";
                return null;
            };
    
            /**
             * Creates a SerializedIdemixIdentity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {msp.SerializedIdemixIdentity} SerializedIdemixIdentity
             */
            SerializedIdemixIdentity.fromObject = function fromObject(object) {
                if (object instanceof $root.msp.SerializedIdemixIdentity)
                    return object;
                var message = new $root.msp.SerializedIdemixIdentity();
                if (object.nymX != null)
                    if (typeof object.nymX === "string")
                        $util.base64.decode(object.nymX, message.nymX = $util.newBuffer($util.base64.length(object.nymX)), 0);
                    else if (object.nymX.length)
                        message.nymX = object.nymX;
                if (object.nymY != null)
                    if (typeof object.nymY === "string")
                        $util.base64.decode(object.nymY, message.nymY = $util.newBuffer($util.base64.length(object.nymY)), 0);
                    else if (object.nymY.length)
                        message.nymY = object.nymY;
                if (object.ou != null)
                    if (typeof object.ou === "string")
                        $util.base64.decode(object.ou, message.ou = $util.newBuffer($util.base64.length(object.ou)), 0);
                    else if (object.ou.length)
                        message.ou = object.ou;
                if (object.role != null)
                    if (typeof object.role === "string")
                        $util.base64.decode(object.role, message.role = $util.newBuffer($util.base64.length(object.role)), 0);
                    else if (object.role.length)
                        message.role = object.role;
                if (object.proof != null)
                    if (typeof object.proof === "string")
                        $util.base64.decode(object.proof, message.proof = $util.newBuffer($util.base64.length(object.proof)), 0);
                    else if (object.proof.length)
                        message.proof = object.proof;
                return message;
            };
    
            /**
             * Creates a plain object from a SerializedIdemixIdentity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof msp.SerializedIdemixIdentity
             * @static
             * @param {msp.SerializedIdemixIdentity} message SerializedIdemixIdentity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SerializedIdemixIdentity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.nymX = "";
                    else {
                        object.nymX = [];
                        if (options.bytes !== Array)
                            object.nymX = $util.newBuffer(object.nymX);
                    }
                    if (options.bytes === String)
                        object.nymY = "";
                    else {
                        object.nymY = [];
                        if (options.bytes !== Array)
                            object.nymY = $util.newBuffer(object.nymY);
                    }
                    if (options.bytes === String)
                        object.ou = "";
                    else {
                        object.ou = [];
                        if (options.bytes !== Array)
                            object.ou = $util.newBuffer(object.ou);
                    }
                    if (options.bytes === String)
                        object.role = "";
                    else {
                        object.role = [];
                        if (options.bytes !== Array)
                            object.role = $util.newBuffer(object.role);
                    }
                    if (options.bytes === String)
                        object.proof = "";
                    else {
                        object.proof = [];
                        if (options.bytes !== Array)
                            object.proof = $util.newBuffer(object.proof);
                    }
                }
                if (message.nymX != null && message.hasOwnProperty("nymX"))
                    object.nymX = options.bytes === String ? $util.base64.encode(message.nymX, 0, message.nymX.length) : options.bytes === Array ? Array.prototype.slice.call(message.nymX) : message.nymX;
                if (message.nymY != null && message.hasOwnProperty("nymY"))
                    object.nymY = options.bytes === String ? $util.base64.encode(message.nymY, 0, message.nymY.length) : options.bytes === Array ? Array.prototype.slice.call(message.nymY) : message.nymY;
                if (message.ou != null && message.hasOwnProperty("ou"))
                    object.ou = options.bytes === String ? $util.base64.encode(message.ou, 0, message.ou.length) : options.bytes === Array ? Array.prototype.slice.call(message.ou) : message.ou;
                if (message.role != null && message.hasOwnProperty("role"))
                    object.role = options.bytes === String ? $util.base64.encode(message.role, 0, message.role.length) : options.bytes === Array ? Array.prototype.slice.call(message.role) : message.role;
                if (message.proof != null && message.hasOwnProperty("proof"))
                    object.proof = options.bytes === String ? $util.base64.encode(message.proof, 0, message.proof.length) : options.bytes === Array ? Array.prototype.slice.call(message.proof) : message.proof;
                return object;
            };
    
            /**
             * Converts this SerializedIdemixIdentity to JSON.
             * @function toJSON
             * @memberof msp.SerializedIdemixIdentity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SerializedIdemixIdentity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SerializedIdemixIdentity;
        })();
    
        return msp;
    })();
    
    $root.common = (function() {
    
        /**
         * Namespace common.
         * @exports common
         * @namespace
         */
        var common = {};
    
        common.MSPPrincipal = (function() {
    
            /**
             * Properties of a MSPPrincipal.
             * @memberof common
             * @interface IMSPPrincipal
             * @property {common.MSPPrincipal.Classification|null} [principalClassification] MSPPrincipal principalClassification
             * @property {Uint8Array|null} [principal] MSPPrincipal principal
             */
    
            /**
             * Constructs a new MSPPrincipal.
             * @memberof common
             * @classdesc Represents a MSPPrincipal.
             * @implements IMSPPrincipal
             * @constructor
             * @param {common.IMSPPrincipal=} [properties] Properties to set
             */
            function MSPPrincipal(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MSPPrincipal principalClassification.
             * @member {common.MSPPrincipal.Classification} principalClassification
             * @memberof common.MSPPrincipal
             * @instance
             */
            MSPPrincipal.prototype.principalClassification = 0;
    
            /**
             * MSPPrincipal principal.
             * @member {Uint8Array} principal
             * @memberof common.MSPPrincipal
             * @instance
             */
            MSPPrincipal.prototype.principal = $util.newBuffer([]);
    
            /**
             * Creates a new MSPPrincipal instance using the specified properties.
             * @function create
             * @memberof common.MSPPrincipal
             * @static
             * @param {common.IMSPPrincipal=} [properties] Properties to set
             * @returns {common.MSPPrincipal} MSPPrincipal instance
             */
            MSPPrincipal.create = function create(properties) {
                return new MSPPrincipal(properties);
            };
    
            /**
             * Encodes the specified MSPPrincipal message. Does not implicitly {@link common.MSPPrincipal.verify|verify} messages.
             * @function encode
             * @memberof common.MSPPrincipal
             * @static
             * @param {common.IMSPPrincipal} message MSPPrincipal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPPrincipal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.principalClassification != null && message.hasOwnProperty("principalClassification"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.principalClassification);
                if (message.principal != null && message.hasOwnProperty("principal"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.principal);
                return writer;
            };
    
            /**
             * Encodes the specified MSPPrincipal message, length delimited. Does not implicitly {@link common.MSPPrincipal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.MSPPrincipal
             * @static
             * @param {common.IMSPPrincipal} message MSPPrincipal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPPrincipal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MSPPrincipal message from the specified reader or buffer.
             * @function decode
             * @memberof common.MSPPrincipal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.MSPPrincipal} MSPPrincipal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPPrincipal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.MSPPrincipal();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.principalClassification = reader.int32();
                        break;
                    case 2:
                        message.principal = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MSPPrincipal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.MSPPrincipal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.MSPPrincipal} MSPPrincipal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPPrincipal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MSPPrincipal message.
             * @function verify
             * @memberof common.MSPPrincipal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MSPPrincipal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.principalClassification != null && message.hasOwnProperty("principalClassification"))
                    switch (message.principalClassification) {
                    default:
                        return "principalClassification: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.principal != null && message.hasOwnProperty("principal"))
                    if (!(message.principal && typeof message.principal.length === "number" || $util.isString(message.principal)))
                        return "principal: buffer expected";
                return null;
            };
    
            /**
             * Creates a MSPPrincipal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.MSPPrincipal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.MSPPrincipal} MSPPrincipal
             */
            MSPPrincipal.fromObject = function fromObject(object) {
                if (object instanceof $root.common.MSPPrincipal)
                    return object;
                var message = new $root.common.MSPPrincipal();
                switch (object.principalClassification) {
                case "ROLE":
                case 0:
                    message.principalClassification = 0;
                    break;
                case "ORGANIZATION_UNIT":
                case 1:
                    message.principalClassification = 1;
                    break;
                case "IDENTITY":
                case 2:
                    message.principalClassification = 2;
                    break;
                case "ANONYMITY":
                case 3:
                    message.principalClassification = 3;
                    break;
                case "COMBINED":
                case 4:
                    message.principalClassification = 4;
                    break;
                }
                if (object.principal != null)
                    if (typeof object.principal === "string")
                        $util.base64.decode(object.principal, message.principal = $util.newBuffer($util.base64.length(object.principal)), 0);
                    else if (object.principal.length)
                        message.principal = object.principal;
                return message;
            };
    
            /**
             * Creates a plain object from a MSPPrincipal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.MSPPrincipal
             * @static
             * @param {common.MSPPrincipal} message MSPPrincipal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MSPPrincipal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.principalClassification = options.enums === String ? "ROLE" : 0;
                    if (options.bytes === String)
                        object.principal = "";
                    else {
                        object.principal = [];
                        if (options.bytes !== Array)
                            object.principal = $util.newBuffer(object.principal);
                    }
                }
                if (message.principalClassification != null && message.hasOwnProperty("principalClassification"))
                    object.principalClassification = options.enums === String ? $root.common.MSPPrincipal.Classification[message.principalClassification] : message.principalClassification;
                if (message.principal != null && message.hasOwnProperty("principal"))
                    object.principal = options.bytes === String ? $util.base64.encode(message.principal, 0, message.principal.length) : options.bytes === Array ? Array.prototype.slice.call(message.principal) : message.principal;
                return object;
            };
    
            /**
             * Converts this MSPPrincipal to JSON.
             * @function toJSON
             * @memberof common.MSPPrincipal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MSPPrincipal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Classification enum.
             * @name common.MSPPrincipal.Classification
             * @enum {string}
             * @property {number} ROLE=0 ROLE value
             * @property {number} ORGANIZATION_UNIT=1 ORGANIZATION_UNIT value
             * @property {number} IDENTITY=2 IDENTITY value
             * @property {number} ANONYMITY=3 ANONYMITY value
             * @property {number} COMBINED=4 COMBINED value
             */
            MSPPrincipal.Classification = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ROLE"] = 0;
                values[valuesById[1] = "ORGANIZATION_UNIT"] = 1;
                values[valuesById[2] = "IDENTITY"] = 2;
                values[valuesById[3] = "ANONYMITY"] = 3;
                values[valuesById[4] = "COMBINED"] = 4;
                return values;
            })();
    
            return MSPPrincipal;
        })();
    
        common.OrganizationUnit = (function() {
    
            /**
             * Properties of an OrganizationUnit.
             * @memberof common
             * @interface IOrganizationUnit
             * @property {string|null} [mspIdentifier] OrganizationUnit mspIdentifier
             * @property {string|null} [organizationalUnitIdentifier] OrganizationUnit organizationalUnitIdentifier
             * @property {Uint8Array|null} [certifiersIdentifier] OrganizationUnit certifiersIdentifier
             */
    
            /**
             * Constructs a new OrganizationUnit.
             * @memberof common
             * @classdesc Represents an OrganizationUnit.
             * @implements IOrganizationUnit
             * @constructor
             * @param {common.IOrganizationUnit=} [properties] Properties to set
             */
            function OrganizationUnit(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OrganizationUnit mspIdentifier.
             * @member {string} mspIdentifier
             * @memberof common.OrganizationUnit
             * @instance
             */
            OrganizationUnit.prototype.mspIdentifier = "";
    
            /**
             * OrganizationUnit organizationalUnitIdentifier.
             * @member {string} organizationalUnitIdentifier
             * @memberof common.OrganizationUnit
             * @instance
             */
            OrganizationUnit.prototype.organizationalUnitIdentifier = "";
    
            /**
             * OrganizationUnit certifiersIdentifier.
             * @member {Uint8Array} certifiersIdentifier
             * @memberof common.OrganizationUnit
             * @instance
             */
            OrganizationUnit.prototype.certifiersIdentifier = $util.newBuffer([]);
    
            /**
             * Creates a new OrganizationUnit instance using the specified properties.
             * @function create
             * @memberof common.OrganizationUnit
             * @static
             * @param {common.IOrganizationUnit=} [properties] Properties to set
             * @returns {common.OrganizationUnit} OrganizationUnit instance
             */
            OrganizationUnit.create = function create(properties) {
                return new OrganizationUnit(properties);
            };
    
            /**
             * Encodes the specified OrganizationUnit message. Does not implicitly {@link common.OrganizationUnit.verify|verify} messages.
             * @function encode
             * @memberof common.OrganizationUnit
             * @static
             * @param {common.IOrganizationUnit} message OrganizationUnit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrganizationUnit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mspIdentifier != null && message.hasOwnProperty("mspIdentifier"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.mspIdentifier);
                if (message.organizationalUnitIdentifier != null && message.hasOwnProperty("organizationalUnitIdentifier"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.organizationalUnitIdentifier);
                if (message.certifiersIdentifier != null && message.hasOwnProperty("certifiersIdentifier"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.certifiersIdentifier);
                return writer;
            };
    
            /**
             * Encodes the specified OrganizationUnit message, length delimited. Does not implicitly {@link common.OrganizationUnit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.OrganizationUnit
             * @static
             * @param {common.IOrganizationUnit} message OrganizationUnit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrganizationUnit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an OrganizationUnit message from the specified reader or buffer.
             * @function decode
             * @memberof common.OrganizationUnit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.OrganizationUnit} OrganizationUnit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrganizationUnit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.OrganizationUnit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mspIdentifier = reader.string();
                        break;
                    case 2:
                        message.organizationalUnitIdentifier = reader.string();
                        break;
                    case 3:
                        message.certifiersIdentifier = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an OrganizationUnit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.OrganizationUnit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.OrganizationUnit} OrganizationUnit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrganizationUnit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an OrganizationUnit message.
             * @function verify
             * @memberof common.OrganizationUnit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrganizationUnit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mspIdentifier != null && message.hasOwnProperty("mspIdentifier"))
                    if (!$util.isString(message.mspIdentifier))
                        return "mspIdentifier: string expected";
                if (message.organizationalUnitIdentifier != null && message.hasOwnProperty("organizationalUnitIdentifier"))
                    if (!$util.isString(message.organizationalUnitIdentifier))
                        return "organizationalUnitIdentifier: string expected";
                if (message.certifiersIdentifier != null && message.hasOwnProperty("certifiersIdentifier"))
                    if (!(message.certifiersIdentifier && typeof message.certifiersIdentifier.length === "number" || $util.isString(message.certifiersIdentifier)))
                        return "certifiersIdentifier: buffer expected";
                return null;
            };
    
            /**
             * Creates an OrganizationUnit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.OrganizationUnit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.OrganizationUnit} OrganizationUnit
             */
            OrganizationUnit.fromObject = function fromObject(object) {
                if (object instanceof $root.common.OrganizationUnit)
                    return object;
                var message = new $root.common.OrganizationUnit();
                if (object.mspIdentifier != null)
                    message.mspIdentifier = String(object.mspIdentifier);
                if (object.organizationalUnitIdentifier != null)
                    message.organizationalUnitIdentifier = String(object.organizationalUnitIdentifier);
                if (object.certifiersIdentifier != null)
                    if (typeof object.certifiersIdentifier === "string")
                        $util.base64.decode(object.certifiersIdentifier, message.certifiersIdentifier = $util.newBuffer($util.base64.length(object.certifiersIdentifier)), 0);
                    else if (object.certifiersIdentifier.length)
                        message.certifiersIdentifier = object.certifiersIdentifier;
                return message;
            };
    
            /**
             * Creates a plain object from an OrganizationUnit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.OrganizationUnit
             * @static
             * @param {common.OrganizationUnit} message OrganizationUnit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrganizationUnit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.mspIdentifier = "";
                    object.organizationalUnitIdentifier = "";
                    if (options.bytes === String)
                        object.certifiersIdentifier = "";
                    else {
                        object.certifiersIdentifier = [];
                        if (options.bytes !== Array)
                            object.certifiersIdentifier = $util.newBuffer(object.certifiersIdentifier);
                    }
                }
                if (message.mspIdentifier != null && message.hasOwnProperty("mspIdentifier"))
                    object.mspIdentifier = message.mspIdentifier;
                if (message.organizationalUnitIdentifier != null && message.hasOwnProperty("organizationalUnitIdentifier"))
                    object.organizationalUnitIdentifier = message.organizationalUnitIdentifier;
                if (message.certifiersIdentifier != null && message.hasOwnProperty("certifiersIdentifier"))
                    object.certifiersIdentifier = options.bytes === String ? $util.base64.encode(message.certifiersIdentifier, 0, message.certifiersIdentifier.length) : options.bytes === Array ? Array.prototype.slice.call(message.certifiersIdentifier) : message.certifiersIdentifier;
                return object;
            };
    
            /**
             * Converts this OrganizationUnit to JSON.
             * @function toJSON
             * @memberof common.OrganizationUnit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrganizationUnit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OrganizationUnit;
        })();
    
        common.MSPRole = (function() {
    
            /**
             * Properties of a MSPRole.
             * @memberof common
             * @interface IMSPRole
             * @property {string|null} [mspIdentifier] MSPRole mspIdentifier
             * @property {common.MSPRole.MSPRoleType|null} [role] MSPRole role
             */
    
            /**
             * Constructs a new MSPRole.
             * @memberof common
             * @classdesc Represents a MSPRole.
             * @implements IMSPRole
             * @constructor
             * @param {common.IMSPRole=} [properties] Properties to set
             */
            function MSPRole(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MSPRole mspIdentifier.
             * @member {string} mspIdentifier
             * @memberof common.MSPRole
             * @instance
             */
            MSPRole.prototype.mspIdentifier = "";
    
            /**
             * MSPRole role.
             * @member {common.MSPRole.MSPRoleType} role
             * @memberof common.MSPRole
             * @instance
             */
            MSPRole.prototype.role = 0;
    
            /**
             * Creates a new MSPRole instance using the specified properties.
             * @function create
             * @memberof common.MSPRole
             * @static
             * @param {common.IMSPRole=} [properties] Properties to set
             * @returns {common.MSPRole} MSPRole instance
             */
            MSPRole.create = function create(properties) {
                return new MSPRole(properties);
            };
    
            /**
             * Encodes the specified MSPRole message. Does not implicitly {@link common.MSPRole.verify|verify} messages.
             * @function encode
             * @memberof common.MSPRole
             * @static
             * @param {common.IMSPRole} message MSPRole message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPRole.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mspIdentifier != null && message.hasOwnProperty("mspIdentifier"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.mspIdentifier);
                if (message.role != null && message.hasOwnProperty("role"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.role);
                return writer;
            };
    
            /**
             * Encodes the specified MSPRole message, length delimited. Does not implicitly {@link common.MSPRole.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.MSPRole
             * @static
             * @param {common.IMSPRole} message MSPRole message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPRole.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MSPRole message from the specified reader or buffer.
             * @function decode
             * @memberof common.MSPRole
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.MSPRole} MSPRole
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPRole.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.MSPRole();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mspIdentifier = reader.string();
                        break;
                    case 2:
                        message.role = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MSPRole message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.MSPRole
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.MSPRole} MSPRole
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPRole.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MSPRole message.
             * @function verify
             * @memberof common.MSPRole
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MSPRole.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mspIdentifier != null && message.hasOwnProperty("mspIdentifier"))
                    if (!$util.isString(message.mspIdentifier))
                        return "mspIdentifier: string expected";
                if (message.role != null && message.hasOwnProperty("role"))
                    switch (message.role) {
                    default:
                        return "role: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a MSPRole message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.MSPRole
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.MSPRole} MSPRole
             */
            MSPRole.fromObject = function fromObject(object) {
                if (object instanceof $root.common.MSPRole)
                    return object;
                var message = new $root.common.MSPRole();
                if (object.mspIdentifier != null)
                    message.mspIdentifier = String(object.mspIdentifier);
                switch (object.role) {
                case "MEMBER":
                case 0:
                    message.role = 0;
                    break;
                case "ADMIN":
                case 1:
                    message.role = 1;
                    break;
                case "CLIENT":
                case 2:
                    message.role = 2;
                    break;
                case "PEER":
                case 3:
                    message.role = 3;
                    break;
                case "ORDERER":
                case 4:
                    message.role = 4;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a MSPRole message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.MSPRole
             * @static
             * @param {common.MSPRole} message MSPRole
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MSPRole.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.mspIdentifier = "";
                    object.role = options.enums === String ? "MEMBER" : 0;
                }
                if (message.mspIdentifier != null && message.hasOwnProperty("mspIdentifier"))
                    object.mspIdentifier = message.mspIdentifier;
                if (message.role != null && message.hasOwnProperty("role"))
                    object.role = options.enums === String ? $root.common.MSPRole.MSPRoleType[message.role] : message.role;
                return object;
            };
    
            /**
             * Converts this MSPRole to JSON.
             * @function toJSON
             * @memberof common.MSPRole
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MSPRole.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * MSPRoleType enum.
             * @name common.MSPRole.MSPRoleType
             * @enum {string}
             * @property {number} MEMBER=0 MEMBER value
             * @property {number} ADMIN=1 ADMIN value
             * @property {number} CLIENT=2 CLIENT value
             * @property {number} PEER=3 PEER value
             * @property {number} ORDERER=4 ORDERER value
             */
            MSPRole.MSPRoleType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MEMBER"] = 0;
                values[valuesById[1] = "ADMIN"] = 1;
                values[valuesById[2] = "CLIENT"] = 2;
                values[valuesById[3] = "PEER"] = 3;
                values[valuesById[4] = "ORDERER"] = 4;
                return values;
            })();
    
            return MSPRole;
        })();
    
        common.MSPIdentityAnonymity = (function() {
    
            /**
             * Properties of a MSPIdentityAnonymity.
             * @memberof common
             * @interface IMSPIdentityAnonymity
             * @property {common.MSPIdentityAnonymity.MSPIdentityAnonymityType|null} [anonymityType] MSPIdentityAnonymity anonymityType
             */
    
            /**
             * Constructs a new MSPIdentityAnonymity.
             * @memberof common
             * @classdesc Represents a MSPIdentityAnonymity.
             * @implements IMSPIdentityAnonymity
             * @constructor
             * @param {common.IMSPIdentityAnonymity=} [properties] Properties to set
             */
            function MSPIdentityAnonymity(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MSPIdentityAnonymity anonymityType.
             * @member {common.MSPIdentityAnonymity.MSPIdentityAnonymityType} anonymityType
             * @memberof common.MSPIdentityAnonymity
             * @instance
             */
            MSPIdentityAnonymity.prototype.anonymityType = 0;
    
            /**
             * Creates a new MSPIdentityAnonymity instance using the specified properties.
             * @function create
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {common.IMSPIdentityAnonymity=} [properties] Properties to set
             * @returns {common.MSPIdentityAnonymity} MSPIdentityAnonymity instance
             */
            MSPIdentityAnonymity.create = function create(properties) {
                return new MSPIdentityAnonymity(properties);
            };
    
            /**
             * Encodes the specified MSPIdentityAnonymity message. Does not implicitly {@link common.MSPIdentityAnonymity.verify|verify} messages.
             * @function encode
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {common.IMSPIdentityAnonymity} message MSPIdentityAnonymity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPIdentityAnonymity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.anonymityType != null && message.hasOwnProperty("anonymityType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.anonymityType);
                return writer;
            };
    
            /**
             * Encodes the specified MSPIdentityAnonymity message, length delimited. Does not implicitly {@link common.MSPIdentityAnonymity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {common.IMSPIdentityAnonymity} message MSPIdentityAnonymity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MSPIdentityAnonymity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MSPIdentityAnonymity message from the specified reader or buffer.
             * @function decode
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.MSPIdentityAnonymity} MSPIdentityAnonymity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPIdentityAnonymity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.MSPIdentityAnonymity();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.anonymityType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MSPIdentityAnonymity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.MSPIdentityAnonymity} MSPIdentityAnonymity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MSPIdentityAnonymity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MSPIdentityAnonymity message.
             * @function verify
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MSPIdentityAnonymity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.anonymityType != null && message.hasOwnProperty("anonymityType"))
                    switch (message.anonymityType) {
                    default:
                        return "anonymityType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a MSPIdentityAnonymity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.MSPIdentityAnonymity} MSPIdentityAnonymity
             */
            MSPIdentityAnonymity.fromObject = function fromObject(object) {
                if (object instanceof $root.common.MSPIdentityAnonymity)
                    return object;
                var message = new $root.common.MSPIdentityAnonymity();
                switch (object.anonymityType) {
                case "NOMINAL":
                case 0:
                    message.anonymityType = 0;
                    break;
                case "ANONYMOUS":
                case 1:
                    message.anonymityType = 1;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a MSPIdentityAnonymity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.MSPIdentityAnonymity
             * @static
             * @param {common.MSPIdentityAnonymity} message MSPIdentityAnonymity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MSPIdentityAnonymity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.anonymityType = options.enums === String ? "NOMINAL" : 0;
                if (message.anonymityType != null && message.hasOwnProperty("anonymityType"))
                    object.anonymityType = options.enums === String ? $root.common.MSPIdentityAnonymity.MSPIdentityAnonymityType[message.anonymityType] : message.anonymityType;
                return object;
            };
    
            /**
             * Converts this MSPIdentityAnonymity to JSON.
             * @function toJSON
             * @memberof common.MSPIdentityAnonymity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MSPIdentityAnonymity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * MSPIdentityAnonymityType enum.
             * @name common.MSPIdentityAnonymity.MSPIdentityAnonymityType
             * @enum {string}
             * @property {number} NOMINAL=0 NOMINAL value
             * @property {number} ANONYMOUS=1 ANONYMOUS value
             */
            MSPIdentityAnonymity.MSPIdentityAnonymityType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NOMINAL"] = 0;
                values[valuesById[1] = "ANONYMOUS"] = 1;
                return values;
            })();
    
            return MSPIdentityAnonymity;
        })();
    
        common.CombinedPrincipal = (function() {
    
            /**
             * Properties of a CombinedPrincipal.
             * @memberof common
             * @interface ICombinedPrincipal
             * @property {Array.<common.IMSPPrincipal>|null} [principals] CombinedPrincipal principals
             */
    
            /**
             * Constructs a new CombinedPrincipal.
             * @memberof common
             * @classdesc Represents a CombinedPrincipal.
             * @implements ICombinedPrincipal
             * @constructor
             * @param {common.ICombinedPrincipal=} [properties] Properties to set
             */
            function CombinedPrincipal(properties) {
                this.principals = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CombinedPrincipal principals.
             * @member {Array.<common.IMSPPrincipal>} principals
             * @memberof common.CombinedPrincipal
             * @instance
             */
            CombinedPrincipal.prototype.principals = $util.emptyArray;
    
            /**
             * Creates a new CombinedPrincipal instance using the specified properties.
             * @function create
             * @memberof common.CombinedPrincipal
             * @static
             * @param {common.ICombinedPrincipal=} [properties] Properties to set
             * @returns {common.CombinedPrincipal} CombinedPrincipal instance
             */
            CombinedPrincipal.create = function create(properties) {
                return new CombinedPrincipal(properties);
            };
    
            /**
             * Encodes the specified CombinedPrincipal message. Does not implicitly {@link common.CombinedPrincipal.verify|verify} messages.
             * @function encode
             * @memberof common.CombinedPrincipal
             * @static
             * @param {common.ICombinedPrincipal} message CombinedPrincipal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CombinedPrincipal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.principals != null && message.principals.length)
                    for (var i = 0; i < message.principals.length; ++i)
                        $root.common.MSPPrincipal.encode(message.principals[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CombinedPrincipal message, length delimited. Does not implicitly {@link common.CombinedPrincipal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.CombinedPrincipal
             * @static
             * @param {common.ICombinedPrincipal} message CombinedPrincipal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CombinedPrincipal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CombinedPrincipal message from the specified reader or buffer.
             * @function decode
             * @memberof common.CombinedPrincipal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.CombinedPrincipal} CombinedPrincipal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CombinedPrincipal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.CombinedPrincipal();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.principals && message.principals.length))
                            message.principals = [];
                        message.principals.push($root.common.MSPPrincipal.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CombinedPrincipal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.CombinedPrincipal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.CombinedPrincipal} CombinedPrincipal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CombinedPrincipal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CombinedPrincipal message.
             * @function verify
             * @memberof common.CombinedPrincipal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CombinedPrincipal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.principals != null && message.hasOwnProperty("principals")) {
                    if (!Array.isArray(message.principals))
                        return "principals: array expected";
                    for (var i = 0; i < message.principals.length; ++i) {
                        var error = $root.common.MSPPrincipal.verify(message.principals[i]);
                        if (error)
                            return "principals." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a CombinedPrincipal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.CombinedPrincipal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.CombinedPrincipal} CombinedPrincipal
             */
            CombinedPrincipal.fromObject = function fromObject(object) {
                if (object instanceof $root.common.CombinedPrincipal)
                    return object;
                var message = new $root.common.CombinedPrincipal();
                if (object.principals) {
                    if (!Array.isArray(object.principals))
                        throw TypeError(".common.CombinedPrincipal.principals: array expected");
                    message.principals = [];
                    for (var i = 0; i < object.principals.length; ++i) {
                        if (typeof object.principals[i] !== "object")
                            throw TypeError(".common.CombinedPrincipal.principals: object expected");
                        message.principals[i] = $root.common.MSPPrincipal.fromObject(object.principals[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CombinedPrincipal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.CombinedPrincipal
             * @static
             * @param {common.CombinedPrincipal} message CombinedPrincipal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CombinedPrincipal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.principals = [];
                if (message.principals && message.principals.length) {
                    object.principals = [];
                    for (var j = 0; j < message.principals.length; ++j)
                        object.principals[j] = $root.common.MSPPrincipal.toObject(message.principals[j], options);
                }
                return object;
            };
    
            /**
             * Converts this CombinedPrincipal to JSON.
             * @function toJSON
             * @memberof common.CombinedPrincipal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CombinedPrincipal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CombinedPrincipal;
        })();
    
        common.CollectionConfigPackage = (function() {
    
            /**
             * Properties of a CollectionConfigPackage.
             * @memberof common
             * @interface ICollectionConfigPackage
             * @property {Array.<common.ICollectionConfig>|null} [config] CollectionConfigPackage config
             */
    
            /**
             * Constructs a new CollectionConfigPackage.
             * @memberof common
             * @classdesc Represents a CollectionConfigPackage.
             * @implements ICollectionConfigPackage
             * @constructor
             * @param {common.ICollectionConfigPackage=} [properties] Properties to set
             */
            function CollectionConfigPackage(properties) {
                this.config = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionConfigPackage config.
             * @member {Array.<common.ICollectionConfig>} config
             * @memberof common.CollectionConfigPackage
             * @instance
             */
            CollectionConfigPackage.prototype.config = $util.emptyArray;
    
            /**
             * Creates a new CollectionConfigPackage instance using the specified properties.
             * @function create
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {common.ICollectionConfigPackage=} [properties] Properties to set
             * @returns {common.CollectionConfigPackage} CollectionConfigPackage instance
             */
            CollectionConfigPackage.create = function create(properties) {
                return new CollectionConfigPackage(properties);
            };
    
            /**
             * Encodes the specified CollectionConfigPackage message. Does not implicitly {@link common.CollectionConfigPackage.verify|verify} messages.
             * @function encode
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {common.ICollectionConfigPackage} message CollectionConfigPackage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionConfigPackage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.config != null && message.config.length)
                    for (var i = 0; i < message.config.length; ++i)
                        $root.common.CollectionConfig.encode(message.config[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CollectionConfigPackage message, length delimited. Does not implicitly {@link common.CollectionConfigPackage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {common.ICollectionConfigPackage} message CollectionConfigPackage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionConfigPackage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionConfigPackage message from the specified reader or buffer.
             * @function decode
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.CollectionConfigPackage} CollectionConfigPackage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionConfigPackage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.CollectionConfigPackage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.config && message.config.length))
                            message.config = [];
                        message.config.push($root.common.CollectionConfig.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionConfigPackage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.CollectionConfigPackage} CollectionConfigPackage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionConfigPackage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionConfigPackage message.
             * @function verify
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionConfigPackage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.config != null && message.hasOwnProperty("config")) {
                    if (!Array.isArray(message.config))
                        return "config: array expected";
                    for (var i = 0; i < message.config.length; ++i) {
                        var error = $root.common.CollectionConfig.verify(message.config[i]);
                        if (error)
                            return "config." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a CollectionConfigPackage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.CollectionConfigPackage} CollectionConfigPackage
             */
            CollectionConfigPackage.fromObject = function fromObject(object) {
                if (object instanceof $root.common.CollectionConfigPackage)
                    return object;
                var message = new $root.common.CollectionConfigPackage();
                if (object.config) {
                    if (!Array.isArray(object.config))
                        throw TypeError(".common.CollectionConfigPackage.config: array expected");
                    message.config = [];
                    for (var i = 0; i < object.config.length; ++i) {
                        if (typeof object.config[i] !== "object")
                            throw TypeError(".common.CollectionConfigPackage.config: object expected");
                        message.config[i] = $root.common.CollectionConfig.fromObject(object.config[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionConfigPackage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.CollectionConfigPackage
             * @static
             * @param {common.CollectionConfigPackage} message CollectionConfigPackage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionConfigPackage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.config = [];
                if (message.config && message.config.length) {
                    object.config = [];
                    for (var j = 0; j < message.config.length; ++j)
                        object.config[j] = $root.common.CollectionConfig.toObject(message.config[j], options);
                }
                return object;
            };
    
            /**
             * Converts this CollectionConfigPackage to JSON.
             * @function toJSON
             * @memberof common.CollectionConfigPackage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionConfigPackage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionConfigPackage;
        })();
    
        common.CollectionConfig = (function() {
    
            /**
             * Properties of a CollectionConfig.
             * @memberof common
             * @interface ICollectionConfig
             * @property {common.IStaticCollectionConfig|null} [staticCollectionConfig] CollectionConfig staticCollectionConfig
             */
    
            /**
             * Constructs a new CollectionConfig.
             * @memberof common
             * @classdesc Represents a CollectionConfig.
             * @implements ICollectionConfig
             * @constructor
             * @param {common.ICollectionConfig=} [properties] Properties to set
             */
            function CollectionConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionConfig staticCollectionConfig.
             * @member {common.IStaticCollectionConfig|null|undefined} staticCollectionConfig
             * @memberof common.CollectionConfig
             * @instance
             */
            CollectionConfig.prototype.staticCollectionConfig = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * CollectionConfig payload.
             * @member {"staticCollectionConfig"|undefined} payload
             * @memberof common.CollectionConfig
             * @instance
             */
            Object.defineProperty(CollectionConfig.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["staticCollectionConfig"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new CollectionConfig instance using the specified properties.
             * @function create
             * @memberof common.CollectionConfig
             * @static
             * @param {common.ICollectionConfig=} [properties] Properties to set
             * @returns {common.CollectionConfig} CollectionConfig instance
             */
            CollectionConfig.create = function create(properties) {
                return new CollectionConfig(properties);
            };
    
            /**
             * Encodes the specified CollectionConfig message. Does not implicitly {@link common.CollectionConfig.verify|verify} messages.
             * @function encode
             * @memberof common.CollectionConfig
             * @static
             * @param {common.ICollectionConfig} message CollectionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.staticCollectionConfig != null && message.hasOwnProperty("staticCollectionConfig"))
                    $root.common.StaticCollectionConfig.encode(message.staticCollectionConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CollectionConfig message, length delimited. Does not implicitly {@link common.CollectionConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.CollectionConfig
             * @static
             * @param {common.ICollectionConfig} message CollectionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionConfig message from the specified reader or buffer.
             * @function decode
             * @memberof common.CollectionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.CollectionConfig} CollectionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.CollectionConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.staticCollectionConfig = $root.common.StaticCollectionConfig.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.CollectionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.CollectionConfig} CollectionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionConfig message.
             * @function verify
             * @memberof common.CollectionConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.staticCollectionConfig != null && message.hasOwnProperty("staticCollectionConfig")) {
                    properties.payload = 1;
                    {
                        var error = $root.common.StaticCollectionConfig.verify(message.staticCollectionConfig);
                        if (error)
                            return "staticCollectionConfig." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a CollectionConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.CollectionConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.CollectionConfig} CollectionConfig
             */
            CollectionConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.common.CollectionConfig)
                    return object;
                var message = new $root.common.CollectionConfig();
                if (object.staticCollectionConfig != null) {
                    if (typeof object.staticCollectionConfig !== "object")
                        throw TypeError(".common.CollectionConfig.staticCollectionConfig: object expected");
                    message.staticCollectionConfig = $root.common.StaticCollectionConfig.fromObject(object.staticCollectionConfig);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.CollectionConfig
             * @static
             * @param {common.CollectionConfig} message CollectionConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.staticCollectionConfig != null && message.hasOwnProperty("staticCollectionConfig")) {
                    object.staticCollectionConfig = $root.common.StaticCollectionConfig.toObject(message.staticCollectionConfig, options);
                    if (options.oneofs)
                        object.payload = "staticCollectionConfig";
                }
                return object;
            };
    
            /**
             * Converts this CollectionConfig to JSON.
             * @function toJSON
             * @memberof common.CollectionConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionConfig;
        })();
    
        common.StaticCollectionConfig = (function() {
    
            /**
             * Properties of a StaticCollectionConfig.
             * @memberof common
             * @interface IStaticCollectionConfig
             * @property {string|null} [name] StaticCollectionConfig name
             * @property {common.ICollectionPolicyConfig|null} [memberOrgsPolicy] StaticCollectionConfig memberOrgsPolicy
             * @property {number|null} [requiredPeerCount] StaticCollectionConfig requiredPeerCount
             * @property {number|null} [maximumPeerCount] StaticCollectionConfig maximumPeerCount
             * @property {number|Long|null} [blockToLive] StaticCollectionConfig blockToLive
             * @property {boolean|null} [memberOnlyRead] StaticCollectionConfig memberOnlyRead
             * @property {boolean|null} [memberOnlyWrite] StaticCollectionConfig memberOnlyWrite
             */
    
            /**
             * Constructs a new StaticCollectionConfig.
             * @memberof common
             * @classdesc Represents a StaticCollectionConfig.
             * @implements IStaticCollectionConfig
             * @constructor
             * @param {common.IStaticCollectionConfig=} [properties] Properties to set
             */
            function StaticCollectionConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StaticCollectionConfig name.
             * @member {string} name
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.name = "";
    
            /**
             * StaticCollectionConfig memberOrgsPolicy.
             * @member {common.ICollectionPolicyConfig|null|undefined} memberOrgsPolicy
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.memberOrgsPolicy = null;
    
            /**
             * StaticCollectionConfig requiredPeerCount.
             * @member {number} requiredPeerCount
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.requiredPeerCount = 0;
    
            /**
             * StaticCollectionConfig maximumPeerCount.
             * @member {number} maximumPeerCount
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.maximumPeerCount = 0;
    
            /**
             * StaticCollectionConfig blockToLive.
             * @member {number|Long} blockToLive
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.blockToLive = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * StaticCollectionConfig memberOnlyRead.
             * @member {boolean} memberOnlyRead
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.memberOnlyRead = false;
    
            /**
             * StaticCollectionConfig memberOnlyWrite.
             * @member {boolean} memberOnlyWrite
             * @memberof common.StaticCollectionConfig
             * @instance
             */
            StaticCollectionConfig.prototype.memberOnlyWrite = false;
    
            /**
             * Creates a new StaticCollectionConfig instance using the specified properties.
             * @function create
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {common.IStaticCollectionConfig=} [properties] Properties to set
             * @returns {common.StaticCollectionConfig} StaticCollectionConfig instance
             */
            StaticCollectionConfig.create = function create(properties) {
                return new StaticCollectionConfig(properties);
            };
    
            /**
             * Encodes the specified StaticCollectionConfig message. Does not implicitly {@link common.StaticCollectionConfig.verify|verify} messages.
             * @function encode
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {common.IStaticCollectionConfig} message StaticCollectionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaticCollectionConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.memberOrgsPolicy != null && message.hasOwnProperty("memberOrgsPolicy"))
                    $root.common.CollectionPolicyConfig.encode(message.memberOrgsPolicy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.requiredPeerCount != null && message.hasOwnProperty("requiredPeerCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.requiredPeerCount);
                if (message.maximumPeerCount != null && message.hasOwnProperty("maximumPeerCount"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maximumPeerCount);
                if (message.blockToLive != null && message.hasOwnProperty("blockToLive"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.blockToLive);
                if (message.memberOnlyRead != null && message.hasOwnProperty("memberOnlyRead"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.memberOnlyRead);
                if (message.memberOnlyWrite != null && message.hasOwnProperty("memberOnlyWrite"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.memberOnlyWrite);
                return writer;
            };
    
            /**
             * Encodes the specified StaticCollectionConfig message, length delimited. Does not implicitly {@link common.StaticCollectionConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {common.IStaticCollectionConfig} message StaticCollectionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaticCollectionConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StaticCollectionConfig message from the specified reader or buffer.
             * @function decode
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.StaticCollectionConfig} StaticCollectionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaticCollectionConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.StaticCollectionConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.memberOrgsPolicy = $root.common.CollectionPolicyConfig.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.requiredPeerCount = reader.int32();
                        break;
                    case 4:
                        message.maximumPeerCount = reader.int32();
                        break;
                    case 5:
                        message.blockToLive = reader.uint64();
                        break;
                    case 6:
                        message.memberOnlyRead = reader.bool();
                        break;
                    case 7:
                        message.memberOnlyWrite = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StaticCollectionConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.StaticCollectionConfig} StaticCollectionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaticCollectionConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StaticCollectionConfig message.
             * @function verify
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StaticCollectionConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.memberOrgsPolicy != null && message.hasOwnProperty("memberOrgsPolicy")) {
                    var error = $root.common.CollectionPolicyConfig.verify(message.memberOrgsPolicy);
                    if (error)
                        return "memberOrgsPolicy." + error;
                }
                if (message.requiredPeerCount != null && message.hasOwnProperty("requiredPeerCount"))
                    if (!$util.isInteger(message.requiredPeerCount))
                        return "requiredPeerCount: integer expected";
                if (message.maximumPeerCount != null && message.hasOwnProperty("maximumPeerCount"))
                    if (!$util.isInteger(message.maximumPeerCount))
                        return "maximumPeerCount: integer expected";
                if (message.blockToLive != null && message.hasOwnProperty("blockToLive"))
                    if (!$util.isInteger(message.blockToLive) && !(message.blockToLive && $util.isInteger(message.blockToLive.low) && $util.isInteger(message.blockToLive.high)))
                        return "blockToLive: integer|Long expected";
                if (message.memberOnlyRead != null && message.hasOwnProperty("memberOnlyRead"))
                    if (typeof message.memberOnlyRead !== "boolean")
                        return "memberOnlyRead: boolean expected";
                if (message.memberOnlyWrite != null && message.hasOwnProperty("memberOnlyWrite"))
                    if (typeof message.memberOnlyWrite !== "boolean")
                        return "memberOnlyWrite: boolean expected";
                return null;
            };
    
            /**
             * Creates a StaticCollectionConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.StaticCollectionConfig} StaticCollectionConfig
             */
            StaticCollectionConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.common.StaticCollectionConfig)
                    return object;
                var message = new $root.common.StaticCollectionConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.memberOrgsPolicy != null) {
                    if (typeof object.memberOrgsPolicy !== "object")
                        throw TypeError(".common.StaticCollectionConfig.memberOrgsPolicy: object expected");
                    message.memberOrgsPolicy = $root.common.CollectionPolicyConfig.fromObject(object.memberOrgsPolicy);
                }
                if (object.requiredPeerCount != null)
                    message.requiredPeerCount = object.requiredPeerCount | 0;
                if (object.maximumPeerCount != null)
                    message.maximumPeerCount = object.maximumPeerCount | 0;
                if (object.blockToLive != null)
                    if ($util.Long)
                        (message.blockToLive = $util.Long.fromValue(object.blockToLive)).unsigned = true;
                    else if (typeof object.blockToLive === "string")
                        message.blockToLive = parseInt(object.blockToLive, 10);
                    else if (typeof object.blockToLive === "number")
                        message.blockToLive = object.blockToLive;
                    else if (typeof object.blockToLive === "object")
                        message.blockToLive = new $util.LongBits(object.blockToLive.low >>> 0, object.blockToLive.high >>> 0).toNumber(true);
                if (object.memberOnlyRead != null)
                    message.memberOnlyRead = Boolean(object.memberOnlyRead);
                if (object.memberOnlyWrite != null)
                    message.memberOnlyWrite = Boolean(object.memberOnlyWrite);
                return message;
            };
    
            /**
             * Creates a plain object from a StaticCollectionConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.StaticCollectionConfig
             * @static
             * @param {common.StaticCollectionConfig} message StaticCollectionConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StaticCollectionConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.memberOrgsPolicy = null;
                    object.requiredPeerCount = 0;
                    object.maximumPeerCount = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.blockToLive = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.blockToLive = options.longs === String ? "0" : 0;
                    object.memberOnlyRead = false;
                    object.memberOnlyWrite = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.memberOrgsPolicy != null && message.hasOwnProperty("memberOrgsPolicy"))
                    object.memberOrgsPolicy = $root.common.CollectionPolicyConfig.toObject(message.memberOrgsPolicy, options);
                if (message.requiredPeerCount != null && message.hasOwnProperty("requiredPeerCount"))
                    object.requiredPeerCount = message.requiredPeerCount;
                if (message.maximumPeerCount != null && message.hasOwnProperty("maximumPeerCount"))
                    object.maximumPeerCount = message.maximumPeerCount;
                if (message.blockToLive != null && message.hasOwnProperty("blockToLive"))
                    if (typeof message.blockToLive === "number")
                        object.blockToLive = options.longs === String ? String(message.blockToLive) : message.blockToLive;
                    else
                        object.blockToLive = options.longs === String ? $util.Long.prototype.toString.call(message.blockToLive) : options.longs === Number ? new $util.LongBits(message.blockToLive.low >>> 0, message.blockToLive.high >>> 0).toNumber(true) : message.blockToLive;
                if (message.memberOnlyRead != null && message.hasOwnProperty("memberOnlyRead"))
                    object.memberOnlyRead = message.memberOnlyRead;
                if (message.memberOnlyWrite != null && message.hasOwnProperty("memberOnlyWrite"))
                    object.memberOnlyWrite = message.memberOnlyWrite;
                return object;
            };
    
            /**
             * Converts this StaticCollectionConfig to JSON.
             * @function toJSON
             * @memberof common.StaticCollectionConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StaticCollectionConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StaticCollectionConfig;
        })();
    
        common.CollectionPolicyConfig = (function() {
    
            /**
             * Properties of a CollectionPolicyConfig.
             * @memberof common
             * @interface ICollectionPolicyConfig
             * @property {common.ISignaturePolicyEnvelope|null} [signaturePolicy] CollectionPolicyConfig signaturePolicy
             */
    
            /**
             * Constructs a new CollectionPolicyConfig.
             * @memberof common
             * @classdesc Represents a CollectionPolicyConfig.
             * @implements ICollectionPolicyConfig
             * @constructor
             * @param {common.ICollectionPolicyConfig=} [properties] Properties to set
             */
            function CollectionPolicyConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionPolicyConfig signaturePolicy.
             * @member {common.ISignaturePolicyEnvelope|null|undefined} signaturePolicy
             * @memberof common.CollectionPolicyConfig
             * @instance
             */
            CollectionPolicyConfig.prototype.signaturePolicy = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * CollectionPolicyConfig payload.
             * @member {"signaturePolicy"|undefined} payload
             * @memberof common.CollectionPolicyConfig
             * @instance
             */
            Object.defineProperty(CollectionPolicyConfig.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["signaturePolicy"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new CollectionPolicyConfig instance using the specified properties.
             * @function create
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {common.ICollectionPolicyConfig=} [properties] Properties to set
             * @returns {common.CollectionPolicyConfig} CollectionPolicyConfig instance
             */
            CollectionPolicyConfig.create = function create(properties) {
                return new CollectionPolicyConfig(properties);
            };
    
            /**
             * Encodes the specified CollectionPolicyConfig message. Does not implicitly {@link common.CollectionPolicyConfig.verify|verify} messages.
             * @function encode
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {common.ICollectionPolicyConfig} message CollectionPolicyConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionPolicyConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signaturePolicy != null && message.hasOwnProperty("signaturePolicy"))
                    $root.common.SignaturePolicyEnvelope.encode(message.signaturePolicy, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CollectionPolicyConfig message, length delimited. Does not implicitly {@link common.CollectionPolicyConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {common.ICollectionPolicyConfig} message CollectionPolicyConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionPolicyConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionPolicyConfig message from the specified reader or buffer.
             * @function decode
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.CollectionPolicyConfig} CollectionPolicyConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionPolicyConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.CollectionPolicyConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signaturePolicy = $root.common.SignaturePolicyEnvelope.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionPolicyConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.CollectionPolicyConfig} CollectionPolicyConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionPolicyConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionPolicyConfig message.
             * @function verify
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionPolicyConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.signaturePolicy != null && message.hasOwnProperty("signaturePolicy")) {
                    properties.payload = 1;
                    {
                        var error = $root.common.SignaturePolicyEnvelope.verify(message.signaturePolicy);
                        if (error)
                            return "signaturePolicy." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a CollectionPolicyConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.CollectionPolicyConfig} CollectionPolicyConfig
             */
            CollectionPolicyConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.common.CollectionPolicyConfig)
                    return object;
                var message = new $root.common.CollectionPolicyConfig();
                if (object.signaturePolicy != null) {
                    if (typeof object.signaturePolicy !== "object")
                        throw TypeError(".common.CollectionPolicyConfig.signaturePolicy: object expected");
                    message.signaturePolicy = $root.common.SignaturePolicyEnvelope.fromObject(object.signaturePolicy);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionPolicyConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.CollectionPolicyConfig
             * @static
             * @param {common.CollectionPolicyConfig} message CollectionPolicyConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionPolicyConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.signaturePolicy != null && message.hasOwnProperty("signaturePolicy")) {
                    object.signaturePolicy = $root.common.SignaturePolicyEnvelope.toObject(message.signaturePolicy, options);
                    if (options.oneofs)
                        object.payload = "signaturePolicy";
                }
                return object;
            };
    
            /**
             * Converts this CollectionPolicyConfig to JSON.
             * @function toJSON
             * @memberof common.CollectionPolicyConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionPolicyConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionPolicyConfig;
        })();
    
        common.CollectionCriteria = (function() {
    
            /**
             * Properties of a CollectionCriteria.
             * @memberof common
             * @interface ICollectionCriteria
             * @property {string|null} [channel] CollectionCriteria channel
             * @property {string|null} [txId] CollectionCriteria txId
             * @property {string|null} [collection] CollectionCriteria collection
             * @property {string|null} [namespace] CollectionCriteria namespace
             */
    
            /**
             * Constructs a new CollectionCriteria.
             * @memberof common
             * @classdesc Represents a CollectionCriteria.
             * @implements ICollectionCriteria
             * @constructor
             * @param {common.ICollectionCriteria=} [properties] Properties to set
             */
            function CollectionCriteria(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionCriteria channel.
             * @member {string} channel
             * @memberof common.CollectionCriteria
             * @instance
             */
            CollectionCriteria.prototype.channel = "";
    
            /**
             * CollectionCriteria txId.
             * @member {string} txId
             * @memberof common.CollectionCriteria
             * @instance
             */
            CollectionCriteria.prototype.txId = "";
    
            /**
             * CollectionCriteria collection.
             * @member {string} collection
             * @memberof common.CollectionCriteria
             * @instance
             */
            CollectionCriteria.prototype.collection = "";
    
            /**
             * CollectionCriteria namespace.
             * @member {string} namespace
             * @memberof common.CollectionCriteria
             * @instance
             */
            CollectionCriteria.prototype.namespace = "";
    
            /**
             * Creates a new CollectionCriteria instance using the specified properties.
             * @function create
             * @memberof common.CollectionCriteria
             * @static
             * @param {common.ICollectionCriteria=} [properties] Properties to set
             * @returns {common.CollectionCriteria} CollectionCriteria instance
             */
            CollectionCriteria.create = function create(properties) {
                return new CollectionCriteria(properties);
            };
    
            /**
             * Encodes the specified CollectionCriteria message. Does not implicitly {@link common.CollectionCriteria.verify|verify} messages.
             * @function encode
             * @memberof common.CollectionCriteria
             * @static
             * @param {common.ICollectionCriteria} message CollectionCriteria message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionCriteria.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.txId != null && message.hasOwnProperty("txId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.txId);
                if (message.collection != null && message.hasOwnProperty("collection"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.collection);
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.namespace);
                return writer;
            };
    
            /**
             * Encodes the specified CollectionCriteria message, length delimited. Does not implicitly {@link common.CollectionCriteria.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.CollectionCriteria
             * @static
             * @param {common.ICollectionCriteria} message CollectionCriteria message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionCriteria.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionCriteria message from the specified reader or buffer.
             * @function decode
             * @memberof common.CollectionCriteria
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.CollectionCriteria} CollectionCriteria
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionCriteria.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.CollectionCriteria();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.txId = reader.string();
                        break;
                    case 3:
                        message.collection = reader.string();
                        break;
                    case 4:
                        message.namespace = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionCriteria message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.CollectionCriteria
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.CollectionCriteria} CollectionCriteria
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionCriteria.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionCriteria message.
             * @function verify
             * @memberof common.CollectionCriteria
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionCriteria.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isString(message.txId))
                        return "txId: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                return null;
            };
    
            /**
             * Creates a CollectionCriteria message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.CollectionCriteria
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.CollectionCriteria} CollectionCriteria
             */
            CollectionCriteria.fromObject = function fromObject(object) {
                if (object instanceof $root.common.CollectionCriteria)
                    return object;
                var message = new $root.common.CollectionCriteria();
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.txId != null)
                    message.txId = String(object.txId);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionCriteria message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.CollectionCriteria
             * @static
             * @param {common.CollectionCriteria} message CollectionCriteria
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionCriteria.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = "";
                    object.txId = "";
                    object.collection = "";
                    object.namespace = "";
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.txId != null && message.hasOwnProperty("txId"))
                    object.txId = message.txId;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                return object;
            };
    
            /**
             * Converts this CollectionCriteria to JSON.
             * @function toJSON
             * @memberof common.CollectionCriteria
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionCriteria.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionCriteria;
        })();
    
        common.Policy = (function() {
    
            /**
             * Properties of a Policy.
             * @memberof common
             * @interface IPolicy
             * @property {number|null} [type] Policy type
             * @property {Uint8Array|null} [value] Policy value
             */
    
            /**
             * Constructs a new Policy.
             * @memberof common
             * @classdesc Represents a Policy.
             * @implements IPolicy
             * @constructor
             * @param {common.IPolicy=} [properties] Properties to set
             */
            function Policy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Policy type.
             * @member {number} type
             * @memberof common.Policy
             * @instance
             */
            Policy.prototype.type = 0;
    
            /**
             * Policy value.
             * @member {Uint8Array} value
             * @memberof common.Policy
             * @instance
             */
            Policy.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new Policy instance using the specified properties.
             * @function create
             * @memberof common.Policy
             * @static
             * @param {common.IPolicy=} [properties] Properties to set
             * @returns {common.Policy} Policy instance
             */
            Policy.create = function create(properties) {
                return new Policy(properties);
            };
    
            /**
             * Encodes the specified Policy message. Does not implicitly {@link common.Policy.verify|verify} messages.
             * @function encode
             * @memberof common.Policy
             * @static
             * @param {common.IPolicy} message Policy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Policy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified Policy message, length delimited. Does not implicitly {@link common.Policy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Policy
             * @static
             * @param {common.IPolicy} message Policy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Policy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Policy message from the specified reader or buffer.
             * @function decode
             * @memberof common.Policy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Policy} Policy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Policy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Policy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Policy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Policy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Policy} Policy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Policy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Policy message.
             * @function verify
             * @memberof common.Policy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Policy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a Policy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Policy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Policy} Policy
             */
            Policy.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Policy)
                    return object;
                var message = new $root.common.Policy();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a Policy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Policy
             * @static
             * @param {common.Policy} message Policy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Policy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this Policy to JSON.
             * @function toJSON
             * @memberof common.Policy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Policy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * PolicyType enum.
             * @name common.Policy.PolicyType
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} SIGNATURE=1 SIGNATURE value
             * @property {number} MSP=2 MSP value
             * @property {number} IMPLICIT_META=3 IMPLICIT_META value
             */
            Policy.PolicyType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "SIGNATURE"] = 1;
                values[valuesById[2] = "MSP"] = 2;
                values[valuesById[3] = "IMPLICIT_META"] = 3;
                return values;
            })();
    
            return Policy;
        })();
    
        common.SignaturePolicyEnvelope = (function() {
    
            /**
             * Properties of a SignaturePolicyEnvelope.
             * @memberof common
             * @interface ISignaturePolicyEnvelope
             * @property {number|null} [version] SignaturePolicyEnvelope version
             * @property {common.ISignaturePolicy|null} [rule] SignaturePolicyEnvelope rule
             * @property {Array.<common.IMSPPrincipal>|null} [identities] SignaturePolicyEnvelope identities
             */
    
            /**
             * Constructs a new SignaturePolicyEnvelope.
             * @memberof common
             * @classdesc Represents a SignaturePolicyEnvelope.
             * @implements ISignaturePolicyEnvelope
             * @constructor
             * @param {common.ISignaturePolicyEnvelope=} [properties] Properties to set
             */
            function SignaturePolicyEnvelope(properties) {
                this.identities = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignaturePolicyEnvelope version.
             * @member {number} version
             * @memberof common.SignaturePolicyEnvelope
             * @instance
             */
            SignaturePolicyEnvelope.prototype.version = 0;
    
            /**
             * SignaturePolicyEnvelope rule.
             * @member {common.ISignaturePolicy|null|undefined} rule
             * @memberof common.SignaturePolicyEnvelope
             * @instance
             */
            SignaturePolicyEnvelope.prototype.rule = null;
    
            /**
             * SignaturePolicyEnvelope identities.
             * @member {Array.<common.IMSPPrincipal>} identities
             * @memberof common.SignaturePolicyEnvelope
             * @instance
             */
            SignaturePolicyEnvelope.prototype.identities = $util.emptyArray;
    
            /**
             * Creates a new SignaturePolicyEnvelope instance using the specified properties.
             * @function create
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {common.ISignaturePolicyEnvelope=} [properties] Properties to set
             * @returns {common.SignaturePolicyEnvelope} SignaturePolicyEnvelope instance
             */
            SignaturePolicyEnvelope.create = function create(properties) {
                return new SignaturePolicyEnvelope(properties);
            };
    
            /**
             * Encodes the specified SignaturePolicyEnvelope message. Does not implicitly {@link common.SignaturePolicyEnvelope.verify|verify} messages.
             * @function encode
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {common.ISignaturePolicyEnvelope} message SignaturePolicyEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignaturePolicyEnvelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
                if (message.rule != null && message.hasOwnProperty("rule"))
                    $root.common.SignaturePolicy.encode(message.rule, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identities != null && message.identities.length)
                    for (var i = 0; i < message.identities.length; ++i)
                        $root.common.MSPPrincipal.encode(message.identities[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SignaturePolicyEnvelope message, length delimited. Does not implicitly {@link common.SignaturePolicyEnvelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {common.ISignaturePolicyEnvelope} message SignaturePolicyEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignaturePolicyEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignaturePolicyEnvelope message from the specified reader or buffer.
             * @function decode
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.SignaturePolicyEnvelope} SignaturePolicyEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignaturePolicyEnvelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.SignaturePolicyEnvelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.int32();
                        break;
                    case 2:
                        message.rule = $root.common.SignaturePolicy.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.identities && message.identities.length))
                            message.identities = [];
                        message.identities.push($root.common.MSPPrincipal.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignaturePolicyEnvelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.SignaturePolicyEnvelope} SignaturePolicyEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignaturePolicyEnvelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignaturePolicyEnvelope message.
             * @function verify
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignaturePolicyEnvelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.rule != null && message.hasOwnProperty("rule")) {
                    var error = $root.common.SignaturePolicy.verify(message.rule);
                    if (error)
                        return "rule." + error;
                }
                if (message.identities != null && message.hasOwnProperty("identities")) {
                    if (!Array.isArray(message.identities))
                        return "identities: array expected";
                    for (var i = 0; i < message.identities.length; ++i) {
                        var error = $root.common.MSPPrincipal.verify(message.identities[i]);
                        if (error)
                            return "identities." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SignaturePolicyEnvelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.SignaturePolicyEnvelope} SignaturePolicyEnvelope
             */
            SignaturePolicyEnvelope.fromObject = function fromObject(object) {
                if (object instanceof $root.common.SignaturePolicyEnvelope)
                    return object;
                var message = new $root.common.SignaturePolicyEnvelope();
                if (object.version != null)
                    message.version = object.version | 0;
                if (object.rule != null) {
                    if (typeof object.rule !== "object")
                        throw TypeError(".common.SignaturePolicyEnvelope.rule: object expected");
                    message.rule = $root.common.SignaturePolicy.fromObject(object.rule);
                }
                if (object.identities) {
                    if (!Array.isArray(object.identities))
                        throw TypeError(".common.SignaturePolicyEnvelope.identities: array expected");
                    message.identities = [];
                    for (var i = 0; i < object.identities.length; ++i) {
                        if (typeof object.identities[i] !== "object")
                            throw TypeError(".common.SignaturePolicyEnvelope.identities: object expected");
                        message.identities[i] = $root.common.MSPPrincipal.fromObject(object.identities[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SignaturePolicyEnvelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.SignaturePolicyEnvelope
             * @static
             * @param {common.SignaturePolicyEnvelope} message SignaturePolicyEnvelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignaturePolicyEnvelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.identities = [];
                if (options.defaults) {
                    object.version = 0;
                    object.rule = null;
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.rule != null && message.hasOwnProperty("rule"))
                    object.rule = $root.common.SignaturePolicy.toObject(message.rule, options);
                if (message.identities && message.identities.length) {
                    object.identities = [];
                    for (var j = 0; j < message.identities.length; ++j)
                        object.identities[j] = $root.common.MSPPrincipal.toObject(message.identities[j], options);
                }
                return object;
            };
    
            /**
             * Converts this SignaturePolicyEnvelope to JSON.
             * @function toJSON
             * @memberof common.SignaturePolicyEnvelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignaturePolicyEnvelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignaturePolicyEnvelope;
        })();
    
        common.SignaturePolicy = (function() {
    
            /**
             * Properties of a SignaturePolicy.
             * @memberof common
             * @interface ISignaturePolicy
             * @property {number|null} [signedBy] SignaturePolicy signedBy
             * @property {common.SignaturePolicy.INOutOf|null} [nOutOf] SignaturePolicy nOutOf
             */
    
            /**
             * Constructs a new SignaturePolicy.
             * @memberof common
             * @classdesc Represents a SignaturePolicy.
             * @implements ISignaturePolicy
             * @constructor
             * @param {common.ISignaturePolicy=} [properties] Properties to set
             */
            function SignaturePolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignaturePolicy signedBy.
             * @member {number} signedBy
             * @memberof common.SignaturePolicy
             * @instance
             */
            SignaturePolicy.prototype.signedBy = 0;
    
            /**
             * SignaturePolicy nOutOf.
             * @member {common.SignaturePolicy.INOutOf|null|undefined} nOutOf
             * @memberof common.SignaturePolicy
             * @instance
             */
            SignaturePolicy.prototype.nOutOf = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * SignaturePolicy Type.
             * @member {"signedBy"|"nOutOf"|undefined} Type
             * @memberof common.SignaturePolicy
             * @instance
             */
            Object.defineProperty(SignaturePolicy.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["signedBy", "nOutOf"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new SignaturePolicy instance using the specified properties.
             * @function create
             * @memberof common.SignaturePolicy
             * @static
             * @param {common.ISignaturePolicy=} [properties] Properties to set
             * @returns {common.SignaturePolicy} SignaturePolicy instance
             */
            SignaturePolicy.create = function create(properties) {
                return new SignaturePolicy(properties);
            };
    
            /**
             * Encodes the specified SignaturePolicy message. Does not implicitly {@link common.SignaturePolicy.verify|verify} messages.
             * @function encode
             * @memberof common.SignaturePolicy
             * @static
             * @param {common.ISignaturePolicy} message SignaturePolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignaturePolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signedBy != null && message.hasOwnProperty("signedBy"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.signedBy);
                if (message.nOutOf != null && message.hasOwnProperty("nOutOf"))
                    $root.common.SignaturePolicy.NOutOf.encode(message.nOutOf, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SignaturePolicy message, length delimited. Does not implicitly {@link common.SignaturePolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.SignaturePolicy
             * @static
             * @param {common.ISignaturePolicy} message SignaturePolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignaturePolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignaturePolicy message from the specified reader or buffer.
             * @function decode
             * @memberof common.SignaturePolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.SignaturePolicy} SignaturePolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignaturePolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.SignaturePolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signedBy = reader.int32();
                        break;
                    case 2:
                        message.nOutOf = $root.common.SignaturePolicy.NOutOf.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignaturePolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.SignaturePolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.SignaturePolicy} SignaturePolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignaturePolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignaturePolicy message.
             * @function verify
             * @memberof common.SignaturePolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignaturePolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.signedBy != null && message.hasOwnProperty("signedBy")) {
                    properties.Type = 1;
                    if (!$util.isInteger(message.signedBy))
                        return "signedBy: integer expected";
                }
                if (message.nOutOf != null && message.hasOwnProperty("nOutOf")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.common.SignaturePolicy.NOutOf.verify(message.nOutOf);
                        if (error)
                            return "nOutOf." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SignaturePolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.SignaturePolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.SignaturePolicy} SignaturePolicy
             */
            SignaturePolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.common.SignaturePolicy)
                    return object;
                var message = new $root.common.SignaturePolicy();
                if (object.signedBy != null)
                    message.signedBy = object.signedBy | 0;
                if (object.nOutOf != null) {
                    if (typeof object.nOutOf !== "object")
                        throw TypeError(".common.SignaturePolicy.nOutOf: object expected");
                    message.nOutOf = $root.common.SignaturePolicy.NOutOf.fromObject(object.nOutOf);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SignaturePolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.SignaturePolicy
             * @static
             * @param {common.SignaturePolicy} message SignaturePolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignaturePolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.signedBy != null && message.hasOwnProperty("signedBy")) {
                    object.signedBy = message.signedBy;
                    if (options.oneofs)
                        object.Type = "signedBy";
                }
                if (message.nOutOf != null && message.hasOwnProperty("nOutOf")) {
                    object.nOutOf = $root.common.SignaturePolicy.NOutOf.toObject(message.nOutOf, options);
                    if (options.oneofs)
                        object.Type = "nOutOf";
                }
                return object;
            };
    
            /**
             * Converts this SignaturePolicy to JSON.
             * @function toJSON
             * @memberof common.SignaturePolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignaturePolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            SignaturePolicy.NOutOf = (function() {
    
                /**
                 * Properties of a NOutOf.
                 * @memberof common.SignaturePolicy
                 * @interface INOutOf
                 * @property {number|null} [n] NOutOf n
                 * @property {Array.<common.ISignaturePolicy>|null} [rules] NOutOf rules
                 */
    
                /**
                 * Constructs a new NOutOf.
                 * @memberof common.SignaturePolicy
                 * @classdesc Represents a NOutOf.
                 * @implements INOutOf
                 * @constructor
                 * @param {common.SignaturePolicy.INOutOf=} [properties] Properties to set
                 */
                function NOutOf(properties) {
                    this.rules = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NOutOf n.
                 * @member {number} n
                 * @memberof common.SignaturePolicy.NOutOf
                 * @instance
                 */
                NOutOf.prototype.n = 0;
    
                /**
                 * NOutOf rules.
                 * @member {Array.<common.ISignaturePolicy>} rules
                 * @memberof common.SignaturePolicy.NOutOf
                 * @instance
                 */
                NOutOf.prototype.rules = $util.emptyArray;
    
                /**
                 * Creates a new NOutOf instance using the specified properties.
                 * @function create
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {common.SignaturePolicy.INOutOf=} [properties] Properties to set
                 * @returns {common.SignaturePolicy.NOutOf} NOutOf instance
                 */
                NOutOf.create = function create(properties) {
                    return new NOutOf(properties);
                };
    
                /**
                 * Encodes the specified NOutOf message. Does not implicitly {@link common.SignaturePolicy.NOutOf.verify|verify} messages.
                 * @function encode
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {common.SignaturePolicy.INOutOf} message NOutOf message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NOutOf.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.n != null && message.hasOwnProperty("n"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.n);
                    if (message.rules != null && message.rules.length)
                        for (var i = 0; i < message.rules.length; ++i)
                            $root.common.SignaturePolicy.encode(message.rules[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NOutOf message, length delimited. Does not implicitly {@link common.SignaturePolicy.NOutOf.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {common.SignaturePolicy.INOutOf} message NOutOf message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NOutOf.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NOutOf message from the specified reader or buffer.
                 * @function decode
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {common.SignaturePolicy.NOutOf} NOutOf
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NOutOf.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.SignaturePolicy.NOutOf();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.n = reader.int32();
                            break;
                        case 2:
                            if (!(message.rules && message.rules.length))
                                message.rules = [];
                            message.rules.push($root.common.SignaturePolicy.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NOutOf message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {common.SignaturePolicy.NOutOf} NOutOf
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NOutOf.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NOutOf message.
                 * @function verify
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NOutOf.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.n != null && message.hasOwnProperty("n"))
                        if (!$util.isInteger(message.n))
                            return "n: integer expected";
                    if (message.rules != null && message.hasOwnProperty("rules")) {
                        if (!Array.isArray(message.rules))
                            return "rules: array expected";
                        for (var i = 0; i < message.rules.length; ++i) {
                            var error = $root.common.SignaturePolicy.verify(message.rules[i]);
                            if (error)
                                return "rules." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NOutOf message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {common.SignaturePolicy.NOutOf} NOutOf
                 */
                NOutOf.fromObject = function fromObject(object) {
                    if (object instanceof $root.common.SignaturePolicy.NOutOf)
                        return object;
                    var message = new $root.common.SignaturePolicy.NOutOf();
                    if (object.n != null)
                        message.n = object.n | 0;
                    if (object.rules) {
                        if (!Array.isArray(object.rules))
                            throw TypeError(".common.SignaturePolicy.NOutOf.rules: array expected");
                        message.rules = [];
                        for (var i = 0; i < object.rules.length; ++i) {
                            if (typeof object.rules[i] !== "object")
                                throw TypeError(".common.SignaturePolicy.NOutOf.rules: object expected");
                            message.rules[i] = $root.common.SignaturePolicy.fromObject(object.rules[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NOutOf message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof common.SignaturePolicy.NOutOf
                 * @static
                 * @param {common.SignaturePolicy.NOutOf} message NOutOf
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NOutOf.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.rules = [];
                    if (options.defaults)
                        object.n = 0;
                    if (message.n != null && message.hasOwnProperty("n"))
                        object.n = message.n;
                    if (message.rules && message.rules.length) {
                        object.rules = [];
                        for (var j = 0; j < message.rules.length; ++j)
                            object.rules[j] = $root.common.SignaturePolicy.toObject(message.rules[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this NOutOf to JSON.
                 * @function toJSON
                 * @memberof common.SignaturePolicy.NOutOf
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NOutOf.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NOutOf;
            })();
    
            return SignaturePolicy;
        })();
    
        common.ImplicitMetaPolicy = (function() {
    
            /**
             * Properties of an ImplicitMetaPolicy.
             * @memberof common
             * @interface IImplicitMetaPolicy
             * @property {string|null} [subPolicy] ImplicitMetaPolicy subPolicy
             * @property {common.ImplicitMetaPolicy.Rule|null} [rule] ImplicitMetaPolicy rule
             */
    
            /**
             * Constructs a new ImplicitMetaPolicy.
             * @memberof common
             * @classdesc Represents an ImplicitMetaPolicy.
             * @implements IImplicitMetaPolicy
             * @constructor
             * @param {common.IImplicitMetaPolicy=} [properties] Properties to set
             */
            function ImplicitMetaPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ImplicitMetaPolicy subPolicy.
             * @member {string} subPolicy
             * @memberof common.ImplicitMetaPolicy
             * @instance
             */
            ImplicitMetaPolicy.prototype.subPolicy = "";
    
            /**
             * ImplicitMetaPolicy rule.
             * @member {common.ImplicitMetaPolicy.Rule} rule
             * @memberof common.ImplicitMetaPolicy
             * @instance
             */
            ImplicitMetaPolicy.prototype.rule = 0;
    
            /**
             * Creates a new ImplicitMetaPolicy instance using the specified properties.
             * @function create
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {common.IImplicitMetaPolicy=} [properties] Properties to set
             * @returns {common.ImplicitMetaPolicy} ImplicitMetaPolicy instance
             */
            ImplicitMetaPolicy.create = function create(properties) {
                return new ImplicitMetaPolicy(properties);
            };
    
            /**
             * Encodes the specified ImplicitMetaPolicy message. Does not implicitly {@link common.ImplicitMetaPolicy.verify|verify} messages.
             * @function encode
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {common.IImplicitMetaPolicy} message ImplicitMetaPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImplicitMetaPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subPolicy != null && message.hasOwnProperty("subPolicy"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subPolicy);
                if (message.rule != null && message.hasOwnProperty("rule"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rule);
                return writer;
            };
    
            /**
             * Encodes the specified ImplicitMetaPolicy message, length delimited. Does not implicitly {@link common.ImplicitMetaPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {common.IImplicitMetaPolicy} message ImplicitMetaPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImplicitMetaPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ImplicitMetaPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ImplicitMetaPolicy} ImplicitMetaPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImplicitMetaPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ImplicitMetaPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subPolicy = reader.string();
                        break;
                    case 2:
                        message.rule = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ImplicitMetaPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ImplicitMetaPolicy} ImplicitMetaPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImplicitMetaPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ImplicitMetaPolicy message.
             * @function verify
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImplicitMetaPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subPolicy != null && message.hasOwnProperty("subPolicy"))
                    if (!$util.isString(message.subPolicy))
                        return "subPolicy: string expected";
                if (message.rule != null && message.hasOwnProperty("rule"))
                    switch (message.rule) {
                    default:
                        return "rule: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates an ImplicitMetaPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ImplicitMetaPolicy} ImplicitMetaPolicy
             */
            ImplicitMetaPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ImplicitMetaPolicy)
                    return object;
                var message = new $root.common.ImplicitMetaPolicy();
                if (object.subPolicy != null)
                    message.subPolicy = String(object.subPolicy);
                switch (object.rule) {
                case "ANY":
                case 0:
                    message.rule = 0;
                    break;
                case "ALL":
                case 1:
                    message.rule = 1;
                    break;
                case "MAJORITY":
                case 2:
                    message.rule = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from an ImplicitMetaPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ImplicitMetaPolicy
             * @static
             * @param {common.ImplicitMetaPolicy} message ImplicitMetaPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImplicitMetaPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.subPolicy = "";
                    object.rule = options.enums === String ? "ANY" : 0;
                }
                if (message.subPolicy != null && message.hasOwnProperty("subPolicy"))
                    object.subPolicy = message.subPolicy;
                if (message.rule != null && message.hasOwnProperty("rule"))
                    object.rule = options.enums === String ? $root.common.ImplicitMetaPolicy.Rule[message.rule] : message.rule;
                return object;
            };
    
            /**
             * Converts this ImplicitMetaPolicy to JSON.
             * @function toJSON
             * @memberof common.ImplicitMetaPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImplicitMetaPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Rule enum.
             * @name common.ImplicitMetaPolicy.Rule
             * @enum {string}
             * @property {number} ANY=0 ANY value
             * @property {number} ALL=1 ALL value
             * @property {number} MAJORITY=2 MAJORITY value
             */
            ImplicitMetaPolicy.Rule = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ANY"] = 0;
                values[valuesById[1] = "ALL"] = 1;
                values[valuesById[2] = "MAJORITY"] = 2;
                return values;
            })();
    
            return ImplicitMetaPolicy;
        })();
    
        /**
         * Status enum.
         * @name common.Status
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} SUCCESS=200 SUCCESS value
         * @property {number} BAD_REQUEST=400 BAD_REQUEST value
         * @property {number} FORBIDDEN=403 FORBIDDEN value
         * @property {number} NOT_FOUND=404 NOT_FOUND value
         * @property {number} REQUEST_ENTITY_TOO_LARGE=413 REQUEST_ENTITY_TOO_LARGE value
         * @property {number} INTERNAL_SERVER_ERROR=500 INTERNAL_SERVER_ERROR value
         * @property {number} NOT_IMPLEMENTED=501 NOT_IMPLEMENTED value
         * @property {number} SERVICE_UNAVAILABLE=503 SERVICE_UNAVAILABLE value
         */
        common.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[200] = "SUCCESS"] = 200;
            values[valuesById[400] = "BAD_REQUEST"] = 400;
            values[valuesById[403] = "FORBIDDEN"] = 403;
            values[valuesById[404] = "NOT_FOUND"] = 404;
            values[valuesById[413] = "REQUEST_ENTITY_TOO_LARGE"] = 413;
            values[valuesById[500] = "INTERNAL_SERVER_ERROR"] = 500;
            values[valuesById[501] = "NOT_IMPLEMENTED"] = 501;
            values[valuesById[503] = "SERVICE_UNAVAILABLE"] = 503;
            return values;
        })();
    
        /**
         * HeaderType enum.
         * @name common.HeaderType
         * @enum {string}
         * @property {number} MESSAGE=0 MESSAGE value
         * @property {number} CONFIG=1 CONFIG value
         * @property {number} CONFIG_UPDATE=2 CONFIG_UPDATE value
         * @property {number} ENDORSER_TRANSACTION=3 ENDORSER_TRANSACTION value
         * @property {number} ORDERER_TRANSACTION=4 ORDERER_TRANSACTION value
         * @property {number} DELIVER_SEEK_INFO=5 DELIVER_SEEK_INFO value
         * @property {number} CHAINCODE_PACKAGE=6 CHAINCODE_PACKAGE value
         * @property {number} PEER_ADMIN_OPERATION=8 PEER_ADMIN_OPERATION value
         */
        common.HeaderType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MESSAGE"] = 0;
            values[valuesById[1] = "CONFIG"] = 1;
            values[valuesById[2] = "CONFIG_UPDATE"] = 2;
            values[valuesById[3] = "ENDORSER_TRANSACTION"] = 3;
            values[valuesById[4] = "ORDERER_TRANSACTION"] = 4;
            values[valuesById[5] = "DELIVER_SEEK_INFO"] = 5;
            values[valuesById[6] = "CHAINCODE_PACKAGE"] = 6;
            values[valuesById[8] = "PEER_ADMIN_OPERATION"] = 8;
            return values;
        })();
    
        /**
         * BlockMetadataIndex enum.
         * @name common.BlockMetadataIndex
         * @enum {string}
         * @property {number} SIGNATURES=0 SIGNATURES value
         * @property {number} LAST_CONFIG=1 LAST_CONFIG value
         * @property {number} TRANSACTIONS_FILTER=2 TRANSACTIONS_FILTER value
         * @property {number} ORDERER=3 ORDERER value
         * @property {number} COMMIT_HASH=4 COMMIT_HASH value
         */
        common.BlockMetadataIndex = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SIGNATURES"] = 0;
            values[valuesById[1] = "LAST_CONFIG"] = 1;
            values[valuesById[2] = "TRANSACTIONS_FILTER"] = 2;
            values[valuesById[3] = "ORDERER"] = 3;
            values[valuesById[4] = "COMMIT_HASH"] = 4;
            return values;
        })();
    
        common.LastConfig = (function() {
    
            /**
             * Properties of a LastConfig.
             * @memberof common
             * @interface ILastConfig
             * @property {number|Long|null} [index] LastConfig index
             */
    
            /**
             * Constructs a new LastConfig.
             * @memberof common
             * @classdesc Represents a LastConfig.
             * @implements ILastConfig
             * @constructor
             * @param {common.ILastConfig=} [properties] Properties to set
             */
            function LastConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LastConfig index.
             * @member {number|Long} index
             * @memberof common.LastConfig
             * @instance
             */
            LastConfig.prototype.index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new LastConfig instance using the specified properties.
             * @function create
             * @memberof common.LastConfig
             * @static
             * @param {common.ILastConfig=} [properties] Properties to set
             * @returns {common.LastConfig} LastConfig instance
             */
            LastConfig.create = function create(properties) {
                return new LastConfig(properties);
            };
    
            /**
             * Encodes the specified LastConfig message. Does not implicitly {@link common.LastConfig.verify|verify} messages.
             * @function encode
             * @memberof common.LastConfig
             * @static
             * @param {common.ILastConfig} message LastConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LastConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && message.hasOwnProperty("index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.index);
                return writer;
            };
    
            /**
             * Encodes the specified LastConfig message, length delimited. Does not implicitly {@link common.LastConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.LastConfig
             * @static
             * @param {common.ILastConfig} message LastConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LastConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LastConfig message from the specified reader or buffer.
             * @function decode
             * @memberof common.LastConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.LastConfig} LastConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LastConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.LastConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.index = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LastConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.LastConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.LastConfig} LastConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LastConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LastConfig message.
             * @function verify
             * @memberof common.LastConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LastConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                        return "index: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a LastConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.LastConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.LastConfig} LastConfig
             */
            LastConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.common.LastConfig)
                    return object;
                var message = new $root.common.LastConfig();
                if (object.index != null)
                    if ($util.Long)
                        (message.index = $util.Long.fromValue(object.index)).unsigned = true;
                    else if (typeof object.index === "string")
                        message.index = parseInt(object.index, 10);
                    else if (typeof object.index === "number")
                        message.index = object.index;
                    else if (typeof object.index === "object")
                        message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a LastConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.LastConfig
             * @static
             * @param {common.LastConfig} message LastConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LastConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.index = options.longs === String ? "0" : 0;
                if (message.index != null && message.hasOwnProperty("index"))
                    if (typeof message.index === "number")
                        object.index = options.longs === String ? String(message.index) : message.index;
                    else
                        object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber(true) : message.index;
                return object;
            };
    
            /**
             * Converts this LastConfig to JSON.
             * @function toJSON
             * @memberof common.LastConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LastConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LastConfig;
        })();
    
        common.Metadata = (function() {
    
            /**
             * Properties of a Metadata.
             * @memberof common
             * @interface IMetadata
             * @property {Uint8Array|null} [value] Metadata value
             * @property {Array.<common.IMetadataSignature>|null} [signatures] Metadata signatures
             */
    
            /**
             * Constructs a new Metadata.
             * @memberof common
             * @classdesc Represents a Metadata.
             * @implements IMetadata
             * @constructor
             * @param {common.IMetadata=} [properties] Properties to set
             */
            function Metadata(properties) {
                this.signatures = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Metadata value.
             * @member {Uint8Array} value
             * @memberof common.Metadata
             * @instance
             */
            Metadata.prototype.value = $util.newBuffer([]);
    
            /**
             * Metadata signatures.
             * @member {Array.<common.IMetadataSignature>} signatures
             * @memberof common.Metadata
             * @instance
             */
            Metadata.prototype.signatures = $util.emptyArray;
    
            /**
             * Creates a new Metadata instance using the specified properties.
             * @function create
             * @memberof common.Metadata
             * @static
             * @param {common.IMetadata=} [properties] Properties to set
             * @returns {common.Metadata} Metadata instance
             */
            Metadata.create = function create(properties) {
                return new Metadata(properties);
            };
    
            /**
             * Encodes the specified Metadata message. Does not implicitly {@link common.Metadata.verify|verify} messages.
             * @function encode
             * @memberof common.Metadata
             * @static
             * @param {common.IMetadata} message Metadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Metadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                if (message.signatures != null && message.signatures.length)
                    for (var i = 0; i < message.signatures.length; ++i)
                        $root.common.MetadataSignature.encode(message.signatures[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Metadata message, length delimited. Does not implicitly {@link common.Metadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Metadata
             * @static
             * @param {common.IMetadata} message Metadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Metadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Metadata message from the specified reader or buffer.
             * @function decode
             * @memberof common.Metadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Metadata} Metadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Metadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Metadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bytes();
                        break;
                    case 2:
                        if (!(message.signatures && message.signatures.length))
                            message.signatures = [];
                        message.signatures.push($root.common.MetadataSignature.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Metadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Metadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Metadata} Metadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Metadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Metadata message.
             * @function verify
             * @memberof common.Metadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Metadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.signatures != null && message.hasOwnProperty("signatures")) {
                    if (!Array.isArray(message.signatures))
                        return "signatures: array expected";
                    for (var i = 0; i < message.signatures.length; ++i) {
                        var error = $root.common.MetadataSignature.verify(message.signatures[i]);
                        if (error)
                            return "signatures." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Metadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Metadata} Metadata
             */
            Metadata.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Metadata)
                    return object;
                var message = new $root.common.Metadata();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.signatures) {
                    if (!Array.isArray(object.signatures))
                        throw TypeError(".common.Metadata.signatures: array expected");
                    message.signatures = [];
                    for (var i = 0; i < object.signatures.length; ++i) {
                        if (typeof object.signatures[i] !== "object")
                            throw TypeError(".common.Metadata.signatures: object expected");
                        message.signatures[i] = $root.common.MetadataSignature.fromObject(object.signatures[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Metadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Metadata
             * @static
             * @param {common.Metadata} message Metadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Metadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.signatures = [];
                if (options.defaults)
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.signatures && message.signatures.length) {
                    object.signatures = [];
                    for (var j = 0; j < message.signatures.length; ++j)
                        object.signatures[j] = $root.common.MetadataSignature.toObject(message.signatures[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Metadata to JSON.
             * @function toJSON
             * @memberof common.Metadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Metadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Metadata;
        })();
    
        common.MetadataSignature = (function() {
    
            /**
             * Properties of a MetadataSignature.
             * @memberof common
             * @interface IMetadataSignature
             * @property {Uint8Array|null} [signatureHeader] MetadataSignature signatureHeader
             * @property {Uint8Array|null} [signature] MetadataSignature signature
             */
    
            /**
             * Constructs a new MetadataSignature.
             * @memberof common
             * @classdesc Represents a MetadataSignature.
             * @implements IMetadataSignature
             * @constructor
             * @param {common.IMetadataSignature=} [properties] Properties to set
             */
            function MetadataSignature(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MetadataSignature signatureHeader.
             * @member {Uint8Array} signatureHeader
             * @memberof common.MetadataSignature
             * @instance
             */
            MetadataSignature.prototype.signatureHeader = $util.newBuffer([]);
    
            /**
             * MetadataSignature signature.
             * @member {Uint8Array} signature
             * @memberof common.MetadataSignature
             * @instance
             */
            MetadataSignature.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new MetadataSignature instance using the specified properties.
             * @function create
             * @memberof common.MetadataSignature
             * @static
             * @param {common.IMetadataSignature=} [properties] Properties to set
             * @returns {common.MetadataSignature} MetadataSignature instance
             */
            MetadataSignature.create = function create(properties) {
                return new MetadataSignature(properties);
            };
    
            /**
             * Encodes the specified MetadataSignature message. Does not implicitly {@link common.MetadataSignature.verify|verify} messages.
             * @function encode
             * @memberof common.MetadataSignature
             * @static
             * @param {common.IMetadataSignature} message MetadataSignature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetadataSignature.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signatureHeader != null && message.hasOwnProperty("signatureHeader"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signatureHeader);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified MetadataSignature message, length delimited. Does not implicitly {@link common.MetadataSignature.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.MetadataSignature
             * @static
             * @param {common.IMetadataSignature} message MetadataSignature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetadataSignature.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MetadataSignature message from the specified reader or buffer.
             * @function decode
             * @memberof common.MetadataSignature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.MetadataSignature} MetadataSignature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetadataSignature.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.MetadataSignature();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signatureHeader = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MetadataSignature message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.MetadataSignature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.MetadataSignature} MetadataSignature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetadataSignature.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MetadataSignature message.
             * @function verify
             * @memberof common.MetadataSignature
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MetadataSignature.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.signatureHeader != null && message.hasOwnProperty("signatureHeader"))
                    if (!(message.signatureHeader && typeof message.signatureHeader.length === "number" || $util.isString(message.signatureHeader)))
                        return "signatureHeader: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates a MetadataSignature message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.MetadataSignature
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.MetadataSignature} MetadataSignature
             */
            MetadataSignature.fromObject = function fromObject(object) {
                if (object instanceof $root.common.MetadataSignature)
                    return object;
                var message = new $root.common.MetadataSignature();
                if (object.signatureHeader != null)
                    if (typeof object.signatureHeader === "string")
                        $util.base64.decode(object.signatureHeader, message.signatureHeader = $util.newBuffer($util.base64.length(object.signatureHeader)), 0);
                    else if (object.signatureHeader.length)
                        message.signatureHeader = object.signatureHeader;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from a MetadataSignature message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.MetadataSignature
             * @static
             * @param {common.MetadataSignature} message MetadataSignature
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MetadataSignature.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.signatureHeader = "";
                    else {
                        object.signatureHeader = [];
                        if (options.bytes !== Array)
                            object.signatureHeader = $util.newBuffer(object.signatureHeader);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.signatureHeader != null && message.hasOwnProperty("signatureHeader"))
                    object.signatureHeader = options.bytes === String ? $util.base64.encode(message.signatureHeader, 0, message.signatureHeader.length) : options.bytes === Array ? Array.prototype.slice.call(message.signatureHeader) : message.signatureHeader;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this MetadataSignature to JSON.
             * @function toJSON
             * @memberof common.MetadataSignature
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MetadataSignature.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return MetadataSignature;
        })();
    
        common.Header = (function() {
    
            /**
             * Properties of a Header.
             * @memberof common
             * @interface IHeader
             * @property {Uint8Array|null} [channelHeader] Header channelHeader
             * @property {Uint8Array|null} [signatureHeader] Header signatureHeader
             */
    
            /**
             * Constructs a new Header.
             * @memberof common
             * @classdesc Represents a Header.
             * @implements IHeader
             * @constructor
             * @param {common.IHeader=} [properties] Properties to set
             */
            function Header(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Header channelHeader.
             * @member {Uint8Array} channelHeader
             * @memberof common.Header
             * @instance
             */
            Header.prototype.channelHeader = $util.newBuffer([]);
    
            /**
             * Header signatureHeader.
             * @member {Uint8Array} signatureHeader
             * @memberof common.Header
             * @instance
             */
            Header.prototype.signatureHeader = $util.newBuffer([]);
    
            /**
             * Creates a new Header instance using the specified properties.
             * @function create
             * @memberof common.Header
             * @static
             * @param {common.IHeader=} [properties] Properties to set
             * @returns {common.Header} Header instance
             */
            Header.create = function create(properties) {
                return new Header(properties);
            };
    
            /**
             * Encodes the specified Header message. Does not implicitly {@link common.Header.verify|verify} messages.
             * @function encode
             * @memberof common.Header
             * @static
             * @param {common.IHeader} message Header message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Header.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channelHeader != null && message.hasOwnProperty("channelHeader"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channelHeader);
                if (message.signatureHeader != null && message.hasOwnProperty("signatureHeader"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signatureHeader);
                return writer;
            };
    
            /**
             * Encodes the specified Header message, length delimited. Does not implicitly {@link common.Header.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Header
             * @static
             * @param {common.IHeader} message Header message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Header.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Header message from the specified reader or buffer.
             * @function decode
             * @memberof common.Header
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Header} Header
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Header.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Header();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channelHeader = reader.bytes();
                        break;
                    case 2:
                        message.signatureHeader = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Header message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Header
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Header} Header
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Header.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Header message.
             * @function verify
             * @memberof common.Header
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Header.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channelHeader != null && message.hasOwnProperty("channelHeader"))
                    if (!(message.channelHeader && typeof message.channelHeader.length === "number" || $util.isString(message.channelHeader)))
                        return "channelHeader: buffer expected";
                if (message.signatureHeader != null && message.hasOwnProperty("signatureHeader"))
                    if (!(message.signatureHeader && typeof message.signatureHeader.length === "number" || $util.isString(message.signatureHeader)))
                        return "signatureHeader: buffer expected";
                return null;
            };
    
            /**
             * Creates a Header message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Header
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Header} Header
             */
            Header.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Header)
                    return object;
                var message = new $root.common.Header();
                if (object.channelHeader != null)
                    if (typeof object.channelHeader === "string")
                        $util.base64.decode(object.channelHeader, message.channelHeader = $util.newBuffer($util.base64.length(object.channelHeader)), 0);
                    else if (object.channelHeader.length)
                        message.channelHeader = object.channelHeader;
                if (object.signatureHeader != null)
                    if (typeof object.signatureHeader === "string")
                        $util.base64.decode(object.signatureHeader, message.signatureHeader = $util.newBuffer($util.base64.length(object.signatureHeader)), 0);
                    else if (object.signatureHeader.length)
                        message.signatureHeader = object.signatureHeader;
                return message;
            };
    
            /**
             * Creates a plain object from a Header message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Header
             * @static
             * @param {common.Header} message Header
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Header.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.channelHeader = "";
                    else {
                        object.channelHeader = [];
                        if (options.bytes !== Array)
                            object.channelHeader = $util.newBuffer(object.channelHeader);
                    }
                    if (options.bytes === String)
                        object.signatureHeader = "";
                    else {
                        object.signatureHeader = [];
                        if (options.bytes !== Array)
                            object.signatureHeader = $util.newBuffer(object.signatureHeader);
                    }
                }
                if (message.channelHeader != null && message.hasOwnProperty("channelHeader"))
                    object.channelHeader = options.bytes === String ? $util.base64.encode(message.channelHeader, 0, message.channelHeader.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelHeader) : message.channelHeader;
                if (message.signatureHeader != null && message.hasOwnProperty("signatureHeader"))
                    object.signatureHeader = options.bytes === String ? $util.base64.encode(message.signatureHeader, 0, message.signatureHeader.length) : options.bytes === Array ? Array.prototype.slice.call(message.signatureHeader) : message.signatureHeader;
                return object;
            };
    
            /**
             * Converts this Header to JSON.
             * @function toJSON
             * @memberof common.Header
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Header.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Header;
        })();
    
        common.ChannelHeader = (function() {
    
            /**
             * Properties of a ChannelHeader.
             * @memberof common
             * @interface IChannelHeader
             * @property {number|null} [type] ChannelHeader type
             * @property {number|null} [version] ChannelHeader version
             * @property {google.protobuf.ITimestamp|null} [timestamp] ChannelHeader timestamp
             * @property {string|null} [channelId] ChannelHeader channelId
             * @property {string|null} [txId] ChannelHeader txId
             * @property {number|Long|null} [epoch] ChannelHeader epoch
             * @property {Uint8Array|null} [extension] ChannelHeader extension
             * @property {Uint8Array|null} [tlsCertHash] ChannelHeader tlsCertHash
             */
    
            /**
             * Constructs a new ChannelHeader.
             * @memberof common
             * @classdesc Represents a ChannelHeader.
             * @implements IChannelHeader
             * @constructor
             * @param {common.IChannelHeader=} [properties] Properties to set
             */
            function ChannelHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChannelHeader type.
             * @member {number} type
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.type = 0;
    
            /**
             * ChannelHeader version.
             * @member {number} version
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.version = 0;
    
            /**
             * ChannelHeader timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.timestamp = null;
    
            /**
             * ChannelHeader channelId.
             * @member {string} channelId
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.channelId = "";
    
            /**
             * ChannelHeader txId.
             * @member {string} txId
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.txId = "";
    
            /**
             * ChannelHeader epoch.
             * @member {number|Long} epoch
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.epoch = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * ChannelHeader extension.
             * @member {Uint8Array} extension
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.extension = $util.newBuffer([]);
    
            /**
             * ChannelHeader tlsCertHash.
             * @member {Uint8Array} tlsCertHash
             * @memberof common.ChannelHeader
             * @instance
             */
            ChannelHeader.prototype.tlsCertHash = $util.newBuffer([]);
    
            /**
             * Creates a new ChannelHeader instance using the specified properties.
             * @function create
             * @memberof common.ChannelHeader
             * @static
             * @param {common.IChannelHeader=} [properties] Properties to set
             * @returns {common.ChannelHeader} ChannelHeader instance
             */
            ChannelHeader.create = function create(properties) {
                return new ChannelHeader(properties);
            };
    
            /**
             * Encodes the specified ChannelHeader message. Does not implicitly {@link common.ChannelHeader.verify|verify} messages.
             * @function encode
             * @memberof common.ChannelHeader
             * @static
             * @param {common.IChannelHeader} message ChannelHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.version);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.channelId);
                if (message.txId != null && message.hasOwnProperty("txId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.txId);
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.epoch);
                if (message.extension != null && message.hasOwnProperty("extension"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.extension);
                if (message.tlsCertHash != null && message.hasOwnProperty("tlsCertHash"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.tlsCertHash);
                return writer;
            };
    
            /**
             * Encodes the specified ChannelHeader message, length delimited. Does not implicitly {@link common.ChannelHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ChannelHeader
             * @static
             * @param {common.IChannelHeader} message ChannelHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChannelHeader message from the specified reader or buffer.
             * @function decode
             * @memberof common.ChannelHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ChannelHeader} ChannelHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ChannelHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.version = reader.int32();
                        break;
                    case 3:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.channelId = reader.string();
                        break;
                    case 5:
                        message.txId = reader.string();
                        break;
                    case 6:
                        message.epoch = reader.uint64();
                        break;
                    case 7:
                        message.extension = reader.bytes();
                        break;
                    case 8:
                        message.tlsCertHash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChannelHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ChannelHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ChannelHeader} ChannelHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChannelHeader message.
             * @function verify
             * @memberof common.ChannelHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChannelHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (!$util.isString(message.channelId))
                        return "channelId: string expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isString(message.txId))
                        return "txId: string expected";
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    if (!$util.isInteger(message.epoch) && !(message.epoch && $util.isInteger(message.epoch.low) && $util.isInteger(message.epoch.high)))
                        return "epoch: integer|Long expected";
                if (message.extension != null && message.hasOwnProperty("extension"))
                    if (!(message.extension && typeof message.extension.length === "number" || $util.isString(message.extension)))
                        return "extension: buffer expected";
                if (message.tlsCertHash != null && message.hasOwnProperty("tlsCertHash"))
                    if (!(message.tlsCertHash && typeof message.tlsCertHash.length === "number" || $util.isString(message.tlsCertHash)))
                        return "tlsCertHash: buffer expected";
                return null;
            };
    
            /**
             * Creates a ChannelHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ChannelHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ChannelHeader} ChannelHeader
             */
            ChannelHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ChannelHeader)
                    return object;
                var message = new $root.common.ChannelHeader();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.version != null)
                    message.version = object.version | 0;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".common.ChannelHeader.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                if (object.channelId != null)
                    message.channelId = String(object.channelId);
                if (object.txId != null)
                    message.txId = String(object.txId);
                if (object.epoch != null)
                    if ($util.Long)
                        (message.epoch = $util.Long.fromValue(object.epoch)).unsigned = true;
                    else if (typeof object.epoch === "string")
                        message.epoch = parseInt(object.epoch, 10);
                    else if (typeof object.epoch === "number")
                        message.epoch = object.epoch;
                    else if (typeof object.epoch === "object")
                        message.epoch = new $util.LongBits(object.epoch.low >>> 0, object.epoch.high >>> 0).toNumber(true);
                if (object.extension != null)
                    if (typeof object.extension === "string")
                        $util.base64.decode(object.extension, message.extension = $util.newBuffer($util.base64.length(object.extension)), 0);
                    else if (object.extension.length)
                        message.extension = object.extension;
                if (object.tlsCertHash != null)
                    if (typeof object.tlsCertHash === "string")
                        $util.base64.decode(object.tlsCertHash, message.tlsCertHash = $util.newBuffer($util.base64.length(object.tlsCertHash)), 0);
                    else if (object.tlsCertHash.length)
                        message.tlsCertHash = object.tlsCertHash;
                return message;
            };
    
            /**
             * Creates a plain object from a ChannelHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ChannelHeader
             * @static
             * @param {common.ChannelHeader} message ChannelHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChannelHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.version = 0;
                    object.timestamp = null;
                    object.channelId = "";
                    object.txId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.epoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.epoch = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.extension = "";
                    else {
                        object.extension = [];
                        if (options.bytes !== Array)
                            object.extension = $util.newBuffer(object.extension);
                    }
                    if (options.bytes === String)
                        object.tlsCertHash = "";
                    else {
                        object.tlsCertHash = [];
                        if (options.bytes !== Array)
                            object.tlsCertHash = $util.newBuffer(object.tlsCertHash);
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    object.channelId = message.channelId;
                if (message.txId != null && message.hasOwnProperty("txId"))
                    object.txId = message.txId;
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    if (typeof message.epoch === "number")
                        object.epoch = options.longs === String ? String(message.epoch) : message.epoch;
                    else
                        object.epoch = options.longs === String ? $util.Long.prototype.toString.call(message.epoch) : options.longs === Number ? new $util.LongBits(message.epoch.low >>> 0, message.epoch.high >>> 0).toNumber(true) : message.epoch;
                if (message.extension != null && message.hasOwnProperty("extension"))
                    object.extension = options.bytes === String ? $util.base64.encode(message.extension, 0, message.extension.length) : options.bytes === Array ? Array.prototype.slice.call(message.extension) : message.extension;
                if (message.tlsCertHash != null && message.hasOwnProperty("tlsCertHash"))
                    object.tlsCertHash = options.bytes === String ? $util.base64.encode(message.tlsCertHash, 0, message.tlsCertHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCertHash) : message.tlsCertHash;
                return object;
            };
    
            /**
             * Converts this ChannelHeader to JSON.
             * @function toJSON
             * @memberof common.ChannelHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChannelHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChannelHeader;
        })();
    
        common.SignatureHeader = (function() {
    
            /**
             * Properties of a SignatureHeader.
             * @memberof common
             * @interface ISignatureHeader
             * @property {Uint8Array|null} [creator] SignatureHeader creator
             * @property {Uint8Array|null} [nonce] SignatureHeader nonce
             */
    
            /**
             * Constructs a new SignatureHeader.
             * @memberof common
             * @classdesc Represents a SignatureHeader.
             * @implements ISignatureHeader
             * @constructor
             * @param {common.ISignatureHeader=} [properties] Properties to set
             */
            function SignatureHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignatureHeader creator.
             * @member {Uint8Array} creator
             * @memberof common.SignatureHeader
             * @instance
             */
            SignatureHeader.prototype.creator = $util.newBuffer([]);
    
            /**
             * SignatureHeader nonce.
             * @member {Uint8Array} nonce
             * @memberof common.SignatureHeader
             * @instance
             */
            SignatureHeader.prototype.nonce = $util.newBuffer([]);
    
            /**
             * Creates a new SignatureHeader instance using the specified properties.
             * @function create
             * @memberof common.SignatureHeader
             * @static
             * @param {common.ISignatureHeader=} [properties] Properties to set
             * @returns {common.SignatureHeader} SignatureHeader instance
             */
            SignatureHeader.create = function create(properties) {
                return new SignatureHeader(properties);
            };
    
            /**
             * Encodes the specified SignatureHeader message. Does not implicitly {@link common.SignatureHeader.verify|verify} messages.
             * @function encode
             * @memberof common.SignatureHeader
             * @static
             * @param {common.ISignatureHeader} message SignatureHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignatureHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.creator != null && message.hasOwnProperty("creator"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.creator);
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nonce);
                return writer;
            };
    
            /**
             * Encodes the specified SignatureHeader message, length delimited. Does not implicitly {@link common.SignatureHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.SignatureHeader
             * @static
             * @param {common.ISignatureHeader} message SignatureHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignatureHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignatureHeader message from the specified reader or buffer.
             * @function decode
             * @memberof common.SignatureHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.SignatureHeader} SignatureHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignatureHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.SignatureHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.creator = reader.bytes();
                        break;
                    case 2:
                        message.nonce = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignatureHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.SignatureHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.SignatureHeader} SignatureHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignatureHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignatureHeader message.
             * @function verify
             * @memberof common.SignatureHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignatureHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.creator != null && message.hasOwnProperty("creator"))
                    if (!(message.creator && typeof message.creator.length === "number" || $util.isString(message.creator)))
                        return "creator: buffer expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                        return "nonce: buffer expected";
                return null;
            };
    
            /**
             * Creates a SignatureHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.SignatureHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.SignatureHeader} SignatureHeader
             */
            SignatureHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.common.SignatureHeader)
                    return object;
                var message = new $root.common.SignatureHeader();
                if (object.creator != null)
                    if (typeof object.creator === "string")
                        $util.base64.decode(object.creator, message.creator = $util.newBuffer($util.base64.length(object.creator)), 0);
                    else if (object.creator.length)
                        message.creator = object.creator;
                if (object.nonce != null)
                    if (typeof object.nonce === "string")
                        $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                    else if (object.nonce.length)
                        message.nonce = object.nonce;
                return message;
            };
    
            /**
             * Creates a plain object from a SignatureHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.SignatureHeader
             * @static
             * @param {common.SignatureHeader} message SignatureHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignatureHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.creator = "";
                    else {
                        object.creator = [];
                        if (options.bytes !== Array)
                            object.creator = $util.newBuffer(object.creator);
                    }
                    if (options.bytes === String)
                        object.nonce = "";
                    else {
                        object.nonce = [];
                        if (options.bytes !== Array)
                            object.nonce = $util.newBuffer(object.nonce);
                    }
                }
                if (message.creator != null && message.hasOwnProperty("creator"))
                    object.creator = options.bytes === String ? $util.base64.encode(message.creator, 0, message.creator.length) : options.bytes === Array ? Array.prototype.slice.call(message.creator) : message.creator;
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                return object;
            };
    
            /**
             * Converts this SignatureHeader to JSON.
             * @function toJSON
             * @memberof common.SignatureHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignatureHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignatureHeader;
        })();
    
        common.Payload = (function() {
    
            /**
             * Properties of a Payload.
             * @memberof common
             * @interface IPayload
             * @property {common.IHeader|null} [header] Payload header
             * @property {Uint8Array|null} [data] Payload data
             */
    
            /**
             * Constructs a new Payload.
             * @memberof common
             * @classdesc Represents a Payload.
             * @implements IPayload
             * @constructor
             * @param {common.IPayload=} [properties] Properties to set
             */
            function Payload(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Payload header.
             * @member {common.IHeader|null|undefined} header
             * @memberof common.Payload
             * @instance
             */
            Payload.prototype.header = null;
    
            /**
             * Payload data.
             * @member {Uint8Array} data
             * @memberof common.Payload
             * @instance
             */
            Payload.prototype.data = $util.newBuffer([]);
    
            /**
             * Creates a new Payload instance using the specified properties.
             * @function create
             * @memberof common.Payload
             * @static
             * @param {common.IPayload=} [properties] Properties to set
             * @returns {common.Payload} Payload instance
             */
            Payload.create = function create(properties) {
                return new Payload(properties);
            };
    
            /**
             * Encodes the specified Payload message. Does not implicitly {@link common.Payload.verify|verify} messages.
             * @function encode
             * @memberof common.Payload
             * @static
             * @param {common.IPayload} message Payload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.header != null && message.hasOwnProperty("header"))
                    $root.common.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.data != null && message.hasOwnProperty("data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                return writer;
            };
    
            /**
             * Encodes the specified Payload message, length delimited. Does not implicitly {@link common.Payload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Payload
             * @static
             * @param {common.IPayload} message Payload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Payload message from the specified reader or buffer.
             * @function decode
             * @memberof common.Payload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Payload} Payload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Payload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.header = $root.common.Header.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Payload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Payload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Payload} Payload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Payload message.
             * @function verify
             * @memberof common.Payload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Payload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.header != null && message.hasOwnProperty("header")) {
                    var error = $root.common.Header.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };
    
            /**
             * Creates a Payload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Payload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Payload} Payload
             */
            Payload.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Payload)
                    return object;
                var message = new $root.common.Payload();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".common.Payload.header: object expected");
                    message.header = $root.common.Header.fromObject(object.header);
                }
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                return message;
            };
    
            /**
             * Creates a plain object from a Payload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Payload
             * @static
             * @param {common.Payload} message Payload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Payload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.header = null;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.Header.toObject(message.header, options);
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };
    
            /**
             * Converts this Payload to JSON.
             * @function toJSON
             * @memberof common.Payload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Payload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Payload;
        })();
    
        common.Envelope = (function() {
    
            /**
             * Properties of an Envelope.
             * @memberof common
             * @interface IEnvelope
             * @property {Uint8Array|null} [payload] Envelope payload
             * @property {Uint8Array|null} [signature] Envelope signature
             */
    
            /**
             * Constructs a new Envelope.
             * @memberof common
             * @classdesc Represents an Envelope.
             * @implements IEnvelope
             * @constructor
             * @param {common.IEnvelope=} [properties] Properties to set
             */
            function Envelope(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Envelope payload.
             * @member {Uint8Array} payload
             * @memberof common.Envelope
             * @instance
             */
            Envelope.prototype.payload = $util.newBuffer([]);
    
            /**
             * Envelope signature.
             * @member {Uint8Array} signature
             * @memberof common.Envelope
             * @instance
             */
            Envelope.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new Envelope instance using the specified properties.
             * @function create
             * @memberof common.Envelope
             * @static
             * @param {common.IEnvelope=} [properties] Properties to set
             * @returns {common.Envelope} Envelope instance
             */
            Envelope.create = function create(properties) {
                return new Envelope(properties);
            };
    
            /**
             * Encodes the specified Envelope message. Does not implicitly {@link common.Envelope.verify|verify} messages.
             * @function encode
             * @memberof common.Envelope
             * @static
             * @param {common.IEnvelope} message Envelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Envelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified Envelope message, length delimited. Does not implicitly {@link common.Envelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Envelope
             * @static
             * @param {common.IEnvelope} message Envelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Envelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Envelope message from the specified reader or buffer.
             * @function decode
             * @memberof common.Envelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Envelope} Envelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Envelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Envelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Envelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Envelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Envelope} Envelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Envelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Envelope message.
             * @function verify
             * @memberof common.Envelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Envelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates an Envelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Envelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Envelope} Envelope
             */
            Envelope.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Envelope)
                    return object;
                var message = new $root.common.Envelope();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from an Envelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Envelope
             * @static
             * @param {common.Envelope} message Envelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Envelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this Envelope to JSON.
             * @function toJSON
             * @memberof common.Envelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Envelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Envelope;
        })();
    
        common.Block = (function() {
    
            /**
             * Properties of a Block.
             * @memberof common
             * @interface IBlock
             * @property {common.IBlockHeader|null} [header] Block header
             * @property {common.IBlockData|null} [data] Block data
             * @property {common.IBlockMetadata|null} [metadata] Block metadata
             */
    
            /**
             * Constructs a new Block.
             * @memberof common
             * @classdesc Represents a Block.
             * @implements IBlock
             * @constructor
             * @param {common.IBlock=} [properties] Properties to set
             */
            function Block(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Block header.
             * @member {common.IBlockHeader|null|undefined} header
             * @memberof common.Block
             * @instance
             */
            Block.prototype.header = null;
    
            /**
             * Block data.
             * @member {common.IBlockData|null|undefined} data
             * @memberof common.Block
             * @instance
             */
            Block.prototype.data = null;
    
            /**
             * Block metadata.
             * @member {common.IBlockMetadata|null|undefined} metadata
             * @memberof common.Block
             * @instance
             */
            Block.prototype.metadata = null;
    
            /**
             * Creates a new Block instance using the specified properties.
             * @function create
             * @memberof common.Block
             * @static
             * @param {common.IBlock=} [properties] Properties to set
             * @returns {common.Block} Block instance
             */
            Block.create = function create(properties) {
                return new Block(properties);
            };
    
            /**
             * Encodes the specified Block message. Does not implicitly {@link common.Block.verify|verify} messages.
             * @function encode
             * @memberof common.Block
             * @static
             * @param {common.IBlock} message Block message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Block.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.header != null && message.hasOwnProperty("header"))
                    $root.common.BlockHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.data != null && message.hasOwnProperty("data"))
                    $root.common.BlockData.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.common.BlockMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Block message, length delimited. Does not implicitly {@link common.Block.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Block
             * @static
             * @param {common.IBlock} message Block message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Block.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Block message from the specified reader or buffer.
             * @function decode
             * @memberof common.Block
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Block} Block
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Block.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Block();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.header = $root.common.BlockHeader.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.data = $root.common.BlockData.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.metadata = $root.common.BlockMetadata.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Block message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Block
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Block} Block
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Block.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Block message.
             * @function verify
             * @memberof common.Block
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Block.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.header != null && message.hasOwnProperty("header")) {
                    var error = $root.common.BlockHeader.verify(message.header);
                    if (error)
                        return "header." + error;
                }
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.common.BlockData.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    var error = $root.common.BlockMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };
    
            /**
             * Creates a Block message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Block
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Block} Block
             */
            Block.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Block)
                    return object;
                var message = new $root.common.Block();
                if (object.header != null) {
                    if (typeof object.header !== "object")
                        throw TypeError(".common.Block.header: object expected");
                    message.header = $root.common.BlockHeader.fromObject(object.header);
                }
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".common.Block.data: object expected");
                    message.data = $root.common.BlockData.fromObject(object.data);
                }
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".common.Block.metadata: object expected");
                    message.metadata = $root.common.BlockMetadata.fromObject(object.metadata);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Block message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Block
             * @static
             * @param {common.Block} message Block
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Block.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.header = null;
                    object.data = null;
                    object.metadata = null;
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = $root.common.BlockHeader.toObject(message.header, options);
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.common.BlockData.toObject(message.data, options);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.common.BlockMetadata.toObject(message.metadata, options);
                return object;
            };
    
            /**
             * Converts this Block to JSON.
             * @function toJSON
             * @memberof common.Block
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Block.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Block;
        })();
    
        common.BlockHeader = (function() {
    
            /**
             * Properties of a BlockHeader.
             * @memberof common
             * @interface IBlockHeader
             * @property {number|Long|null} [number] BlockHeader number
             * @property {Uint8Array|null} [previousHash] BlockHeader previousHash
             * @property {Uint8Array|null} [dataHash] BlockHeader dataHash
             */
    
            /**
             * Constructs a new BlockHeader.
             * @memberof common
             * @classdesc Represents a BlockHeader.
             * @implements IBlockHeader
             * @constructor
             * @param {common.IBlockHeader=} [properties] Properties to set
             */
            function BlockHeader(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockHeader number.
             * @member {number|Long} number
             * @memberof common.BlockHeader
             * @instance
             */
            BlockHeader.prototype.number = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * BlockHeader previousHash.
             * @member {Uint8Array} previousHash
             * @memberof common.BlockHeader
             * @instance
             */
            BlockHeader.prototype.previousHash = $util.newBuffer([]);
    
            /**
             * BlockHeader dataHash.
             * @member {Uint8Array} dataHash
             * @memberof common.BlockHeader
             * @instance
             */
            BlockHeader.prototype.dataHash = $util.newBuffer([]);
    
            /**
             * Creates a new BlockHeader instance using the specified properties.
             * @function create
             * @memberof common.BlockHeader
             * @static
             * @param {common.IBlockHeader=} [properties] Properties to set
             * @returns {common.BlockHeader} BlockHeader instance
             */
            BlockHeader.create = function create(properties) {
                return new BlockHeader(properties);
            };
    
            /**
             * Encodes the specified BlockHeader message. Does not implicitly {@link common.BlockHeader.verify|verify} messages.
             * @function encode
             * @memberof common.BlockHeader
             * @static
             * @param {common.IBlockHeader} message BlockHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.number);
                if (message.previousHash != null && message.hasOwnProperty("previousHash"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.previousHash);
                if (message.dataHash != null && message.hasOwnProperty("dataHash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.dataHash);
                return writer;
            };
    
            /**
             * Encodes the specified BlockHeader message, length delimited. Does not implicitly {@link common.BlockHeader.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.BlockHeader
             * @static
             * @param {common.IBlockHeader} message BlockHeader message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockHeader.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockHeader message from the specified reader or buffer.
             * @function decode
             * @memberof common.BlockHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.BlockHeader} BlockHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.BlockHeader();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.number = reader.uint64();
                        break;
                    case 2:
                        message.previousHash = reader.bytes();
                        break;
                    case 3:
                        message.dataHash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockHeader message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.BlockHeader
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.BlockHeader} BlockHeader
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockHeader.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockHeader message.
             * @function verify
             * @memberof common.BlockHeader
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockHeader.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                if (message.previousHash != null && message.hasOwnProperty("previousHash"))
                    if (!(message.previousHash && typeof message.previousHash.length === "number" || $util.isString(message.previousHash)))
                        return "previousHash: buffer expected";
                if (message.dataHash != null && message.hasOwnProperty("dataHash"))
                    if (!(message.dataHash && typeof message.dataHash.length === "number" || $util.isString(message.dataHash)))
                        return "dataHash: buffer expected";
                return null;
            };
    
            /**
             * Creates a BlockHeader message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.BlockHeader
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.BlockHeader} BlockHeader
             */
            BlockHeader.fromObject = function fromObject(object) {
                if (object instanceof $root.common.BlockHeader)
                    return object;
                var message = new $root.common.BlockHeader();
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = true;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber(true);
                if (object.previousHash != null)
                    if (typeof object.previousHash === "string")
                        $util.base64.decode(object.previousHash, message.previousHash = $util.newBuffer($util.base64.length(object.previousHash)), 0);
                    else if (object.previousHash.length)
                        message.previousHash = object.previousHash;
                if (object.dataHash != null)
                    if (typeof object.dataHash === "string")
                        $util.base64.decode(object.dataHash, message.dataHash = $util.newBuffer($util.base64.length(object.dataHash)), 0);
                    else if (object.dataHash.length)
                        message.dataHash = object.dataHash;
                return message;
            };
    
            /**
             * Creates a plain object from a BlockHeader message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.BlockHeader
             * @static
             * @param {common.BlockHeader} message BlockHeader
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockHeader.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.previousHash = "";
                    else {
                        object.previousHash = [];
                        if (options.bytes !== Array)
                            object.previousHash = $util.newBuffer(object.previousHash);
                    }
                    if (options.bytes === String)
                        object.dataHash = "";
                    else {
                        object.dataHash = [];
                        if (options.bytes !== Array)
                            object.dataHash = $util.newBuffer(object.dataHash);
                    }
                }
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber(true) : message.number;
                if (message.previousHash != null && message.hasOwnProperty("previousHash"))
                    object.previousHash = options.bytes === String ? $util.base64.encode(message.previousHash, 0, message.previousHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.previousHash) : message.previousHash;
                if (message.dataHash != null && message.hasOwnProperty("dataHash"))
                    object.dataHash = options.bytes === String ? $util.base64.encode(message.dataHash, 0, message.dataHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.dataHash) : message.dataHash;
                return object;
            };
    
            /**
             * Converts this BlockHeader to JSON.
             * @function toJSON
             * @memberof common.BlockHeader
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockHeader.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockHeader;
        })();
    
        common.BlockData = (function() {
    
            /**
             * Properties of a BlockData.
             * @memberof common
             * @interface IBlockData
             * @property {Array.<Uint8Array>|null} [data] BlockData data
             */
    
            /**
             * Constructs a new BlockData.
             * @memberof common
             * @classdesc Represents a BlockData.
             * @implements IBlockData
             * @constructor
             * @param {common.IBlockData=} [properties] Properties to set
             */
            function BlockData(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockData data.
             * @member {Array.<Uint8Array>} data
             * @memberof common.BlockData
             * @instance
             */
            BlockData.prototype.data = $util.emptyArray;
    
            /**
             * Creates a new BlockData instance using the specified properties.
             * @function create
             * @memberof common.BlockData
             * @static
             * @param {common.IBlockData=} [properties] Properties to set
             * @returns {common.BlockData} BlockData instance
             */
            BlockData.create = function create(properties) {
                return new BlockData(properties);
            };
    
            /**
             * Encodes the specified BlockData message. Does not implicitly {@link common.BlockData.verify|verify} messages.
             * @function encode
             * @memberof common.BlockData
             * @static
             * @param {common.IBlockData} message BlockData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && message.data.length)
                    for (var i = 0; i < message.data.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data[i]);
                return writer;
            };
    
            /**
             * Encodes the specified BlockData message, length delimited. Does not implicitly {@link common.BlockData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.BlockData
             * @static
             * @param {common.IBlockData} message BlockData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockData message from the specified reader or buffer.
             * @function decode
             * @memberof common.BlockData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.BlockData} BlockData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.BlockData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.data && message.data.length))
                            message.data = [];
                        message.data.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.BlockData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.BlockData} BlockData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockData message.
             * @function verify
             * @memberof common.BlockData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i)
                        if (!(message.data[i] && typeof message.data[i].length === "number" || $util.isString(message.data[i])))
                            return "data: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a BlockData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.BlockData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.BlockData} BlockData
             */
            BlockData.fromObject = function fromObject(object) {
                if (object instanceof $root.common.BlockData)
                    return object;
                var message = new $root.common.BlockData();
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".common.BlockData.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i)
                        if (typeof object.data[i] === "string")
                            $util.base64.decode(object.data[i], message.data[i] = $util.newBuffer($util.base64.length(object.data[i])), 0);
                        else if (object.data[i].length)
                            message.data[i] = object.data[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a BlockData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.BlockData
             * @static
             * @param {common.BlockData} message BlockData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = options.bytes === String ? $util.base64.encode(message.data[j], 0, message.data[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.data[j]) : message.data[j];
                }
                return object;
            };
    
            /**
             * Converts this BlockData to JSON.
             * @function toJSON
             * @memberof common.BlockData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockData;
        })();
    
        common.BlockMetadata = (function() {
    
            /**
             * Properties of a BlockMetadata.
             * @memberof common
             * @interface IBlockMetadata
             * @property {Array.<Uint8Array>|null} [metadata] BlockMetadata metadata
             */
    
            /**
             * Constructs a new BlockMetadata.
             * @memberof common
             * @classdesc Represents a BlockMetadata.
             * @implements IBlockMetadata
             * @constructor
             * @param {common.IBlockMetadata=} [properties] Properties to set
             */
            function BlockMetadata(properties) {
                this.metadata = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockMetadata metadata.
             * @member {Array.<Uint8Array>} metadata
             * @memberof common.BlockMetadata
             * @instance
             */
            BlockMetadata.prototype.metadata = $util.emptyArray;
    
            /**
             * Creates a new BlockMetadata instance using the specified properties.
             * @function create
             * @memberof common.BlockMetadata
             * @static
             * @param {common.IBlockMetadata=} [properties] Properties to set
             * @returns {common.BlockMetadata} BlockMetadata instance
             */
            BlockMetadata.create = function create(properties) {
                return new BlockMetadata(properties);
            };
    
            /**
             * Encodes the specified BlockMetadata message. Does not implicitly {@link common.BlockMetadata.verify|verify} messages.
             * @function encode
             * @memberof common.BlockMetadata
             * @static
             * @param {common.IBlockMetadata} message BlockMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metadata != null && message.metadata.length)
                    for (var i = 0; i < message.metadata.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.metadata[i]);
                return writer;
            };
    
            /**
             * Encodes the specified BlockMetadata message, length delimited. Does not implicitly {@link common.BlockMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.BlockMetadata
             * @static
             * @param {common.IBlockMetadata} message BlockMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof common.BlockMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.BlockMetadata} BlockMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.BlockMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.metadata && message.metadata.length))
                            message.metadata = [];
                        message.metadata.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.BlockMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.BlockMetadata} BlockMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockMetadata message.
             * @function verify
             * @memberof common.BlockMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    if (!Array.isArray(message.metadata))
                        return "metadata: array expected";
                    for (var i = 0; i < message.metadata.length; ++i)
                        if (!(message.metadata[i] && typeof message.metadata[i].length === "number" || $util.isString(message.metadata[i])))
                            return "metadata: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a BlockMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.BlockMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.BlockMetadata} BlockMetadata
             */
            BlockMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.common.BlockMetadata)
                    return object;
                var message = new $root.common.BlockMetadata();
                if (object.metadata) {
                    if (!Array.isArray(object.metadata))
                        throw TypeError(".common.BlockMetadata.metadata: array expected");
                    message.metadata = [];
                    for (var i = 0; i < object.metadata.length; ++i)
                        if (typeof object.metadata[i] === "string")
                            $util.base64.decode(object.metadata[i], message.metadata[i] = $util.newBuffer($util.base64.length(object.metadata[i])), 0);
                        else if (object.metadata[i].length)
                            message.metadata[i] = object.metadata[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a BlockMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.BlockMetadata
             * @static
             * @param {common.BlockMetadata} message BlockMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.metadata = [];
                if (message.metadata && message.metadata.length) {
                    object.metadata = [];
                    for (var j = 0; j < message.metadata.length; ++j)
                        object.metadata[j] = options.bytes === String ? $util.base64.encode(message.metadata[j], 0, message.metadata[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata[j]) : message.metadata[j];
                }
                return object;
            };
    
            /**
             * Converts this BlockMetadata to JSON.
             * @function toJSON
             * @memberof common.BlockMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockMetadata;
        })();
    
        common.OrdererBlockMetadata = (function() {
    
            /**
             * Properties of an OrdererBlockMetadata.
             * @memberof common
             * @interface IOrdererBlockMetadata
             * @property {common.ILastConfig|null} [lastConfig] OrdererBlockMetadata lastConfig
             * @property {Uint8Array|null} [consenterMetadata] OrdererBlockMetadata consenterMetadata
             */
    
            /**
             * Constructs a new OrdererBlockMetadata.
             * @memberof common
             * @classdesc Represents an OrdererBlockMetadata.
             * @implements IOrdererBlockMetadata
             * @constructor
             * @param {common.IOrdererBlockMetadata=} [properties] Properties to set
             */
            function OrdererBlockMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OrdererBlockMetadata lastConfig.
             * @member {common.ILastConfig|null|undefined} lastConfig
             * @memberof common.OrdererBlockMetadata
             * @instance
             */
            OrdererBlockMetadata.prototype.lastConfig = null;
    
            /**
             * OrdererBlockMetadata consenterMetadata.
             * @member {Uint8Array} consenterMetadata
             * @memberof common.OrdererBlockMetadata
             * @instance
             */
            OrdererBlockMetadata.prototype.consenterMetadata = $util.newBuffer([]);
    
            /**
             * Creates a new OrdererBlockMetadata instance using the specified properties.
             * @function create
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {common.IOrdererBlockMetadata=} [properties] Properties to set
             * @returns {common.OrdererBlockMetadata} OrdererBlockMetadata instance
             */
            OrdererBlockMetadata.create = function create(properties) {
                return new OrdererBlockMetadata(properties);
            };
    
            /**
             * Encodes the specified OrdererBlockMetadata message. Does not implicitly {@link common.OrdererBlockMetadata.verify|verify} messages.
             * @function encode
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {common.IOrdererBlockMetadata} message OrdererBlockMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrdererBlockMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lastConfig != null && message.hasOwnProperty("lastConfig"))
                    $root.common.LastConfig.encode(message.lastConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.consenterMetadata != null && message.hasOwnProperty("consenterMetadata"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.consenterMetadata);
                return writer;
            };
    
            /**
             * Encodes the specified OrdererBlockMetadata message, length delimited. Does not implicitly {@link common.OrdererBlockMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {common.IOrdererBlockMetadata} message OrdererBlockMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrdererBlockMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an OrdererBlockMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.OrdererBlockMetadata} OrdererBlockMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrdererBlockMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.OrdererBlockMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lastConfig = $root.common.LastConfig.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.consenterMetadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an OrdererBlockMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.OrdererBlockMetadata} OrdererBlockMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrdererBlockMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an OrdererBlockMetadata message.
             * @function verify
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrdererBlockMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lastConfig != null && message.hasOwnProperty("lastConfig")) {
                    var error = $root.common.LastConfig.verify(message.lastConfig);
                    if (error)
                        return "lastConfig." + error;
                }
                if (message.consenterMetadata != null && message.hasOwnProperty("consenterMetadata"))
                    if (!(message.consenterMetadata && typeof message.consenterMetadata.length === "number" || $util.isString(message.consenterMetadata)))
                        return "consenterMetadata: buffer expected";
                return null;
            };
    
            /**
             * Creates an OrdererBlockMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.OrdererBlockMetadata} OrdererBlockMetadata
             */
            OrdererBlockMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.common.OrdererBlockMetadata)
                    return object;
                var message = new $root.common.OrdererBlockMetadata();
                if (object.lastConfig != null) {
                    if (typeof object.lastConfig !== "object")
                        throw TypeError(".common.OrdererBlockMetadata.lastConfig: object expected");
                    message.lastConfig = $root.common.LastConfig.fromObject(object.lastConfig);
                }
                if (object.consenterMetadata != null)
                    if (typeof object.consenterMetadata === "string")
                        $util.base64.decode(object.consenterMetadata, message.consenterMetadata = $util.newBuffer($util.base64.length(object.consenterMetadata)), 0);
                    else if (object.consenterMetadata.length)
                        message.consenterMetadata = object.consenterMetadata;
                return message;
            };
    
            /**
             * Creates a plain object from an OrdererBlockMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.OrdererBlockMetadata
             * @static
             * @param {common.OrdererBlockMetadata} message OrdererBlockMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrdererBlockMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.lastConfig = null;
                    if (options.bytes === String)
                        object.consenterMetadata = "";
                    else {
                        object.consenterMetadata = [];
                        if (options.bytes !== Array)
                            object.consenterMetadata = $util.newBuffer(object.consenterMetadata);
                    }
                }
                if (message.lastConfig != null && message.hasOwnProperty("lastConfig"))
                    object.lastConfig = $root.common.LastConfig.toObject(message.lastConfig, options);
                if (message.consenterMetadata != null && message.hasOwnProperty("consenterMetadata"))
                    object.consenterMetadata = options.bytes === String ? $util.base64.encode(message.consenterMetadata, 0, message.consenterMetadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.consenterMetadata) : message.consenterMetadata;
                return object;
            };
    
            /**
             * Converts this OrdererBlockMetadata to JSON.
             * @function toJSON
             * @memberof common.OrdererBlockMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrdererBlockMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OrdererBlockMetadata;
        })();
    
        common.ConfigEnvelope = (function() {
    
            /**
             * Properties of a ConfigEnvelope.
             * @memberof common
             * @interface IConfigEnvelope
             * @property {common.IConfig|null} [config] ConfigEnvelope config
             * @property {common.IEnvelope|null} [lastUpdate] ConfigEnvelope lastUpdate
             */
    
            /**
             * Constructs a new ConfigEnvelope.
             * @memberof common
             * @classdesc Represents a ConfigEnvelope.
             * @implements IConfigEnvelope
             * @constructor
             * @param {common.IConfigEnvelope=} [properties] Properties to set
             */
            function ConfigEnvelope(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigEnvelope config.
             * @member {common.IConfig|null|undefined} config
             * @memberof common.ConfigEnvelope
             * @instance
             */
            ConfigEnvelope.prototype.config = null;
    
            /**
             * ConfigEnvelope lastUpdate.
             * @member {common.IEnvelope|null|undefined} lastUpdate
             * @memberof common.ConfigEnvelope
             * @instance
             */
            ConfigEnvelope.prototype.lastUpdate = null;
    
            /**
             * Creates a new ConfigEnvelope instance using the specified properties.
             * @function create
             * @memberof common.ConfigEnvelope
             * @static
             * @param {common.IConfigEnvelope=} [properties] Properties to set
             * @returns {common.ConfigEnvelope} ConfigEnvelope instance
             */
            ConfigEnvelope.create = function create(properties) {
                return new ConfigEnvelope(properties);
            };
    
            /**
             * Encodes the specified ConfigEnvelope message. Does not implicitly {@link common.ConfigEnvelope.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigEnvelope
             * @static
             * @param {common.IConfigEnvelope} message ConfigEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigEnvelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.config != null && message.hasOwnProperty("config"))
                    $root.common.Config.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                    $root.common.Envelope.encode(message.lastUpdate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigEnvelope message, length delimited. Does not implicitly {@link common.ConfigEnvelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigEnvelope
             * @static
             * @param {common.IConfigEnvelope} message ConfigEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigEnvelope message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigEnvelope} ConfigEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigEnvelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigEnvelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.config = $root.common.Config.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.lastUpdate = $root.common.Envelope.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigEnvelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigEnvelope} ConfigEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigEnvelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigEnvelope message.
             * @function verify
             * @memberof common.ConfigEnvelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigEnvelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.config != null && message.hasOwnProperty("config")) {
                    var error = $root.common.Config.verify(message.config);
                    if (error)
                        return "config." + error;
                }
                if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate")) {
                    var error = $root.common.Envelope.verify(message.lastUpdate);
                    if (error)
                        return "lastUpdate." + error;
                }
                return null;
            };
    
            /**
             * Creates a ConfigEnvelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigEnvelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigEnvelope} ConfigEnvelope
             */
            ConfigEnvelope.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigEnvelope)
                    return object;
                var message = new $root.common.ConfigEnvelope();
                if (object.config != null) {
                    if (typeof object.config !== "object")
                        throw TypeError(".common.ConfigEnvelope.config: object expected");
                    message.config = $root.common.Config.fromObject(object.config);
                }
                if (object.lastUpdate != null) {
                    if (typeof object.lastUpdate !== "object")
                        throw TypeError(".common.ConfigEnvelope.lastUpdate: object expected");
                    message.lastUpdate = $root.common.Envelope.fromObject(object.lastUpdate);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigEnvelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigEnvelope
             * @static
             * @param {common.ConfigEnvelope} message ConfigEnvelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigEnvelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.config = null;
                    object.lastUpdate = null;
                }
                if (message.config != null && message.hasOwnProperty("config"))
                    object.config = $root.common.Config.toObject(message.config, options);
                if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                    object.lastUpdate = $root.common.Envelope.toObject(message.lastUpdate, options);
                return object;
            };
    
            /**
             * Converts this ConfigEnvelope to JSON.
             * @function toJSON
             * @memberof common.ConfigEnvelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigEnvelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigEnvelope;
        })();
    
        common.ConfigGroupSchema = (function() {
    
            /**
             * Properties of a ConfigGroupSchema.
             * @memberof common
             * @interface IConfigGroupSchema
             * @property {Object.<string,common.IConfigGroupSchema>|null} [groups] ConfigGroupSchema groups
             * @property {Object.<string,common.IConfigValueSchema>|null} [values] ConfigGroupSchema values
             * @property {Object.<string,common.IConfigPolicySchema>|null} [policies] ConfigGroupSchema policies
             */
    
            /**
             * Constructs a new ConfigGroupSchema.
             * @memberof common
             * @classdesc Represents a ConfigGroupSchema.
             * @implements IConfigGroupSchema
             * @constructor
             * @param {common.IConfigGroupSchema=} [properties] Properties to set
             */
            function ConfigGroupSchema(properties) {
                this.groups = {};
                this.values = {};
                this.policies = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigGroupSchema groups.
             * @member {Object.<string,common.IConfigGroupSchema>} groups
             * @memberof common.ConfigGroupSchema
             * @instance
             */
            ConfigGroupSchema.prototype.groups = $util.emptyObject;
    
            /**
             * ConfigGroupSchema values.
             * @member {Object.<string,common.IConfigValueSchema>} values
             * @memberof common.ConfigGroupSchema
             * @instance
             */
            ConfigGroupSchema.prototype.values = $util.emptyObject;
    
            /**
             * ConfigGroupSchema policies.
             * @member {Object.<string,common.IConfigPolicySchema>} policies
             * @memberof common.ConfigGroupSchema
             * @instance
             */
            ConfigGroupSchema.prototype.policies = $util.emptyObject;
    
            /**
             * Creates a new ConfigGroupSchema instance using the specified properties.
             * @function create
             * @memberof common.ConfigGroupSchema
             * @static
             * @param {common.IConfigGroupSchema=} [properties] Properties to set
             * @returns {common.ConfigGroupSchema} ConfigGroupSchema instance
             */
            ConfigGroupSchema.create = function create(properties) {
                return new ConfigGroupSchema(properties);
            };
    
            /**
             * Encodes the specified ConfigGroupSchema message. Does not implicitly {@link common.ConfigGroupSchema.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigGroupSchema
             * @static
             * @param {common.IConfigGroupSchema} message ConfigGroupSchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigGroupSchema.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groups != null && message.hasOwnProperty("groups"))
                    for (var keys = Object.keys(message.groups), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.common.ConfigGroupSchema.encode(message.groups[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.values != null && message.hasOwnProperty("values"))
                    for (var keys = Object.keys(message.values), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.common.ConfigValueSchema.encode(message.values[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.policies != null && message.hasOwnProperty("policies"))
                    for (var keys = Object.keys(message.policies), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.common.ConfigPolicySchema.encode(message.policies[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified ConfigGroupSchema message, length delimited. Does not implicitly {@link common.ConfigGroupSchema.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigGroupSchema
             * @static
             * @param {common.IConfigGroupSchema} message ConfigGroupSchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigGroupSchema.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigGroupSchema message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigGroupSchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigGroupSchema} ConfigGroupSchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigGroupSchema.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigGroupSchema(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.groups === $util.emptyObject)
                            message.groups = {};
                        key = reader.string();
                        reader.pos++;
                        message.groups[key] = $root.common.ConfigGroupSchema.decode(reader, reader.uint32());
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.values === $util.emptyObject)
                            message.values = {};
                        key = reader.string();
                        reader.pos++;
                        message.values[key] = $root.common.ConfigValueSchema.decode(reader, reader.uint32());
                        break;
                    case 3:
                        reader.skip().pos++;
                        if (message.policies === $util.emptyObject)
                            message.policies = {};
                        key = reader.string();
                        reader.pos++;
                        message.policies[key] = $root.common.ConfigPolicySchema.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigGroupSchema message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigGroupSchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigGroupSchema} ConfigGroupSchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigGroupSchema.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigGroupSchema message.
             * @function verify
             * @memberof common.ConfigGroupSchema
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigGroupSchema.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groups != null && message.hasOwnProperty("groups")) {
                    if (!$util.isObject(message.groups))
                        return "groups: object expected";
                    var key = Object.keys(message.groups);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.common.ConfigGroupSchema.verify(message.groups[key[i]]);
                        if (error)
                            return "groups." + error;
                    }
                }
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!$util.isObject(message.values))
                        return "values: object expected";
                    var key = Object.keys(message.values);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.common.ConfigValueSchema.verify(message.values[key[i]]);
                        if (error)
                            return "values." + error;
                    }
                }
                if (message.policies != null && message.hasOwnProperty("policies")) {
                    if (!$util.isObject(message.policies))
                        return "policies: object expected";
                    var key = Object.keys(message.policies);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.common.ConfigPolicySchema.verify(message.policies[key[i]]);
                        if (error)
                            return "policies." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ConfigGroupSchema message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigGroupSchema
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigGroupSchema} ConfigGroupSchema
             */
            ConfigGroupSchema.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigGroupSchema)
                    return object;
                var message = new $root.common.ConfigGroupSchema();
                if (object.groups) {
                    if (typeof object.groups !== "object")
                        throw TypeError(".common.ConfigGroupSchema.groups: object expected");
                    message.groups = {};
                    for (var keys = Object.keys(object.groups), i = 0; i < keys.length; ++i) {
                        if (typeof object.groups[keys[i]] !== "object")
                            throw TypeError(".common.ConfigGroupSchema.groups: object expected");
                        message.groups[keys[i]] = $root.common.ConfigGroupSchema.fromObject(object.groups[keys[i]]);
                    }
                }
                if (object.values) {
                    if (typeof object.values !== "object")
                        throw TypeError(".common.ConfigGroupSchema.values: object expected");
                    message.values = {};
                    for (var keys = Object.keys(object.values), i = 0; i < keys.length; ++i) {
                        if (typeof object.values[keys[i]] !== "object")
                            throw TypeError(".common.ConfigGroupSchema.values: object expected");
                        message.values[keys[i]] = $root.common.ConfigValueSchema.fromObject(object.values[keys[i]]);
                    }
                }
                if (object.policies) {
                    if (typeof object.policies !== "object")
                        throw TypeError(".common.ConfigGroupSchema.policies: object expected");
                    message.policies = {};
                    for (var keys = Object.keys(object.policies), i = 0; i < keys.length; ++i) {
                        if (typeof object.policies[keys[i]] !== "object")
                            throw TypeError(".common.ConfigGroupSchema.policies: object expected");
                        message.policies[keys[i]] = $root.common.ConfigPolicySchema.fromObject(object.policies[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigGroupSchema message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigGroupSchema
             * @static
             * @param {common.ConfigGroupSchema} message ConfigGroupSchema
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigGroupSchema.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults) {
                    object.groups = {};
                    object.values = {};
                    object.policies = {};
                }
                var keys2;
                if (message.groups && (keys2 = Object.keys(message.groups)).length) {
                    object.groups = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.groups[keys2[j]] = $root.common.ConfigGroupSchema.toObject(message.groups[keys2[j]], options);
                }
                if (message.values && (keys2 = Object.keys(message.values)).length) {
                    object.values = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.values[keys2[j]] = $root.common.ConfigValueSchema.toObject(message.values[keys2[j]], options);
                }
                if (message.policies && (keys2 = Object.keys(message.policies)).length) {
                    object.policies = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.policies[keys2[j]] = $root.common.ConfigPolicySchema.toObject(message.policies[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this ConfigGroupSchema to JSON.
             * @function toJSON
             * @memberof common.ConfigGroupSchema
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigGroupSchema.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigGroupSchema;
        })();
    
        common.ConfigValueSchema = (function() {
    
            /**
             * Properties of a ConfigValueSchema.
             * @memberof common
             * @interface IConfigValueSchema
             */
    
            /**
             * Constructs a new ConfigValueSchema.
             * @memberof common
             * @classdesc Represents a ConfigValueSchema.
             * @implements IConfigValueSchema
             * @constructor
             * @param {common.IConfigValueSchema=} [properties] Properties to set
             */
            function ConfigValueSchema(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ConfigValueSchema instance using the specified properties.
             * @function create
             * @memberof common.ConfigValueSchema
             * @static
             * @param {common.IConfigValueSchema=} [properties] Properties to set
             * @returns {common.ConfigValueSchema} ConfigValueSchema instance
             */
            ConfigValueSchema.create = function create(properties) {
                return new ConfigValueSchema(properties);
            };
    
            /**
             * Encodes the specified ConfigValueSchema message. Does not implicitly {@link common.ConfigValueSchema.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigValueSchema
             * @static
             * @param {common.IConfigValueSchema} message ConfigValueSchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigValueSchema.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigValueSchema message, length delimited. Does not implicitly {@link common.ConfigValueSchema.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigValueSchema
             * @static
             * @param {common.IConfigValueSchema} message ConfigValueSchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigValueSchema.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigValueSchema message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigValueSchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigValueSchema} ConfigValueSchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigValueSchema.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigValueSchema();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigValueSchema message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigValueSchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigValueSchema} ConfigValueSchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigValueSchema.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigValueSchema message.
             * @function verify
             * @memberof common.ConfigValueSchema
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigValueSchema.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a ConfigValueSchema message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigValueSchema
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigValueSchema} ConfigValueSchema
             */
            ConfigValueSchema.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigValueSchema)
                    return object;
                return new $root.common.ConfigValueSchema();
            };
    
            /**
             * Creates a plain object from a ConfigValueSchema message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigValueSchema
             * @static
             * @param {common.ConfigValueSchema} message ConfigValueSchema
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigValueSchema.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this ConfigValueSchema to JSON.
             * @function toJSON
             * @memberof common.ConfigValueSchema
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigValueSchema.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigValueSchema;
        })();
    
        common.ConfigPolicySchema = (function() {
    
            /**
             * Properties of a ConfigPolicySchema.
             * @memberof common
             * @interface IConfigPolicySchema
             */
    
            /**
             * Constructs a new ConfigPolicySchema.
             * @memberof common
             * @classdesc Represents a ConfigPolicySchema.
             * @implements IConfigPolicySchema
             * @constructor
             * @param {common.IConfigPolicySchema=} [properties] Properties to set
             */
            function ConfigPolicySchema(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ConfigPolicySchema instance using the specified properties.
             * @function create
             * @memberof common.ConfigPolicySchema
             * @static
             * @param {common.IConfigPolicySchema=} [properties] Properties to set
             * @returns {common.ConfigPolicySchema} ConfigPolicySchema instance
             */
            ConfigPolicySchema.create = function create(properties) {
                return new ConfigPolicySchema(properties);
            };
    
            /**
             * Encodes the specified ConfigPolicySchema message. Does not implicitly {@link common.ConfigPolicySchema.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigPolicySchema
             * @static
             * @param {common.IConfigPolicySchema} message ConfigPolicySchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigPolicySchema.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigPolicySchema message, length delimited. Does not implicitly {@link common.ConfigPolicySchema.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigPolicySchema
             * @static
             * @param {common.IConfigPolicySchema} message ConfigPolicySchema message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigPolicySchema.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigPolicySchema message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigPolicySchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigPolicySchema} ConfigPolicySchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigPolicySchema.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigPolicySchema();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigPolicySchema message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigPolicySchema
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigPolicySchema} ConfigPolicySchema
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigPolicySchema.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigPolicySchema message.
             * @function verify
             * @memberof common.ConfigPolicySchema
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigPolicySchema.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a ConfigPolicySchema message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigPolicySchema
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigPolicySchema} ConfigPolicySchema
             */
            ConfigPolicySchema.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigPolicySchema)
                    return object;
                return new $root.common.ConfigPolicySchema();
            };
    
            /**
             * Creates a plain object from a ConfigPolicySchema message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigPolicySchema
             * @static
             * @param {common.ConfigPolicySchema} message ConfigPolicySchema
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigPolicySchema.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this ConfigPolicySchema to JSON.
             * @function toJSON
             * @memberof common.ConfigPolicySchema
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigPolicySchema.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigPolicySchema;
        })();
    
        common.Config = (function() {
    
            /**
             * Properties of a Config.
             * @memberof common
             * @interface IConfig
             * @property {number|Long|null} [sequence] Config sequence
             * @property {common.IConfigGroup|null} [channelGroup] Config channelGroup
             */
    
            /**
             * Constructs a new Config.
             * @memberof common
             * @classdesc Represents a Config.
             * @implements IConfig
             * @constructor
             * @param {common.IConfig=} [properties] Properties to set
             */
            function Config(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Config sequence.
             * @member {number|Long} sequence
             * @memberof common.Config
             * @instance
             */
            Config.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Config channelGroup.
             * @member {common.IConfigGroup|null|undefined} channelGroup
             * @memberof common.Config
             * @instance
             */
            Config.prototype.channelGroup = null;
    
            /**
             * Creates a new Config instance using the specified properties.
             * @function create
             * @memberof common.Config
             * @static
             * @param {common.IConfig=} [properties] Properties to set
             * @returns {common.Config} Config instance
             */
            Config.create = function create(properties) {
                return new Config(properties);
            };
    
            /**
             * Encodes the specified Config message. Does not implicitly {@link common.Config.verify|verify} messages.
             * @function encode
             * @memberof common.Config
             * @static
             * @param {common.IConfig} message Config message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Config.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.sequence);
                if (message.channelGroup != null && message.hasOwnProperty("channelGroup"))
                    $root.common.ConfigGroup.encode(message.channelGroup, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Config message, length delimited. Does not implicitly {@link common.Config.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Config
             * @static
             * @param {common.IConfig} message Config message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Config.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Config message from the specified reader or buffer.
             * @function decode
             * @memberof common.Config
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Config} Config
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Config.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Config();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sequence = reader.uint64();
                        break;
                    case 2:
                        message.channelGroup = $root.common.ConfigGroup.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Config message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Config
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Config} Config
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Config.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Config message.
             * @function verify
             * @memberof common.Config
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Config.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                if (message.channelGroup != null && message.hasOwnProperty("channelGroup")) {
                    var error = $root.common.ConfigGroup.verify(message.channelGroup);
                    if (error)
                        return "channelGroup." + error;
                }
                return null;
            };
    
            /**
             * Creates a Config message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Config
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Config} Config
             */
            Config.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Config)
                    return object;
                var message = new $root.common.Config();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = true;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber(true);
                if (object.channelGroup != null) {
                    if (typeof object.channelGroup !== "object")
                        throw TypeError(".common.Config.channelGroup: object expected");
                    message.channelGroup = $root.common.ConfigGroup.fromObject(object.channelGroup);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Config message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Config
             * @static
             * @param {common.Config} message Config
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Config.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                    object.channelGroup = null;
                }
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber(true) : message.sequence;
                if (message.channelGroup != null && message.hasOwnProperty("channelGroup"))
                    object.channelGroup = $root.common.ConfigGroup.toObject(message.channelGroup, options);
                return object;
            };
    
            /**
             * Converts this Config to JSON.
             * @function toJSON
             * @memberof common.Config
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Config.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Config;
        })();
    
        common.ConfigUpdateEnvelope = (function() {
    
            /**
             * Properties of a ConfigUpdateEnvelope.
             * @memberof common
             * @interface IConfigUpdateEnvelope
             * @property {Uint8Array|null} [configUpdate] ConfigUpdateEnvelope configUpdate
             * @property {Array.<common.IConfigSignature>|null} [signatures] ConfigUpdateEnvelope signatures
             */
    
            /**
             * Constructs a new ConfigUpdateEnvelope.
             * @memberof common
             * @classdesc Represents a ConfigUpdateEnvelope.
             * @implements IConfigUpdateEnvelope
             * @constructor
             * @param {common.IConfigUpdateEnvelope=} [properties] Properties to set
             */
            function ConfigUpdateEnvelope(properties) {
                this.signatures = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigUpdateEnvelope configUpdate.
             * @member {Uint8Array} configUpdate
             * @memberof common.ConfigUpdateEnvelope
             * @instance
             */
            ConfigUpdateEnvelope.prototype.configUpdate = $util.newBuffer([]);
    
            /**
             * ConfigUpdateEnvelope signatures.
             * @member {Array.<common.IConfigSignature>} signatures
             * @memberof common.ConfigUpdateEnvelope
             * @instance
             */
            ConfigUpdateEnvelope.prototype.signatures = $util.emptyArray;
    
            /**
             * Creates a new ConfigUpdateEnvelope instance using the specified properties.
             * @function create
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {common.IConfigUpdateEnvelope=} [properties] Properties to set
             * @returns {common.ConfigUpdateEnvelope} ConfigUpdateEnvelope instance
             */
            ConfigUpdateEnvelope.create = function create(properties) {
                return new ConfigUpdateEnvelope(properties);
            };
    
            /**
             * Encodes the specified ConfigUpdateEnvelope message. Does not implicitly {@link common.ConfigUpdateEnvelope.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {common.IConfigUpdateEnvelope} message ConfigUpdateEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigUpdateEnvelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.configUpdate != null && message.hasOwnProperty("configUpdate"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.configUpdate);
                if (message.signatures != null && message.signatures.length)
                    for (var i = 0; i < message.signatures.length; ++i)
                        $root.common.ConfigSignature.encode(message.signatures[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigUpdateEnvelope message, length delimited. Does not implicitly {@link common.ConfigUpdateEnvelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {common.IConfigUpdateEnvelope} message ConfigUpdateEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigUpdateEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigUpdateEnvelope message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigUpdateEnvelope} ConfigUpdateEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigUpdateEnvelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigUpdateEnvelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.configUpdate = reader.bytes();
                        break;
                    case 2:
                        if (!(message.signatures && message.signatures.length))
                            message.signatures = [];
                        message.signatures.push($root.common.ConfigSignature.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigUpdateEnvelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigUpdateEnvelope} ConfigUpdateEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigUpdateEnvelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigUpdateEnvelope message.
             * @function verify
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigUpdateEnvelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.configUpdate != null && message.hasOwnProperty("configUpdate"))
                    if (!(message.configUpdate && typeof message.configUpdate.length === "number" || $util.isString(message.configUpdate)))
                        return "configUpdate: buffer expected";
                if (message.signatures != null && message.hasOwnProperty("signatures")) {
                    if (!Array.isArray(message.signatures))
                        return "signatures: array expected";
                    for (var i = 0; i < message.signatures.length; ++i) {
                        var error = $root.common.ConfigSignature.verify(message.signatures[i]);
                        if (error)
                            return "signatures." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ConfigUpdateEnvelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigUpdateEnvelope} ConfigUpdateEnvelope
             */
            ConfigUpdateEnvelope.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigUpdateEnvelope)
                    return object;
                var message = new $root.common.ConfigUpdateEnvelope();
                if (object.configUpdate != null)
                    if (typeof object.configUpdate === "string")
                        $util.base64.decode(object.configUpdate, message.configUpdate = $util.newBuffer($util.base64.length(object.configUpdate)), 0);
                    else if (object.configUpdate.length)
                        message.configUpdate = object.configUpdate;
                if (object.signatures) {
                    if (!Array.isArray(object.signatures))
                        throw TypeError(".common.ConfigUpdateEnvelope.signatures: array expected");
                    message.signatures = [];
                    for (var i = 0; i < object.signatures.length; ++i) {
                        if (typeof object.signatures[i] !== "object")
                            throw TypeError(".common.ConfigUpdateEnvelope.signatures: object expected");
                        message.signatures[i] = $root.common.ConfigSignature.fromObject(object.signatures[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigUpdateEnvelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigUpdateEnvelope
             * @static
             * @param {common.ConfigUpdateEnvelope} message ConfigUpdateEnvelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigUpdateEnvelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.signatures = [];
                if (options.defaults)
                    if (options.bytes === String)
                        object.configUpdate = "";
                    else {
                        object.configUpdate = [];
                        if (options.bytes !== Array)
                            object.configUpdate = $util.newBuffer(object.configUpdate);
                    }
                if (message.configUpdate != null && message.hasOwnProperty("configUpdate"))
                    object.configUpdate = options.bytes === String ? $util.base64.encode(message.configUpdate, 0, message.configUpdate.length) : options.bytes === Array ? Array.prototype.slice.call(message.configUpdate) : message.configUpdate;
                if (message.signatures && message.signatures.length) {
                    object.signatures = [];
                    for (var j = 0; j < message.signatures.length; ++j)
                        object.signatures[j] = $root.common.ConfigSignature.toObject(message.signatures[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ConfigUpdateEnvelope to JSON.
             * @function toJSON
             * @memberof common.ConfigUpdateEnvelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigUpdateEnvelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigUpdateEnvelope;
        })();
    
        common.ConfigUpdate = (function() {
    
            /**
             * Properties of a ConfigUpdate.
             * @memberof common
             * @interface IConfigUpdate
             * @property {string|null} [channelId] ConfigUpdate channelId
             * @property {common.IConfigGroup|null} [readSet] ConfigUpdate readSet
             * @property {common.IConfigGroup|null} [writeSet] ConfigUpdate writeSet
             * @property {Object.<string,Uint8Array>|null} [isolatedData] ConfigUpdate isolatedData
             */
    
            /**
             * Constructs a new ConfigUpdate.
             * @memberof common
             * @classdesc Represents a ConfigUpdate.
             * @implements IConfigUpdate
             * @constructor
             * @param {common.IConfigUpdate=} [properties] Properties to set
             */
            function ConfigUpdate(properties) {
                this.isolatedData = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigUpdate channelId.
             * @member {string} channelId
             * @memberof common.ConfigUpdate
             * @instance
             */
            ConfigUpdate.prototype.channelId = "";
    
            /**
             * ConfigUpdate readSet.
             * @member {common.IConfigGroup|null|undefined} readSet
             * @memberof common.ConfigUpdate
             * @instance
             */
            ConfigUpdate.prototype.readSet = null;
    
            /**
             * ConfigUpdate writeSet.
             * @member {common.IConfigGroup|null|undefined} writeSet
             * @memberof common.ConfigUpdate
             * @instance
             */
            ConfigUpdate.prototype.writeSet = null;
    
            /**
             * ConfigUpdate isolatedData.
             * @member {Object.<string,Uint8Array>} isolatedData
             * @memberof common.ConfigUpdate
             * @instance
             */
            ConfigUpdate.prototype.isolatedData = $util.emptyObject;
    
            /**
             * Creates a new ConfigUpdate instance using the specified properties.
             * @function create
             * @memberof common.ConfigUpdate
             * @static
             * @param {common.IConfigUpdate=} [properties] Properties to set
             * @returns {common.ConfigUpdate} ConfigUpdate instance
             */
            ConfigUpdate.create = function create(properties) {
                return new ConfigUpdate(properties);
            };
    
            /**
             * Encodes the specified ConfigUpdate message. Does not implicitly {@link common.ConfigUpdate.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigUpdate
             * @static
             * @param {common.IConfigUpdate} message ConfigUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigUpdate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelId);
                if (message.readSet != null && message.hasOwnProperty("readSet"))
                    $root.common.ConfigGroup.encode(message.readSet, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.writeSet != null && message.hasOwnProperty("writeSet"))
                    $root.common.ConfigGroup.encode(message.writeSet, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.isolatedData != null && message.hasOwnProperty("isolatedData"))
                    for (var keys = Object.keys(message.isolatedData), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.isolatedData[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigUpdate message, length delimited. Does not implicitly {@link common.ConfigUpdate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigUpdate
             * @static
             * @param {common.IConfigUpdate} message ConfigUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigUpdate message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigUpdate} ConfigUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigUpdate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigUpdate(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channelId = reader.string();
                        break;
                    case 2:
                        message.readSet = $root.common.ConfigGroup.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.writeSet = $root.common.ConfigGroup.decode(reader, reader.uint32());
                        break;
                    case 5:
                        reader.skip().pos++;
                        if (message.isolatedData === $util.emptyObject)
                            message.isolatedData = {};
                        key = reader.string();
                        reader.pos++;
                        message.isolatedData[key] = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigUpdate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigUpdate} ConfigUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigUpdate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigUpdate message.
             * @function verify
             * @memberof common.ConfigUpdate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigUpdate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (!$util.isString(message.channelId))
                        return "channelId: string expected";
                if (message.readSet != null && message.hasOwnProperty("readSet")) {
                    var error = $root.common.ConfigGroup.verify(message.readSet);
                    if (error)
                        return "readSet." + error;
                }
                if (message.writeSet != null && message.hasOwnProperty("writeSet")) {
                    var error = $root.common.ConfigGroup.verify(message.writeSet);
                    if (error)
                        return "writeSet." + error;
                }
                if (message.isolatedData != null && message.hasOwnProperty("isolatedData")) {
                    if (!$util.isObject(message.isolatedData))
                        return "isolatedData: object expected";
                    var key = Object.keys(message.isolatedData);
                    for (var i = 0; i < key.length; ++i)
                        if (!(message.isolatedData[key[i]] && typeof message.isolatedData[key[i]].length === "number" || $util.isString(message.isolatedData[key[i]])))
                            return "isolatedData: buffer{k:string} expected";
                }
                return null;
            };
    
            /**
             * Creates a ConfigUpdate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigUpdate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigUpdate} ConfigUpdate
             */
            ConfigUpdate.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigUpdate)
                    return object;
                var message = new $root.common.ConfigUpdate();
                if (object.channelId != null)
                    message.channelId = String(object.channelId);
                if (object.readSet != null) {
                    if (typeof object.readSet !== "object")
                        throw TypeError(".common.ConfigUpdate.readSet: object expected");
                    message.readSet = $root.common.ConfigGroup.fromObject(object.readSet);
                }
                if (object.writeSet != null) {
                    if (typeof object.writeSet !== "object")
                        throw TypeError(".common.ConfigUpdate.writeSet: object expected");
                    message.writeSet = $root.common.ConfigGroup.fromObject(object.writeSet);
                }
                if (object.isolatedData) {
                    if (typeof object.isolatedData !== "object")
                        throw TypeError(".common.ConfigUpdate.isolatedData: object expected");
                    message.isolatedData = {};
                    for (var keys = Object.keys(object.isolatedData), i = 0; i < keys.length; ++i)
                        if (typeof object.isolatedData[keys[i]] === "string")
                            $util.base64.decode(object.isolatedData[keys[i]], message.isolatedData[keys[i]] = $util.newBuffer($util.base64.length(object.isolatedData[keys[i]])), 0);
                        else if (object.isolatedData[keys[i]].length)
                            message.isolatedData[keys[i]] = object.isolatedData[keys[i]];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigUpdate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigUpdate
             * @static
             * @param {common.ConfigUpdate} message ConfigUpdate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigUpdate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.isolatedData = {};
                if (options.defaults) {
                    object.channelId = "";
                    object.readSet = null;
                    object.writeSet = null;
                }
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    object.channelId = message.channelId;
                if (message.readSet != null && message.hasOwnProperty("readSet"))
                    object.readSet = $root.common.ConfigGroup.toObject(message.readSet, options);
                if (message.writeSet != null && message.hasOwnProperty("writeSet"))
                    object.writeSet = $root.common.ConfigGroup.toObject(message.writeSet, options);
                var keys2;
                if (message.isolatedData && (keys2 = Object.keys(message.isolatedData)).length) {
                    object.isolatedData = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.isolatedData[keys2[j]] = options.bytes === String ? $util.base64.encode(message.isolatedData[keys2[j]], 0, message.isolatedData[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.isolatedData[keys2[j]]) : message.isolatedData[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this ConfigUpdate to JSON.
             * @function toJSON
             * @memberof common.ConfigUpdate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigUpdate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigUpdate;
        })();
    
        common.ConfigGroup = (function() {
    
            /**
             * Properties of a ConfigGroup.
             * @memberof common
             * @interface IConfigGroup
             * @property {number|Long|null} [version] ConfigGroup version
             * @property {Object.<string,common.IConfigGroup>|null} [groups] ConfigGroup groups
             * @property {Object.<string,common.IConfigValue>|null} [values] ConfigGroup values
             * @property {Object.<string,common.IConfigPolicy>|null} [policies] ConfigGroup policies
             * @property {string|null} [modPolicy] ConfigGroup modPolicy
             */
    
            /**
             * Constructs a new ConfigGroup.
             * @memberof common
             * @classdesc Represents a ConfigGroup.
             * @implements IConfigGroup
             * @constructor
             * @param {common.IConfigGroup=} [properties] Properties to set
             */
            function ConfigGroup(properties) {
                this.groups = {};
                this.values = {};
                this.policies = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigGroup version.
             * @member {number|Long} version
             * @memberof common.ConfigGroup
             * @instance
             */
            ConfigGroup.prototype.version = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * ConfigGroup groups.
             * @member {Object.<string,common.IConfigGroup>} groups
             * @memberof common.ConfigGroup
             * @instance
             */
            ConfigGroup.prototype.groups = $util.emptyObject;
    
            /**
             * ConfigGroup values.
             * @member {Object.<string,common.IConfigValue>} values
             * @memberof common.ConfigGroup
             * @instance
             */
            ConfigGroup.prototype.values = $util.emptyObject;
    
            /**
             * ConfigGroup policies.
             * @member {Object.<string,common.IConfigPolicy>} policies
             * @memberof common.ConfigGroup
             * @instance
             */
            ConfigGroup.prototype.policies = $util.emptyObject;
    
            /**
             * ConfigGroup modPolicy.
             * @member {string} modPolicy
             * @memberof common.ConfigGroup
             * @instance
             */
            ConfigGroup.prototype.modPolicy = "";
    
            /**
             * Creates a new ConfigGroup instance using the specified properties.
             * @function create
             * @memberof common.ConfigGroup
             * @static
             * @param {common.IConfigGroup=} [properties] Properties to set
             * @returns {common.ConfigGroup} ConfigGroup instance
             */
            ConfigGroup.create = function create(properties) {
                return new ConfigGroup(properties);
            };
    
            /**
             * Encodes the specified ConfigGroup message. Does not implicitly {@link common.ConfigGroup.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigGroup
             * @static
             * @param {common.IConfigGroup} message ConfigGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigGroup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.version);
                if (message.groups != null && message.hasOwnProperty("groups"))
                    for (var keys = Object.keys(message.groups), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.common.ConfigGroup.encode(message.groups[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.values != null && message.hasOwnProperty("values"))
                    for (var keys = Object.keys(message.values), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.common.ConfigValue.encode(message.values[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.policies != null && message.hasOwnProperty("policies"))
                    for (var keys = Object.keys(message.policies), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.common.ConfigPolicy.encode(message.policies[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.modPolicy != null && message.hasOwnProperty("modPolicy"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.modPolicy);
                return writer;
            };
    
            /**
             * Encodes the specified ConfigGroup message, length delimited. Does not implicitly {@link common.ConfigGroup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigGroup
             * @static
             * @param {common.IConfigGroup} message ConfigGroup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigGroup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigGroup message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigGroup} ConfigGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigGroup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigGroup(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.uint64();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.groups === $util.emptyObject)
                            message.groups = {};
                        key = reader.string();
                        reader.pos++;
                        message.groups[key] = $root.common.ConfigGroup.decode(reader, reader.uint32());
                        break;
                    case 3:
                        reader.skip().pos++;
                        if (message.values === $util.emptyObject)
                            message.values = {};
                        key = reader.string();
                        reader.pos++;
                        message.values[key] = $root.common.ConfigValue.decode(reader, reader.uint32());
                        break;
                    case 4:
                        reader.skip().pos++;
                        if (message.policies === $util.emptyObject)
                            message.policies = {};
                        key = reader.string();
                        reader.pos++;
                        message.policies[key] = $root.common.ConfigPolicy.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.modPolicy = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigGroup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigGroup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigGroup} ConfigGroup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigGroup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigGroup message.
             * @function verify
             * @memberof common.ConfigGroup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigGroup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                        return "version: integer|Long expected";
                if (message.groups != null && message.hasOwnProperty("groups")) {
                    if (!$util.isObject(message.groups))
                        return "groups: object expected";
                    var key = Object.keys(message.groups);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.common.ConfigGroup.verify(message.groups[key[i]]);
                        if (error)
                            return "groups." + error;
                    }
                }
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!$util.isObject(message.values))
                        return "values: object expected";
                    var key = Object.keys(message.values);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.common.ConfigValue.verify(message.values[key[i]]);
                        if (error)
                            return "values." + error;
                    }
                }
                if (message.policies != null && message.hasOwnProperty("policies")) {
                    if (!$util.isObject(message.policies))
                        return "policies: object expected";
                    var key = Object.keys(message.policies);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.common.ConfigPolicy.verify(message.policies[key[i]]);
                        if (error)
                            return "policies." + error;
                    }
                }
                if (message.modPolicy != null && message.hasOwnProperty("modPolicy"))
                    if (!$util.isString(message.modPolicy))
                        return "modPolicy: string expected";
                return null;
            };
    
            /**
             * Creates a ConfigGroup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigGroup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigGroup} ConfigGroup
             */
            ConfigGroup.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigGroup)
                    return object;
                var message = new $root.common.ConfigGroup();
                if (object.version != null)
                    if ($util.Long)
                        (message.version = $util.Long.fromValue(object.version)).unsigned = true;
                    else if (typeof object.version === "string")
                        message.version = parseInt(object.version, 10);
                    else if (typeof object.version === "number")
                        message.version = object.version;
                    else if (typeof object.version === "object")
                        message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
                if (object.groups) {
                    if (typeof object.groups !== "object")
                        throw TypeError(".common.ConfigGroup.groups: object expected");
                    message.groups = {};
                    for (var keys = Object.keys(object.groups), i = 0; i < keys.length; ++i) {
                        if (typeof object.groups[keys[i]] !== "object")
                            throw TypeError(".common.ConfigGroup.groups: object expected");
                        message.groups[keys[i]] = $root.common.ConfigGroup.fromObject(object.groups[keys[i]]);
                    }
                }
                if (object.values) {
                    if (typeof object.values !== "object")
                        throw TypeError(".common.ConfigGroup.values: object expected");
                    message.values = {};
                    for (var keys = Object.keys(object.values), i = 0; i < keys.length; ++i) {
                        if (typeof object.values[keys[i]] !== "object")
                            throw TypeError(".common.ConfigGroup.values: object expected");
                        message.values[keys[i]] = $root.common.ConfigValue.fromObject(object.values[keys[i]]);
                    }
                }
                if (object.policies) {
                    if (typeof object.policies !== "object")
                        throw TypeError(".common.ConfigGroup.policies: object expected");
                    message.policies = {};
                    for (var keys = Object.keys(object.policies), i = 0; i < keys.length; ++i) {
                        if (typeof object.policies[keys[i]] !== "object")
                            throw TypeError(".common.ConfigGroup.policies: object expected");
                        message.policies[keys[i]] = $root.common.ConfigPolicy.fromObject(object.policies[keys[i]]);
                    }
                }
                if (object.modPolicy != null)
                    message.modPolicy = String(object.modPolicy);
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigGroup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigGroup
             * @static
             * @param {common.ConfigGroup} message ConfigGroup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigGroup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults) {
                    object.groups = {};
                    object.values = {};
                    object.policies = {};
                }
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.version = options.longs === String ? "0" : 0;
                    object.modPolicy = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    if (typeof message.version === "number")
                        object.version = options.longs === String ? String(message.version) : message.version;
                    else
                        object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
                var keys2;
                if (message.groups && (keys2 = Object.keys(message.groups)).length) {
                    object.groups = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.groups[keys2[j]] = $root.common.ConfigGroup.toObject(message.groups[keys2[j]], options);
                }
                if (message.values && (keys2 = Object.keys(message.values)).length) {
                    object.values = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.values[keys2[j]] = $root.common.ConfigValue.toObject(message.values[keys2[j]], options);
                }
                if (message.policies && (keys2 = Object.keys(message.policies)).length) {
                    object.policies = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.policies[keys2[j]] = $root.common.ConfigPolicy.toObject(message.policies[keys2[j]], options);
                }
                if (message.modPolicy != null && message.hasOwnProperty("modPolicy"))
                    object.modPolicy = message.modPolicy;
                return object;
            };
    
            /**
             * Converts this ConfigGroup to JSON.
             * @function toJSON
             * @memberof common.ConfigGroup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigGroup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigGroup;
        })();
    
        common.ConfigValue = (function() {
    
            /**
             * Properties of a ConfigValue.
             * @memberof common
             * @interface IConfigValue
             * @property {number|Long|null} [version] ConfigValue version
             * @property {Uint8Array|null} [value] ConfigValue value
             * @property {string|null} [modPolicy] ConfigValue modPolicy
             */
    
            /**
             * Constructs a new ConfigValue.
             * @memberof common
             * @classdesc Represents a ConfigValue.
             * @implements IConfigValue
             * @constructor
             * @param {common.IConfigValue=} [properties] Properties to set
             */
            function ConfigValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigValue version.
             * @member {number|Long} version
             * @memberof common.ConfigValue
             * @instance
             */
            ConfigValue.prototype.version = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * ConfigValue value.
             * @member {Uint8Array} value
             * @memberof common.ConfigValue
             * @instance
             */
            ConfigValue.prototype.value = $util.newBuffer([]);
    
            /**
             * ConfigValue modPolicy.
             * @member {string} modPolicy
             * @memberof common.ConfigValue
             * @instance
             */
            ConfigValue.prototype.modPolicy = "";
    
            /**
             * Creates a new ConfigValue instance using the specified properties.
             * @function create
             * @memberof common.ConfigValue
             * @static
             * @param {common.IConfigValue=} [properties] Properties to set
             * @returns {common.ConfigValue} ConfigValue instance
             */
            ConfigValue.create = function create(properties) {
                return new ConfigValue(properties);
            };
    
            /**
             * Encodes the specified ConfigValue message. Does not implicitly {@link common.ConfigValue.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigValue
             * @static
             * @param {common.IConfigValue} message ConfigValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.version);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.modPolicy != null && message.hasOwnProperty("modPolicy"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.modPolicy);
                return writer;
            };
    
            /**
             * Encodes the specified ConfigValue message, length delimited. Does not implicitly {@link common.ConfigValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigValue
             * @static
             * @param {common.IConfigValue} message ConfigValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigValue message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigValue} ConfigValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.uint64();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.modPolicy = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigValue} ConfigValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigValue message.
             * @function verify
             * @memberof common.ConfigValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                        return "version: integer|Long expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.modPolicy != null && message.hasOwnProperty("modPolicy"))
                    if (!$util.isString(message.modPolicy))
                        return "modPolicy: string expected";
                return null;
            };
    
            /**
             * Creates a ConfigValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigValue} ConfigValue
             */
            ConfigValue.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigValue)
                    return object;
                var message = new $root.common.ConfigValue();
                if (object.version != null)
                    if ($util.Long)
                        (message.version = $util.Long.fromValue(object.version)).unsigned = true;
                    else if (typeof object.version === "string")
                        message.version = parseInt(object.version, 10);
                    else if (typeof object.version === "number")
                        message.version = object.version;
                    else if (typeof object.version === "object")
                        message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.modPolicy != null)
                    message.modPolicy = String(object.modPolicy);
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigValue
             * @static
             * @param {common.ConfigValue} message ConfigValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.version = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.modPolicy = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    if (typeof message.version === "number")
                        object.version = options.longs === String ? String(message.version) : message.version;
                    else
                        object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.modPolicy != null && message.hasOwnProperty("modPolicy"))
                    object.modPolicy = message.modPolicy;
                return object;
            };
    
            /**
             * Converts this ConfigValue to JSON.
             * @function toJSON
             * @memberof common.ConfigValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigValue;
        })();
    
        common.ConfigPolicy = (function() {
    
            /**
             * Properties of a ConfigPolicy.
             * @memberof common
             * @interface IConfigPolicy
             * @property {number|Long|null} [version] ConfigPolicy version
             * @property {common.IPolicy|null} [policy] ConfigPolicy policy
             * @property {string|null} [modPolicy] ConfigPolicy modPolicy
             */
    
            /**
             * Constructs a new ConfigPolicy.
             * @memberof common
             * @classdesc Represents a ConfigPolicy.
             * @implements IConfigPolicy
             * @constructor
             * @param {common.IConfigPolicy=} [properties] Properties to set
             */
            function ConfigPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigPolicy version.
             * @member {number|Long} version
             * @memberof common.ConfigPolicy
             * @instance
             */
            ConfigPolicy.prototype.version = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * ConfigPolicy policy.
             * @member {common.IPolicy|null|undefined} policy
             * @memberof common.ConfigPolicy
             * @instance
             */
            ConfigPolicy.prototype.policy = null;
    
            /**
             * ConfigPolicy modPolicy.
             * @member {string} modPolicy
             * @memberof common.ConfigPolicy
             * @instance
             */
            ConfigPolicy.prototype.modPolicy = "";
    
            /**
             * Creates a new ConfigPolicy instance using the specified properties.
             * @function create
             * @memberof common.ConfigPolicy
             * @static
             * @param {common.IConfigPolicy=} [properties] Properties to set
             * @returns {common.ConfigPolicy} ConfigPolicy instance
             */
            ConfigPolicy.create = function create(properties) {
                return new ConfigPolicy(properties);
            };
    
            /**
             * Encodes the specified ConfigPolicy message. Does not implicitly {@link common.ConfigPolicy.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigPolicy
             * @static
             * @param {common.IConfigPolicy} message ConfigPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.version);
                if (message.policy != null && message.hasOwnProperty("policy"))
                    $root.common.Policy.encode(message.policy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.modPolicy != null && message.hasOwnProperty("modPolicy"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.modPolicy);
                return writer;
            };
    
            /**
             * Encodes the specified ConfigPolicy message, length delimited. Does not implicitly {@link common.ConfigPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigPolicy
             * @static
             * @param {common.IConfigPolicy} message ConfigPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigPolicy} ConfigPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.uint64();
                        break;
                    case 2:
                        message.policy = $root.common.Policy.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.modPolicy = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigPolicy} ConfigPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigPolicy message.
             * @function verify
             * @memberof common.ConfigPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                        return "version: integer|Long expected";
                if (message.policy != null && message.hasOwnProperty("policy")) {
                    var error = $root.common.Policy.verify(message.policy);
                    if (error)
                        return "policy." + error;
                }
                if (message.modPolicy != null && message.hasOwnProperty("modPolicy"))
                    if (!$util.isString(message.modPolicy))
                        return "modPolicy: string expected";
                return null;
            };
    
            /**
             * Creates a ConfigPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigPolicy} ConfigPolicy
             */
            ConfigPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigPolicy)
                    return object;
                var message = new $root.common.ConfigPolicy();
                if (object.version != null)
                    if ($util.Long)
                        (message.version = $util.Long.fromValue(object.version)).unsigned = true;
                    else if (typeof object.version === "string")
                        message.version = parseInt(object.version, 10);
                    else if (typeof object.version === "number")
                        message.version = object.version;
                    else if (typeof object.version === "object")
                        message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
                if (object.policy != null) {
                    if (typeof object.policy !== "object")
                        throw TypeError(".common.ConfigPolicy.policy: object expected");
                    message.policy = $root.common.Policy.fromObject(object.policy);
                }
                if (object.modPolicy != null)
                    message.modPolicy = String(object.modPolicy);
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigPolicy
             * @static
             * @param {common.ConfigPolicy} message ConfigPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.version = options.longs === String ? "0" : 0;
                    object.policy = null;
                    object.modPolicy = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    if (typeof message.version === "number")
                        object.version = options.longs === String ? String(message.version) : message.version;
                    else
                        object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
                if (message.policy != null && message.hasOwnProperty("policy"))
                    object.policy = $root.common.Policy.toObject(message.policy, options);
                if (message.modPolicy != null && message.hasOwnProperty("modPolicy"))
                    object.modPolicy = message.modPolicy;
                return object;
            };
    
            /**
             * Converts this ConfigPolicy to JSON.
             * @function toJSON
             * @memberof common.ConfigPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigPolicy;
        })();
    
        common.ConfigSignature = (function() {
    
            /**
             * Properties of a ConfigSignature.
             * @memberof common
             * @interface IConfigSignature
             * @property {Uint8Array|null} [signatureHeader] ConfigSignature signatureHeader
             * @property {Uint8Array|null} [signature] ConfigSignature signature
             */
    
            /**
             * Constructs a new ConfigSignature.
             * @memberof common
             * @classdesc Represents a ConfigSignature.
             * @implements IConfigSignature
             * @constructor
             * @param {common.IConfigSignature=} [properties] Properties to set
             */
            function ConfigSignature(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigSignature signatureHeader.
             * @member {Uint8Array} signatureHeader
             * @memberof common.ConfigSignature
             * @instance
             */
            ConfigSignature.prototype.signatureHeader = $util.newBuffer([]);
    
            /**
             * ConfigSignature signature.
             * @member {Uint8Array} signature
             * @memberof common.ConfigSignature
             * @instance
             */
            ConfigSignature.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new ConfigSignature instance using the specified properties.
             * @function create
             * @memberof common.ConfigSignature
             * @static
             * @param {common.IConfigSignature=} [properties] Properties to set
             * @returns {common.ConfigSignature} ConfigSignature instance
             */
            ConfigSignature.create = function create(properties) {
                return new ConfigSignature(properties);
            };
    
            /**
             * Encodes the specified ConfigSignature message. Does not implicitly {@link common.ConfigSignature.verify|verify} messages.
             * @function encode
             * @memberof common.ConfigSignature
             * @static
             * @param {common.IConfigSignature} message ConfigSignature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigSignature.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signatureHeader != null && message.hasOwnProperty("signatureHeader"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signatureHeader);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified ConfigSignature message, length delimited. Does not implicitly {@link common.ConfigSignature.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.ConfigSignature
             * @static
             * @param {common.IConfigSignature} message ConfigSignature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigSignature.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigSignature message from the specified reader or buffer.
             * @function decode
             * @memberof common.ConfigSignature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.ConfigSignature} ConfigSignature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigSignature.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.ConfigSignature();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signatureHeader = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigSignature message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.ConfigSignature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.ConfigSignature} ConfigSignature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigSignature.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigSignature message.
             * @function verify
             * @memberof common.ConfigSignature
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigSignature.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.signatureHeader != null && message.hasOwnProperty("signatureHeader"))
                    if (!(message.signatureHeader && typeof message.signatureHeader.length === "number" || $util.isString(message.signatureHeader)))
                        return "signatureHeader: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates a ConfigSignature message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.ConfigSignature
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.ConfigSignature} ConfigSignature
             */
            ConfigSignature.fromObject = function fromObject(object) {
                if (object instanceof $root.common.ConfigSignature)
                    return object;
                var message = new $root.common.ConfigSignature();
                if (object.signatureHeader != null)
                    if (typeof object.signatureHeader === "string")
                        $util.base64.decode(object.signatureHeader, message.signatureHeader = $util.newBuffer($util.base64.length(object.signatureHeader)), 0);
                    else if (object.signatureHeader.length)
                        message.signatureHeader = object.signatureHeader;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigSignature message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.ConfigSignature
             * @static
             * @param {common.ConfigSignature} message ConfigSignature
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigSignature.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.signatureHeader = "";
                    else {
                        object.signatureHeader = [];
                        if (options.bytes !== Array)
                            object.signatureHeader = $util.newBuffer(object.signatureHeader);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.signatureHeader != null && message.hasOwnProperty("signatureHeader"))
                    object.signatureHeader = options.bytes === String ? $util.base64.encode(message.signatureHeader, 0, message.signatureHeader.length) : options.bytes === Array ? Array.prototype.slice.call(message.signatureHeader) : message.signatureHeader;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this ConfigSignature to JSON.
             * @function toJSON
             * @memberof common.ConfigSignature
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigSignature.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigSignature;
        })();
    
        common.BlockchainInfo = (function() {
    
            /**
             * Properties of a BlockchainInfo.
             * @memberof common
             * @interface IBlockchainInfo
             * @property {number|Long|null} [height] BlockchainInfo height
             * @property {Uint8Array|null} [currentBlockHash] BlockchainInfo currentBlockHash
             * @property {Uint8Array|null} [previousBlockHash] BlockchainInfo previousBlockHash
             */
    
            /**
             * Constructs a new BlockchainInfo.
             * @memberof common
             * @classdesc Represents a BlockchainInfo.
             * @implements IBlockchainInfo
             * @constructor
             * @param {common.IBlockchainInfo=} [properties] Properties to set
             */
            function BlockchainInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockchainInfo height.
             * @member {number|Long} height
             * @memberof common.BlockchainInfo
             * @instance
             */
            BlockchainInfo.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * BlockchainInfo currentBlockHash.
             * @member {Uint8Array} currentBlockHash
             * @memberof common.BlockchainInfo
             * @instance
             */
            BlockchainInfo.prototype.currentBlockHash = $util.newBuffer([]);
    
            /**
             * BlockchainInfo previousBlockHash.
             * @member {Uint8Array} previousBlockHash
             * @memberof common.BlockchainInfo
             * @instance
             */
            BlockchainInfo.prototype.previousBlockHash = $util.newBuffer([]);
    
            /**
             * Creates a new BlockchainInfo instance using the specified properties.
             * @function create
             * @memberof common.BlockchainInfo
             * @static
             * @param {common.IBlockchainInfo=} [properties] Properties to set
             * @returns {common.BlockchainInfo} BlockchainInfo instance
             */
            BlockchainInfo.create = function create(properties) {
                return new BlockchainInfo(properties);
            };
    
            /**
             * Encodes the specified BlockchainInfo message. Does not implicitly {@link common.BlockchainInfo.verify|verify} messages.
             * @function encode
             * @memberof common.BlockchainInfo
             * @static
             * @param {common.IBlockchainInfo} message BlockchainInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockchainInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.height != null && message.hasOwnProperty("height"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.height);
                if (message.currentBlockHash != null && message.hasOwnProperty("currentBlockHash"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.currentBlockHash);
                if (message.previousBlockHash != null && message.hasOwnProperty("previousBlockHash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.previousBlockHash);
                return writer;
            };
    
            /**
             * Encodes the specified BlockchainInfo message, length delimited. Does not implicitly {@link common.BlockchainInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.BlockchainInfo
             * @static
             * @param {common.IBlockchainInfo} message BlockchainInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockchainInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockchainInfo message from the specified reader or buffer.
             * @function decode
             * @memberof common.BlockchainInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.BlockchainInfo} BlockchainInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockchainInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.BlockchainInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.height = reader.uint64();
                        break;
                    case 2:
                        message.currentBlockHash = reader.bytes();
                        break;
                    case 3:
                        message.previousBlockHash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockchainInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.BlockchainInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.BlockchainInfo} BlockchainInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockchainInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockchainInfo message.
             * @function verify
             * @memberof common.BlockchainInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockchainInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.height != null && message.hasOwnProperty("height"))
                    if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                        return "height: integer|Long expected";
                if (message.currentBlockHash != null && message.hasOwnProperty("currentBlockHash"))
                    if (!(message.currentBlockHash && typeof message.currentBlockHash.length === "number" || $util.isString(message.currentBlockHash)))
                        return "currentBlockHash: buffer expected";
                if (message.previousBlockHash != null && message.hasOwnProperty("previousBlockHash"))
                    if (!(message.previousBlockHash && typeof message.previousBlockHash.length === "number" || $util.isString(message.previousBlockHash)))
                        return "previousBlockHash: buffer expected";
                return null;
            };
    
            /**
             * Creates a BlockchainInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.BlockchainInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.BlockchainInfo} BlockchainInfo
             */
            BlockchainInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.common.BlockchainInfo)
                    return object;
                var message = new $root.common.BlockchainInfo();
                if (object.height != null)
                    if ($util.Long)
                        (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                    else if (typeof object.height === "string")
                        message.height = parseInt(object.height, 10);
                    else if (typeof object.height === "number")
                        message.height = object.height;
                    else if (typeof object.height === "object")
                        message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
                if (object.currentBlockHash != null)
                    if (typeof object.currentBlockHash === "string")
                        $util.base64.decode(object.currentBlockHash, message.currentBlockHash = $util.newBuffer($util.base64.length(object.currentBlockHash)), 0);
                    else if (object.currentBlockHash.length)
                        message.currentBlockHash = object.currentBlockHash;
                if (object.previousBlockHash != null)
                    if (typeof object.previousBlockHash === "string")
                        $util.base64.decode(object.previousBlockHash, message.previousBlockHash = $util.newBuffer($util.base64.length(object.previousBlockHash)), 0);
                    else if (object.previousBlockHash.length)
                        message.previousBlockHash = object.previousBlockHash;
                return message;
            };
    
            /**
             * Creates a plain object from a BlockchainInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.BlockchainInfo
             * @static
             * @param {common.BlockchainInfo} message BlockchainInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockchainInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.height = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.currentBlockHash = "";
                    else {
                        object.currentBlockHash = [];
                        if (options.bytes !== Array)
                            object.currentBlockHash = $util.newBuffer(object.currentBlockHash);
                    }
                    if (options.bytes === String)
                        object.previousBlockHash = "";
                    else {
                        object.previousBlockHash = [];
                        if (options.bytes !== Array)
                            object.previousBlockHash = $util.newBuffer(object.previousBlockHash);
                    }
                }
                if (message.height != null && message.hasOwnProperty("height"))
                    if (typeof message.height === "number")
                        object.height = options.longs === String ? String(message.height) : message.height;
                    else
                        object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
                if (message.currentBlockHash != null && message.hasOwnProperty("currentBlockHash"))
                    object.currentBlockHash = options.bytes === String ? $util.base64.encode(message.currentBlockHash, 0, message.currentBlockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.currentBlockHash) : message.currentBlockHash;
                if (message.previousBlockHash != null && message.hasOwnProperty("previousBlockHash"))
                    object.previousBlockHash = options.bytes === String ? $util.base64.encode(message.previousBlockHash, 0, message.previousBlockHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.previousBlockHash) : message.previousBlockHash;
                return object;
            };
    
            /**
             * Converts this BlockchainInfo to JSON.
             * @function toJSON
             * @memberof common.BlockchainInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockchainInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockchainInfo;
        })();
    
        common.HashingAlgorithm = (function() {
    
            /**
             * Properties of a HashingAlgorithm.
             * @memberof common
             * @interface IHashingAlgorithm
             * @property {string|null} [name] HashingAlgorithm name
             */
    
            /**
             * Constructs a new HashingAlgorithm.
             * @memberof common
             * @classdesc Represents a HashingAlgorithm.
             * @implements IHashingAlgorithm
             * @constructor
             * @param {common.IHashingAlgorithm=} [properties] Properties to set
             */
            function HashingAlgorithm(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * HashingAlgorithm name.
             * @member {string} name
             * @memberof common.HashingAlgorithm
             * @instance
             */
            HashingAlgorithm.prototype.name = "";
    
            /**
             * Creates a new HashingAlgorithm instance using the specified properties.
             * @function create
             * @memberof common.HashingAlgorithm
             * @static
             * @param {common.IHashingAlgorithm=} [properties] Properties to set
             * @returns {common.HashingAlgorithm} HashingAlgorithm instance
             */
            HashingAlgorithm.create = function create(properties) {
                return new HashingAlgorithm(properties);
            };
    
            /**
             * Encodes the specified HashingAlgorithm message. Does not implicitly {@link common.HashingAlgorithm.verify|verify} messages.
             * @function encode
             * @memberof common.HashingAlgorithm
             * @static
             * @param {common.IHashingAlgorithm} message HashingAlgorithm message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HashingAlgorithm.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified HashingAlgorithm message, length delimited. Does not implicitly {@link common.HashingAlgorithm.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.HashingAlgorithm
             * @static
             * @param {common.IHashingAlgorithm} message HashingAlgorithm message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HashingAlgorithm.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a HashingAlgorithm message from the specified reader or buffer.
             * @function decode
             * @memberof common.HashingAlgorithm
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.HashingAlgorithm} HashingAlgorithm
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HashingAlgorithm.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.HashingAlgorithm();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a HashingAlgorithm message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.HashingAlgorithm
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.HashingAlgorithm} HashingAlgorithm
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HashingAlgorithm.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a HashingAlgorithm message.
             * @function verify
             * @memberof common.HashingAlgorithm
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HashingAlgorithm.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a HashingAlgorithm message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.HashingAlgorithm
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.HashingAlgorithm} HashingAlgorithm
             */
            HashingAlgorithm.fromObject = function fromObject(object) {
                if (object instanceof $root.common.HashingAlgorithm)
                    return object;
                var message = new $root.common.HashingAlgorithm();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a HashingAlgorithm message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.HashingAlgorithm
             * @static
             * @param {common.HashingAlgorithm} message HashingAlgorithm
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HashingAlgorithm.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this HashingAlgorithm to JSON.
             * @function toJSON
             * @memberof common.HashingAlgorithm
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HashingAlgorithm.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return HashingAlgorithm;
        })();
    
        common.BlockDataHashingStructure = (function() {
    
            /**
             * Properties of a BlockDataHashingStructure.
             * @memberof common
             * @interface IBlockDataHashingStructure
             * @property {number|null} [width] BlockDataHashingStructure width
             */
    
            /**
             * Constructs a new BlockDataHashingStructure.
             * @memberof common
             * @classdesc Represents a BlockDataHashingStructure.
             * @implements IBlockDataHashingStructure
             * @constructor
             * @param {common.IBlockDataHashingStructure=} [properties] Properties to set
             */
            function BlockDataHashingStructure(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockDataHashingStructure width.
             * @member {number} width
             * @memberof common.BlockDataHashingStructure
             * @instance
             */
            BlockDataHashingStructure.prototype.width = 0;
    
            /**
             * Creates a new BlockDataHashingStructure instance using the specified properties.
             * @function create
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {common.IBlockDataHashingStructure=} [properties] Properties to set
             * @returns {common.BlockDataHashingStructure} BlockDataHashingStructure instance
             */
            BlockDataHashingStructure.create = function create(properties) {
                return new BlockDataHashingStructure(properties);
            };
    
            /**
             * Encodes the specified BlockDataHashingStructure message. Does not implicitly {@link common.BlockDataHashingStructure.verify|verify} messages.
             * @function encode
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {common.IBlockDataHashingStructure} message BlockDataHashingStructure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockDataHashingStructure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.width != null && message.hasOwnProperty("width"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.width);
                return writer;
            };
    
            /**
             * Encodes the specified BlockDataHashingStructure message, length delimited. Does not implicitly {@link common.BlockDataHashingStructure.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {common.IBlockDataHashingStructure} message BlockDataHashingStructure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockDataHashingStructure.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockDataHashingStructure message from the specified reader or buffer.
             * @function decode
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.BlockDataHashingStructure} BlockDataHashingStructure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockDataHashingStructure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.BlockDataHashingStructure();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.width = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockDataHashingStructure message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.BlockDataHashingStructure} BlockDataHashingStructure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockDataHashingStructure.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockDataHashingStructure message.
             * @function verify
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockDataHashingStructure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.width != null && message.hasOwnProperty("width"))
                    if (!$util.isInteger(message.width))
                        return "width: integer expected";
                return null;
            };
    
            /**
             * Creates a BlockDataHashingStructure message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.BlockDataHashingStructure} BlockDataHashingStructure
             */
            BlockDataHashingStructure.fromObject = function fromObject(object) {
                if (object instanceof $root.common.BlockDataHashingStructure)
                    return object;
                var message = new $root.common.BlockDataHashingStructure();
                if (object.width != null)
                    message.width = object.width >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a BlockDataHashingStructure message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.BlockDataHashingStructure
             * @static
             * @param {common.BlockDataHashingStructure} message BlockDataHashingStructure
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockDataHashingStructure.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.width = 0;
                if (message.width != null && message.hasOwnProperty("width"))
                    object.width = message.width;
                return object;
            };
    
            /**
             * Converts this BlockDataHashingStructure to JSON.
             * @function toJSON
             * @memberof common.BlockDataHashingStructure
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockDataHashingStructure.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockDataHashingStructure;
        })();
    
        common.OrdererAddresses = (function() {
    
            /**
             * Properties of an OrdererAddresses.
             * @memberof common
             * @interface IOrdererAddresses
             * @property {Array.<string>|null} [addresses] OrdererAddresses addresses
             */
    
            /**
             * Constructs a new OrdererAddresses.
             * @memberof common
             * @classdesc Represents an OrdererAddresses.
             * @implements IOrdererAddresses
             * @constructor
             * @param {common.IOrdererAddresses=} [properties] Properties to set
             */
            function OrdererAddresses(properties) {
                this.addresses = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * OrdererAddresses addresses.
             * @member {Array.<string>} addresses
             * @memberof common.OrdererAddresses
             * @instance
             */
            OrdererAddresses.prototype.addresses = $util.emptyArray;
    
            /**
             * Creates a new OrdererAddresses instance using the specified properties.
             * @function create
             * @memberof common.OrdererAddresses
             * @static
             * @param {common.IOrdererAddresses=} [properties] Properties to set
             * @returns {common.OrdererAddresses} OrdererAddresses instance
             */
            OrdererAddresses.create = function create(properties) {
                return new OrdererAddresses(properties);
            };
    
            /**
             * Encodes the specified OrdererAddresses message. Does not implicitly {@link common.OrdererAddresses.verify|verify} messages.
             * @function encode
             * @memberof common.OrdererAddresses
             * @static
             * @param {common.IOrdererAddresses} message OrdererAddresses message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrdererAddresses.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.addresses != null && message.addresses.length)
                    for (var i = 0; i < message.addresses.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.addresses[i]);
                return writer;
            };
    
            /**
             * Encodes the specified OrdererAddresses message, length delimited. Does not implicitly {@link common.OrdererAddresses.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.OrdererAddresses
             * @static
             * @param {common.IOrdererAddresses} message OrdererAddresses message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrdererAddresses.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an OrdererAddresses message from the specified reader or buffer.
             * @function decode
             * @memberof common.OrdererAddresses
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.OrdererAddresses} OrdererAddresses
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrdererAddresses.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.OrdererAddresses();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.addresses && message.addresses.length))
                            message.addresses = [];
                        message.addresses.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an OrdererAddresses message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.OrdererAddresses
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.OrdererAddresses} OrdererAddresses
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrdererAddresses.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an OrdererAddresses message.
             * @function verify
             * @memberof common.OrdererAddresses
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrdererAddresses.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.addresses != null && message.hasOwnProperty("addresses")) {
                    if (!Array.isArray(message.addresses))
                        return "addresses: array expected";
                    for (var i = 0; i < message.addresses.length; ++i)
                        if (!$util.isString(message.addresses[i]))
                            return "addresses: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates an OrdererAddresses message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.OrdererAddresses
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.OrdererAddresses} OrdererAddresses
             */
            OrdererAddresses.fromObject = function fromObject(object) {
                if (object instanceof $root.common.OrdererAddresses)
                    return object;
                var message = new $root.common.OrdererAddresses();
                if (object.addresses) {
                    if (!Array.isArray(object.addresses))
                        throw TypeError(".common.OrdererAddresses.addresses: array expected");
                    message.addresses = [];
                    for (var i = 0; i < object.addresses.length; ++i)
                        message.addresses[i] = String(object.addresses[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an OrdererAddresses message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.OrdererAddresses
             * @static
             * @param {common.OrdererAddresses} message OrdererAddresses
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrdererAddresses.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.addresses = [];
                if (message.addresses && message.addresses.length) {
                    object.addresses = [];
                    for (var j = 0; j < message.addresses.length; ++j)
                        object.addresses[j] = message.addresses[j];
                }
                return object;
            };
    
            /**
             * Converts this OrdererAddresses to JSON.
             * @function toJSON
             * @memberof common.OrdererAddresses
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrdererAddresses.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return OrdererAddresses;
        })();
    
        common.Consortium = (function() {
    
            /**
             * Properties of a Consortium.
             * @memberof common
             * @interface IConsortium
             * @property {string|null} [name] Consortium name
             */
    
            /**
             * Constructs a new Consortium.
             * @memberof common
             * @classdesc Represents a Consortium.
             * @implements IConsortium
             * @constructor
             * @param {common.IConsortium=} [properties] Properties to set
             */
            function Consortium(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Consortium name.
             * @member {string} name
             * @memberof common.Consortium
             * @instance
             */
            Consortium.prototype.name = "";
    
            /**
             * Creates a new Consortium instance using the specified properties.
             * @function create
             * @memberof common.Consortium
             * @static
             * @param {common.IConsortium=} [properties] Properties to set
             * @returns {common.Consortium} Consortium instance
             */
            Consortium.create = function create(properties) {
                return new Consortium(properties);
            };
    
            /**
             * Encodes the specified Consortium message. Does not implicitly {@link common.Consortium.verify|verify} messages.
             * @function encode
             * @memberof common.Consortium
             * @static
             * @param {common.IConsortium} message Consortium message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Consortium.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified Consortium message, length delimited. Does not implicitly {@link common.Consortium.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Consortium
             * @static
             * @param {common.IConsortium} message Consortium message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Consortium.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Consortium message from the specified reader or buffer.
             * @function decode
             * @memberof common.Consortium
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Consortium} Consortium
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Consortium.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Consortium();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Consortium message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Consortium
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Consortium} Consortium
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Consortium.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Consortium message.
             * @function verify
             * @memberof common.Consortium
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Consortium.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a Consortium message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Consortium
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Consortium} Consortium
             */
            Consortium.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Consortium)
                    return object;
                var message = new $root.common.Consortium();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a Consortium message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Consortium
             * @static
             * @param {common.Consortium} message Consortium
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Consortium.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this Consortium to JSON.
             * @function toJSON
             * @memberof common.Consortium
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Consortium.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Consortium;
        })();
    
        common.Capabilities = (function() {
    
            /**
             * Properties of a Capabilities.
             * @memberof common
             * @interface ICapabilities
             * @property {Object.<string,common.ICapability>|null} [capabilities] Capabilities capabilities
             */
    
            /**
             * Constructs a new Capabilities.
             * @memberof common
             * @classdesc Represents a Capabilities.
             * @implements ICapabilities
             * @constructor
             * @param {common.ICapabilities=} [properties] Properties to set
             */
            function Capabilities(properties) {
                this.capabilities = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Capabilities capabilities.
             * @member {Object.<string,common.ICapability>} capabilities
             * @memberof common.Capabilities
             * @instance
             */
            Capabilities.prototype.capabilities = $util.emptyObject;
    
            /**
             * Creates a new Capabilities instance using the specified properties.
             * @function create
             * @memberof common.Capabilities
             * @static
             * @param {common.ICapabilities=} [properties] Properties to set
             * @returns {common.Capabilities} Capabilities instance
             */
            Capabilities.create = function create(properties) {
                return new Capabilities(properties);
            };
    
            /**
             * Encodes the specified Capabilities message. Does not implicitly {@link common.Capabilities.verify|verify} messages.
             * @function encode
             * @memberof common.Capabilities
             * @static
             * @param {common.ICapabilities} message Capabilities message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Capabilities.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.capabilities != null && message.hasOwnProperty("capabilities"))
                    for (var keys = Object.keys(message.capabilities), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.common.Capability.encode(message.capabilities[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified Capabilities message, length delimited. Does not implicitly {@link common.Capabilities.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Capabilities
             * @static
             * @param {common.ICapabilities} message Capabilities message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Capabilities.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Capabilities message from the specified reader or buffer.
             * @function decode
             * @memberof common.Capabilities
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Capabilities} Capabilities
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Capabilities.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Capabilities(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.capabilities === $util.emptyObject)
                            message.capabilities = {};
                        key = reader.string();
                        reader.pos++;
                        message.capabilities[key] = $root.common.Capability.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Capabilities message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Capabilities
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Capabilities} Capabilities
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Capabilities.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Capabilities message.
             * @function verify
             * @memberof common.Capabilities
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Capabilities.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.capabilities != null && message.hasOwnProperty("capabilities")) {
                    if (!$util.isObject(message.capabilities))
                        return "capabilities: object expected";
                    var key = Object.keys(message.capabilities);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.common.Capability.verify(message.capabilities[key[i]]);
                        if (error)
                            return "capabilities." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Capabilities message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Capabilities
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Capabilities} Capabilities
             */
            Capabilities.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Capabilities)
                    return object;
                var message = new $root.common.Capabilities();
                if (object.capabilities) {
                    if (typeof object.capabilities !== "object")
                        throw TypeError(".common.Capabilities.capabilities: object expected");
                    message.capabilities = {};
                    for (var keys = Object.keys(object.capabilities), i = 0; i < keys.length; ++i) {
                        if (typeof object.capabilities[keys[i]] !== "object")
                            throw TypeError(".common.Capabilities.capabilities: object expected");
                        message.capabilities[keys[i]] = $root.common.Capability.fromObject(object.capabilities[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Capabilities message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Capabilities
             * @static
             * @param {common.Capabilities} message Capabilities
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Capabilities.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.capabilities = {};
                var keys2;
                if (message.capabilities && (keys2 = Object.keys(message.capabilities)).length) {
                    object.capabilities = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.capabilities[keys2[j]] = $root.common.Capability.toObject(message.capabilities[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this Capabilities to JSON.
             * @function toJSON
             * @memberof common.Capabilities
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Capabilities.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Capabilities;
        })();
    
        common.Capability = (function() {
    
            /**
             * Properties of a Capability.
             * @memberof common
             * @interface ICapability
             */
    
            /**
             * Constructs a new Capability.
             * @memberof common
             * @classdesc Represents a Capability.
             * @implements ICapability
             * @constructor
             * @param {common.ICapability=} [properties] Properties to set
             */
            function Capability(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new Capability instance using the specified properties.
             * @function create
             * @memberof common.Capability
             * @static
             * @param {common.ICapability=} [properties] Properties to set
             * @returns {common.Capability} Capability instance
             */
            Capability.create = function create(properties) {
                return new Capability(properties);
            };
    
            /**
             * Encodes the specified Capability message. Does not implicitly {@link common.Capability.verify|verify} messages.
             * @function encode
             * @memberof common.Capability
             * @static
             * @param {common.ICapability} message Capability message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Capability.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified Capability message, length delimited. Does not implicitly {@link common.Capability.verify|verify} messages.
             * @function encodeDelimited
             * @memberof common.Capability
             * @static
             * @param {common.ICapability} message Capability message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Capability.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Capability message from the specified reader or buffer.
             * @function decode
             * @memberof common.Capability
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {common.Capability} Capability
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Capability.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.common.Capability();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Capability message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof common.Capability
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {common.Capability} Capability
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Capability.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Capability message.
             * @function verify
             * @memberof common.Capability
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Capability.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a Capability message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof common.Capability
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {common.Capability} Capability
             */
            Capability.fromObject = function fromObject(object) {
                if (object instanceof $root.common.Capability)
                    return object;
                return new $root.common.Capability();
            };
    
            /**
             * Creates a plain object from a Capability message. Also converts values to other types if specified.
             * @function toObject
             * @memberof common.Capability
             * @static
             * @param {common.Capability} message Capability
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Capability.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this Capability to JSON.
             * @function toJSON
             * @memberof common.Capability
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Capability.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Capability;
        })();
    
        return common;
    })();
    
    $root.discovery = (function() {
    
        /**
         * Namespace discovery.
         * @exports discovery
         * @namespace
         */
        var discovery = {};
    
        discovery.Discovery = (function() {
    
            /**
             * Constructs a new Discovery service.
             * @memberof discovery
             * @classdesc Represents a Discovery
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Discovery(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (Discovery.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Discovery;
    
            /**
             * Creates new Discovery service using the specified rpc implementation.
             * @function create
             * @memberof discovery.Discovery
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Discovery} RPC service. Useful where requests and/or responses are streamed.
             */
            Discovery.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link discovery.Discovery#discover}.
             * @memberof discovery.Discovery
             * @typedef DiscoverCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {discovery.Response} [response] Response
             */
    
            /**
             * Calls Discover.
             * @function discover
             * @memberof discovery.Discovery
             * @instance
             * @param {discovery.ISignedRequest} request SignedRequest message or plain object
             * @param {discovery.Discovery.DiscoverCallback} callback Node-style callback called with the error, if any, and Response
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Discovery.prototype.discover = function discover(request, callback) {
                return this.rpcCall(discover, $root.discovery.SignedRequest, $root.discovery.Response, request, callback);
            }, "name", { value: "Discover" });
    
            /**
             * Calls Discover.
             * @function discover
             * @memberof discovery.Discovery
             * @instance
             * @param {discovery.ISignedRequest} request SignedRequest message or plain object
             * @returns {Promise<discovery.Response>} Promise
             * @variation 2
             */
    
            return Discovery;
        })();
    
        discovery.SignedRequest = (function() {
    
            /**
             * Properties of a SignedRequest.
             * @memberof discovery
             * @interface ISignedRequest
             * @property {Uint8Array|null} [payload] SignedRequest payload
             * @property {Uint8Array|null} [signature] SignedRequest signature
             */
    
            /**
             * Constructs a new SignedRequest.
             * @memberof discovery
             * @classdesc Represents a SignedRequest.
             * @implements ISignedRequest
             * @constructor
             * @param {discovery.ISignedRequest=} [properties] Properties to set
             */
            function SignedRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignedRequest payload.
             * @member {Uint8Array} payload
             * @memberof discovery.SignedRequest
             * @instance
             */
            SignedRequest.prototype.payload = $util.newBuffer([]);
    
            /**
             * SignedRequest signature.
             * @member {Uint8Array} signature
             * @memberof discovery.SignedRequest
             * @instance
             */
            SignedRequest.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new SignedRequest instance using the specified properties.
             * @function create
             * @memberof discovery.SignedRequest
             * @static
             * @param {discovery.ISignedRequest=} [properties] Properties to set
             * @returns {discovery.SignedRequest} SignedRequest instance
             */
            SignedRequest.create = function create(properties) {
                return new SignedRequest(properties);
            };
    
            /**
             * Encodes the specified SignedRequest message. Does not implicitly {@link discovery.SignedRequest.verify|verify} messages.
             * @function encode
             * @memberof discovery.SignedRequest
             * @static
             * @param {discovery.ISignedRequest} message SignedRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified SignedRequest message, length delimited. Does not implicitly {@link discovery.SignedRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.SignedRequest
             * @static
             * @param {discovery.ISignedRequest} message SignedRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignedRequest message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.SignedRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.SignedRequest} SignedRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.SignedRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignedRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.SignedRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.SignedRequest} SignedRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignedRequest message.
             * @function verify
             * @memberof discovery.SignedRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignedRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates a SignedRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.SignedRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.SignedRequest} SignedRequest
             */
            SignedRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.SignedRequest)
                    return object;
                var message = new $root.discovery.SignedRequest();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from a SignedRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.SignedRequest
             * @static
             * @param {discovery.SignedRequest} message SignedRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignedRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this SignedRequest to JSON.
             * @function toJSON
             * @memberof discovery.SignedRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignedRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignedRequest;
        })();
    
        discovery.Request = (function() {
    
            /**
             * Properties of a Request.
             * @memberof discovery
             * @interface IRequest
             * @property {discovery.IAuthInfo|null} [authentication] Request authentication
             * @property {Array.<discovery.IQuery>|null} [queries] Request queries
             */
    
            /**
             * Constructs a new Request.
             * @memberof discovery
             * @classdesc Represents a Request.
             * @implements IRequest
             * @constructor
             * @param {discovery.IRequest=} [properties] Properties to set
             */
            function Request(properties) {
                this.queries = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Request authentication.
             * @member {discovery.IAuthInfo|null|undefined} authentication
             * @memberof discovery.Request
             * @instance
             */
            Request.prototype.authentication = null;
    
            /**
             * Request queries.
             * @member {Array.<discovery.IQuery>} queries
             * @memberof discovery.Request
             * @instance
             */
            Request.prototype.queries = $util.emptyArray;
    
            /**
             * Creates a new Request instance using the specified properties.
             * @function create
             * @memberof discovery.Request
             * @static
             * @param {discovery.IRequest=} [properties] Properties to set
             * @returns {discovery.Request} Request instance
             */
            Request.create = function create(properties) {
                return new Request(properties);
            };
    
            /**
             * Encodes the specified Request message. Does not implicitly {@link discovery.Request.verify|verify} messages.
             * @function encode
             * @memberof discovery.Request
             * @static
             * @param {discovery.IRequest} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.authentication != null && message.hasOwnProperty("authentication"))
                    $root.discovery.AuthInfo.encode(message.authentication, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.queries != null && message.queries.length)
                    for (var i = 0; i < message.queries.length; ++i)
                        $root.discovery.Query.encode(message.queries[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Request message, length delimited. Does not implicitly {@link discovery.Request.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Request
             * @static
             * @param {discovery.IRequest} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Request message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Request();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.authentication = $root.discovery.AuthInfo.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.queries && message.queries.length))
                            message.queries = [];
                        message.queries.push($root.discovery.Query.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Request message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Request message.
             * @function verify
             * @memberof discovery.Request
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Request.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.authentication != null && message.hasOwnProperty("authentication")) {
                    var error = $root.discovery.AuthInfo.verify(message.authentication);
                    if (error)
                        return "authentication." + error;
                }
                if (message.queries != null && message.hasOwnProperty("queries")) {
                    if (!Array.isArray(message.queries))
                        return "queries: array expected";
                    for (var i = 0; i < message.queries.length; ++i) {
                        var error = $root.discovery.Query.verify(message.queries[i]);
                        if (error)
                            return "queries." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Request message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Request
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Request} Request
             */
            Request.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Request)
                    return object;
                var message = new $root.discovery.Request();
                if (object.authentication != null) {
                    if (typeof object.authentication !== "object")
                        throw TypeError(".discovery.Request.authentication: object expected");
                    message.authentication = $root.discovery.AuthInfo.fromObject(object.authentication);
                }
                if (object.queries) {
                    if (!Array.isArray(object.queries))
                        throw TypeError(".discovery.Request.queries: array expected");
                    message.queries = [];
                    for (var i = 0; i < object.queries.length; ++i) {
                        if (typeof object.queries[i] !== "object")
                            throw TypeError(".discovery.Request.queries: object expected");
                        message.queries[i] = $root.discovery.Query.fromObject(object.queries[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Request message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Request
             * @static
             * @param {discovery.Request} message Request
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Request.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.queries = [];
                if (options.defaults)
                    object.authentication = null;
                if (message.authentication != null && message.hasOwnProperty("authentication"))
                    object.authentication = $root.discovery.AuthInfo.toObject(message.authentication, options);
                if (message.queries && message.queries.length) {
                    object.queries = [];
                    for (var j = 0; j < message.queries.length; ++j)
                        object.queries[j] = $root.discovery.Query.toObject(message.queries[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Request to JSON.
             * @function toJSON
             * @memberof discovery.Request
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Request.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Request;
        })();
    
        discovery.Response = (function() {
    
            /**
             * Properties of a Response.
             * @memberof discovery
             * @interface IResponse
             * @property {Array.<discovery.IQueryResult>|null} [results] Response results
             */
    
            /**
             * Constructs a new Response.
             * @memberof discovery
             * @classdesc Represents a Response.
             * @implements IResponse
             * @constructor
             * @param {discovery.IResponse=} [properties] Properties to set
             */
            function Response(properties) {
                this.results = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Response results.
             * @member {Array.<discovery.IQueryResult>} results
             * @memberof discovery.Response
             * @instance
             */
            Response.prototype.results = $util.emptyArray;
    
            /**
             * Creates a new Response instance using the specified properties.
             * @function create
             * @memberof discovery.Response
             * @static
             * @param {discovery.IResponse=} [properties] Properties to set
             * @returns {discovery.Response} Response instance
             */
            Response.create = function create(properties) {
                return new Response(properties);
            };
    
            /**
             * Encodes the specified Response message. Does not implicitly {@link discovery.Response.verify|verify} messages.
             * @function encode
             * @memberof discovery.Response
             * @static
             * @param {discovery.IResponse} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.results != null && message.results.length)
                    for (var i = 0; i < message.results.length; ++i)
                        $root.discovery.QueryResult.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Response message, length delimited. Does not implicitly {@link discovery.Response.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Response
             * @static
             * @param {discovery.IResponse} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Response message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Response();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.results && message.results.length))
                            message.results = [];
                        message.results.push($root.discovery.QueryResult.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Response message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Response message.
             * @function verify
             * @memberof discovery.Response
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Response.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.results != null && message.hasOwnProperty("results")) {
                    if (!Array.isArray(message.results))
                        return "results: array expected";
                    for (var i = 0; i < message.results.length; ++i) {
                        var error = $root.discovery.QueryResult.verify(message.results[i]);
                        if (error)
                            return "results." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Response message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Response
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Response} Response
             */
            Response.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Response)
                    return object;
                var message = new $root.discovery.Response();
                if (object.results) {
                    if (!Array.isArray(object.results))
                        throw TypeError(".discovery.Response.results: array expected");
                    message.results = [];
                    for (var i = 0; i < object.results.length; ++i) {
                        if (typeof object.results[i] !== "object")
                            throw TypeError(".discovery.Response.results: object expected");
                        message.results[i] = $root.discovery.QueryResult.fromObject(object.results[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Response message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Response
             * @static
             * @param {discovery.Response} message Response
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Response.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.results = [];
                if (message.results && message.results.length) {
                    object.results = [];
                    for (var j = 0; j < message.results.length; ++j)
                        object.results[j] = $root.discovery.QueryResult.toObject(message.results[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Response to JSON.
             * @function toJSON
             * @memberof discovery.Response
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Response.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Response;
        })();
    
        discovery.AuthInfo = (function() {
    
            /**
             * Properties of an AuthInfo.
             * @memberof discovery
             * @interface IAuthInfo
             * @property {Uint8Array|null} [clientIdentity] AuthInfo clientIdentity
             * @property {Uint8Array|null} [clientTlsCertHash] AuthInfo clientTlsCertHash
             */
    
            /**
             * Constructs a new AuthInfo.
             * @memberof discovery
             * @classdesc Represents an AuthInfo.
             * @implements IAuthInfo
             * @constructor
             * @param {discovery.IAuthInfo=} [properties] Properties to set
             */
            function AuthInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AuthInfo clientIdentity.
             * @member {Uint8Array} clientIdentity
             * @memberof discovery.AuthInfo
             * @instance
             */
            AuthInfo.prototype.clientIdentity = $util.newBuffer([]);
    
            /**
             * AuthInfo clientTlsCertHash.
             * @member {Uint8Array} clientTlsCertHash
             * @memberof discovery.AuthInfo
             * @instance
             */
            AuthInfo.prototype.clientTlsCertHash = $util.newBuffer([]);
    
            /**
             * Creates a new AuthInfo instance using the specified properties.
             * @function create
             * @memberof discovery.AuthInfo
             * @static
             * @param {discovery.IAuthInfo=} [properties] Properties to set
             * @returns {discovery.AuthInfo} AuthInfo instance
             */
            AuthInfo.create = function create(properties) {
                return new AuthInfo(properties);
            };
    
            /**
             * Encodes the specified AuthInfo message. Does not implicitly {@link discovery.AuthInfo.verify|verify} messages.
             * @function encode
             * @memberof discovery.AuthInfo
             * @static
             * @param {discovery.IAuthInfo} message AuthInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.clientIdentity != null && message.hasOwnProperty("clientIdentity"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.clientIdentity);
                if (message.clientTlsCertHash != null && message.hasOwnProperty("clientTlsCertHash"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.clientTlsCertHash);
                return writer;
            };
    
            /**
             * Encodes the specified AuthInfo message, length delimited. Does not implicitly {@link discovery.AuthInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.AuthInfo
             * @static
             * @param {discovery.IAuthInfo} message AuthInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AuthInfo message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.AuthInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.AuthInfo} AuthInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.AuthInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.clientIdentity = reader.bytes();
                        break;
                    case 2:
                        message.clientTlsCertHash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AuthInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.AuthInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.AuthInfo} AuthInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AuthInfo message.
             * @function verify
             * @memberof discovery.AuthInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AuthInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.clientIdentity != null && message.hasOwnProperty("clientIdentity"))
                    if (!(message.clientIdentity && typeof message.clientIdentity.length === "number" || $util.isString(message.clientIdentity)))
                        return "clientIdentity: buffer expected";
                if (message.clientTlsCertHash != null && message.hasOwnProperty("clientTlsCertHash"))
                    if (!(message.clientTlsCertHash && typeof message.clientTlsCertHash.length === "number" || $util.isString(message.clientTlsCertHash)))
                        return "clientTlsCertHash: buffer expected";
                return null;
            };
    
            /**
             * Creates an AuthInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.AuthInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.AuthInfo} AuthInfo
             */
            AuthInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.AuthInfo)
                    return object;
                var message = new $root.discovery.AuthInfo();
                if (object.clientIdentity != null)
                    if (typeof object.clientIdentity === "string")
                        $util.base64.decode(object.clientIdentity, message.clientIdentity = $util.newBuffer($util.base64.length(object.clientIdentity)), 0);
                    else if (object.clientIdentity.length)
                        message.clientIdentity = object.clientIdentity;
                if (object.clientTlsCertHash != null)
                    if (typeof object.clientTlsCertHash === "string")
                        $util.base64.decode(object.clientTlsCertHash, message.clientTlsCertHash = $util.newBuffer($util.base64.length(object.clientTlsCertHash)), 0);
                    else if (object.clientTlsCertHash.length)
                        message.clientTlsCertHash = object.clientTlsCertHash;
                return message;
            };
    
            /**
             * Creates a plain object from an AuthInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.AuthInfo
             * @static
             * @param {discovery.AuthInfo} message AuthInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AuthInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.clientIdentity = "";
                    else {
                        object.clientIdentity = [];
                        if (options.bytes !== Array)
                            object.clientIdentity = $util.newBuffer(object.clientIdentity);
                    }
                    if (options.bytes === String)
                        object.clientTlsCertHash = "";
                    else {
                        object.clientTlsCertHash = [];
                        if (options.bytes !== Array)
                            object.clientTlsCertHash = $util.newBuffer(object.clientTlsCertHash);
                    }
                }
                if (message.clientIdentity != null && message.hasOwnProperty("clientIdentity"))
                    object.clientIdentity = options.bytes === String ? $util.base64.encode(message.clientIdentity, 0, message.clientIdentity.length) : options.bytes === Array ? Array.prototype.slice.call(message.clientIdentity) : message.clientIdentity;
                if (message.clientTlsCertHash != null && message.hasOwnProperty("clientTlsCertHash"))
                    object.clientTlsCertHash = options.bytes === String ? $util.base64.encode(message.clientTlsCertHash, 0, message.clientTlsCertHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.clientTlsCertHash) : message.clientTlsCertHash;
                return object;
            };
    
            /**
             * Converts this AuthInfo to JSON.
             * @function toJSON
             * @memberof discovery.AuthInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AuthInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AuthInfo;
        })();
    
        discovery.Query = (function() {
    
            /**
             * Properties of a Query.
             * @memberof discovery
             * @interface IQuery
             * @property {string|null} [channel] Query channel
             * @property {discovery.IConfigQuery|null} [configQuery] Query configQuery
             * @property {discovery.IPeerMembershipQuery|null} [peerQuery] Query peerQuery
             * @property {discovery.IChaincodeQuery|null} [ccQuery] Query ccQuery
             * @property {discovery.ILocalPeerQuery|null} [localPeers] Query localPeers
             */
    
            /**
             * Constructs a new Query.
             * @memberof discovery
             * @classdesc Represents a Query.
             * @implements IQuery
             * @constructor
             * @param {discovery.IQuery=} [properties] Properties to set
             */
            function Query(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Query channel.
             * @member {string} channel
             * @memberof discovery.Query
             * @instance
             */
            Query.prototype.channel = "";
    
            /**
             * Query configQuery.
             * @member {discovery.IConfigQuery|null|undefined} configQuery
             * @memberof discovery.Query
             * @instance
             */
            Query.prototype.configQuery = null;
    
            /**
             * Query peerQuery.
             * @member {discovery.IPeerMembershipQuery|null|undefined} peerQuery
             * @memberof discovery.Query
             * @instance
             */
            Query.prototype.peerQuery = null;
    
            /**
             * Query ccQuery.
             * @member {discovery.IChaincodeQuery|null|undefined} ccQuery
             * @memberof discovery.Query
             * @instance
             */
            Query.prototype.ccQuery = null;
    
            /**
             * Query localPeers.
             * @member {discovery.ILocalPeerQuery|null|undefined} localPeers
             * @memberof discovery.Query
             * @instance
             */
            Query.prototype.localPeers = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * Query query.
             * @member {"configQuery"|"peerQuery"|"ccQuery"|"localPeers"|undefined} query
             * @memberof discovery.Query
             * @instance
             */
            Object.defineProperty(Query.prototype, "query", {
                get: $util.oneOfGetter($oneOfFields = ["configQuery", "peerQuery", "ccQuery", "localPeers"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new Query instance using the specified properties.
             * @function create
             * @memberof discovery.Query
             * @static
             * @param {discovery.IQuery=} [properties] Properties to set
             * @returns {discovery.Query} Query instance
             */
            Query.create = function create(properties) {
                return new Query(properties);
            };
    
            /**
             * Encodes the specified Query message. Does not implicitly {@link discovery.Query.verify|verify} messages.
             * @function encode
             * @memberof discovery.Query
             * @static
             * @param {discovery.IQuery} message Query message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Query.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.configQuery != null && message.hasOwnProperty("configQuery"))
                    $root.discovery.ConfigQuery.encode(message.configQuery, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.peerQuery != null && message.hasOwnProperty("peerQuery"))
                    $root.discovery.PeerMembershipQuery.encode(message.peerQuery, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.ccQuery != null && message.hasOwnProperty("ccQuery"))
                    $root.discovery.ChaincodeQuery.encode(message.ccQuery, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.localPeers != null && message.hasOwnProperty("localPeers"))
                    $root.discovery.LocalPeerQuery.encode(message.localPeers, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Query message, length delimited. Does not implicitly {@link discovery.Query.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Query
             * @static
             * @param {discovery.IQuery} message Query message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Query.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Query message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Query
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Query} Query
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Query.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Query();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.configQuery = $root.discovery.ConfigQuery.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.peerQuery = $root.discovery.PeerMembershipQuery.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.ccQuery = $root.discovery.ChaincodeQuery.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.localPeers = $root.discovery.LocalPeerQuery.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Query message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Query
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Query} Query
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Query.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Query message.
             * @function verify
             * @memberof discovery.Query
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Query.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.configQuery != null && message.hasOwnProperty("configQuery")) {
                    properties.query = 1;
                    {
                        var error = $root.discovery.ConfigQuery.verify(message.configQuery);
                        if (error)
                            return "configQuery." + error;
                    }
                }
                if (message.peerQuery != null && message.hasOwnProperty("peerQuery")) {
                    if (properties.query === 1)
                        return "query: multiple values";
                    properties.query = 1;
                    {
                        var error = $root.discovery.PeerMembershipQuery.verify(message.peerQuery);
                        if (error)
                            return "peerQuery." + error;
                    }
                }
                if (message.ccQuery != null && message.hasOwnProperty("ccQuery")) {
                    if (properties.query === 1)
                        return "query: multiple values";
                    properties.query = 1;
                    {
                        var error = $root.discovery.ChaincodeQuery.verify(message.ccQuery);
                        if (error)
                            return "ccQuery." + error;
                    }
                }
                if (message.localPeers != null && message.hasOwnProperty("localPeers")) {
                    if (properties.query === 1)
                        return "query: multiple values";
                    properties.query = 1;
                    {
                        var error = $root.discovery.LocalPeerQuery.verify(message.localPeers);
                        if (error)
                            return "localPeers." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Query message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Query
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Query} Query
             */
            Query.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Query)
                    return object;
                var message = new $root.discovery.Query();
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.configQuery != null) {
                    if (typeof object.configQuery !== "object")
                        throw TypeError(".discovery.Query.configQuery: object expected");
                    message.configQuery = $root.discovery.ConfigQuery.fromObject(object.configQuery);
                }
                if (object.peerQuery != null) {
                    if (typeof object.peerQuery !== "object")
                        throw TypeError(".discovery.Query.peerQuery: object expected");
                    message.peerQuery = $root.discovery.PeerMembershipQuery.fromObject(object.peerQuery);
                }
                if (object.ccQuery != null) {
                    if (typeof object.ccQuery !== "object")
                        throw TypeError(".discovery.Query.ccQuery: object expected");
                    message.ccQuery = $root.discovery.ChaincodeQuery.fromObject(object.ccQuery);
                }
                if (object.localPeers != null) {
                    if (typeof object.localPeers !== "object")
                        throw TypeError(".discovery.Query.localPeers: object expected");
                    message.localPeers = $root.discovery.LocalPeerQuery.fromObject(object.localPeers);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Query message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Query
             * @static
             * @param {discovery.Query} message Query
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Query.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.channel = "";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.configQuery != null && message.hasOwnProperty("configQuery")) {
                    object.configQuery = $root.discovery.ConfigQuery.toObject(message.configQuery, options);
                    if (options.oneofs)
                        object.query = "configQuery";
                }
                if (message.peerQuery != null && message.hasOwnProperty("peerQuery")) {
                    object.peerQuery = $root.discovery.PeerMembershipQuery.toObject(message.peerQuery, options);
                    if (options.oneofs)
                        object.query = "peerQuery";
                }
                if (message.ccQuery != null && message.hasOwnProperty("ccQuery")) {
                    object.ccQuery = $root.discovery.ChaincodeQuery.toObject(message.ccQuery, options);
                    if (options.oneofs)
                        object.query = "ccQuery";
                }
                if (message.localPeers != null && message.hasOwnProperty("localPeers")) {
                    object.localPeers = $root.discovery.LocalPeerQuery.toObject(message.localPeers, options);
                    if (options.oneofs)
                        object.query = "localPeers";
                }
                return object;
            };
    
            /**
             * Converts this Query to JSON.
             * @function toJSON
             * @memberof discovery.Query
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Query.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Query;
        })();
    
        discovery.QueryResult = (function() {
    
            /**
             * Properties of a QueryResult.
             * @memberof discovery
             * @interface IQueryResult
             * @property {discovery.IError|null} [error] QueryResult error
             * @property {discovery.IConfigResult|null} [configResult] QueryResult configResult
             * @property {discovery.IChaincodeQueryResult|null} [ccQueryRes] QueryResult ccQueryRes
             * @property {discovery.IPeerMembershipResult|null} [members] QueryResult members
             */
    
            /**
             * Constructs a new QueryResult.
             * @memberof discovery
             * @classdesc Represents a QueryResult.
             * @implements IQueryResult
             * @constructor
             * @param {discovery.IQueryResult=} [properties] Properties to set
             */
            function QueryResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryResult error.
             * @member {discovery.IError|null|undefined} error
             * @memberof discovery.QueryResult
             * @instance
             */
            QueryResult.prototype.error = null;
    
            /**
             * QueryResult configResult.
             * @member {discovery.IConfigResult|null|undefined} configResult
             * @memberof discovery.QueryResult
             * @instance
             */
            QueryResult.prototype.configResult = null;
    
            /**
             * QueryResult ccQueryRes.
             * @member {discovery.IChaincodeQueryResult|null|undefined} ccQueryRes
             * @memberof discovery.QueryResult
             * @instance
             */
            QueryResult.prototype.ccQueryRes = null;
    
            /**
             * QueryResult members.
             * @member {discovery.IPeerMembershipResult|null|undefined} members
             * @memberof discovery.QueryResult
             * @instance
             */
            QueryResult.prototype.members = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * QueryResult result.
             * @member {"error"|"configResult"|"ccQueryRes"|"members"|undefined} result
             * @memberof discovery.QueryResult
             * @instance
             */
            Object.defineProperty(QueryResult.prototype, "result", {
                get: $util.oneOfGetter($oneOfFields = ["error", "configResult", "ccQueryRes", "members"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new QueryResult instance using the specified properties.
             * @function create
             * @memberof discovery.QueryResult
             * @static
             * @param {discovery.IQueryResult=} [properties] Properties to set
             * @returns {discovery.QueryResult} QueryResult instance
             */
            QueryResult.create = function create(properties) {
                return new QueryResult(properties);
            };
    
            /**
             * Encodes the specified QueryResult message. Does not implicitly {@link discovery.QueryResult.verify|verify} messages.
             * @function encode
             * @memberof discovery.QueryResult
             * @static
             * @param {discovery.IQueryResult} message QueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    $root.discovery.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.configResult != null && message.hasOwnProperty("configResult"))
                    $root.discovery.ConfigResult.encode(message.configResult, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.ccQueryRes != null && message.hasOwnProperty("ccQueryRes"))
                    $root.discovery.ChaincodeQueryResult.encode(message.ccQueryRes, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.members != null && message.hasOwnProperty("members"))
                    $root.discovery.PeerMembershipResult.encode(message.members, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified QueryResult message, length delimited. Does not implicitly {@link discovery.QueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.QueryResult
             * @static
             * @param {discovery.IQueryResult} message QueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.QueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.QueryResult} QueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.QueryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = $root.discovery.Error.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.configResult = $root.discovery.ConfigResult.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.ccQueryRes = $root.discovery.ChaincodeQueryResult.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.members = $root.discovery.PeerMembershipResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.QueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.QueryResult} QueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryResult message.
             * @function verify
             * @memberof discovery.QueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    properties.result = 1;
                    {
                        var error = $root.discovery.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                }
                if (message.configResult != null && message.hasOwnProperty("configResult")) {
                    if (properties.result === 1)
                        return "result: multiple values";
                    properties.result = 1;
                    {
                        var error = $root.discovery.ConfigResult.verify(message.configResult);
                        if (error)
                            return "configResult." + error;
                    }
                }
                if (message.ccQueryRes != null && message.hasOwnProperty("ccQueryRes")) {
                    if (properties.result === 1)
                        return "result: multiple values";
                    properties.result = 1;
                    {
                        var error = $root.discovery.ChaincodeQueryResult.verify(message.ccQueryRes);
                        if (error)
                            return "ccQueryRes." + error;
                    }
                }
                if (message.members != null && message.hasOwnProperty("members")) {
                    if (properties.result === 1)
                        return "result: multiple values";
                    properties.result = 1;
                    {
                        var error = $root.discovery.PeerMembershipResult.verify(message.members);
                        if (error)
                            return "members." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a QueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.QueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.QueryResult} QueryResult
             */
            QueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.QueryResult)
                    return object;
                var message = new $root.discovery.QueryResult();
                if (object.error != null) {
                    if (typeof object.error !== "object")
                        throw TypeError(".discovery.QueryResult.error: object expected");
                    message.error = $root.discovery.Error.fromObject(object.error);
                }
                if (object.configResult != null) {
                    if (typeof object.configResult !== "object")
                        throw TypeError(".discovery.QueryResult.configResult: object expected");
                    message.configResult = $root.discovery.ConfigResult.fromObject(object.configResult);
                }
                if (object.ccQueryRes != null) {
                    if (typeof object.ccQueryRes !== "object")
                        throw TypeError(".discovery.QueryResult.ccQueryRes: object expected");
                    message.ccQueryRes = $root.discovery.ChaincodeQueryResult.fromObject(object.ccQueryRes);
                }
                if (object.members != null) {
                    if (typeof object.members !== "object")
                        throw TypeError(".discovery.QueryResult.members: object expected");
                    message.members = $root.discovery.PeerMembershipResult.fromObject(object.members);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.QueryResult
             * @static
             * @param {discovery.QueryResult} message QueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.error != null && message.hasOwnProperty("error")) {
                    object.error = $root.discovery.Error.toObject(message.error, options);
                    if (options.oneofs)
                        object.result = "error";
                }
                if (message.configResult != null && message.hasOwnProperty("configResult")) {
                    object.configResult = $root.discovery.ConfigResult.toObject(message.configResult, options);
                    if (options.oneofs)
                        object.result = "configResult";
                }
                if (message.ccQueryRes != null && message.hasOwnProperty("ccQueryRes")) {
                    object.ccQueryRes = $root.discovery.ChaincodeQueryResult.toObject(message.ccQueryRes, options);
                    if (options.oneofs)
                        object.result = "ccQueryRes";
                }
                if (message.members != null && message.hasOwnProperty("members")) {
                    object.members = $root.discovery.PeerMembershipResult.toObject(message.members, options);
                    if (options.oneofs)
                        object.result = "members";
                }
                return object;
            };
    
            /**
             * Converts this QueryResult to JSON.
             * @function toJSON
             * @memberof discovery.QueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryResult;
        })();
    
        discovery.ConfigQuery = (function() {
    
            /**
             * Properties of a ConfigQuery.
             * @memberof discovery
             * @interface IConfigQuery
             */
    
            /**
             * Constructs a new ConfigQuery.
             * @memberof discovery
             * @classdesc Represents a ConfigQuery.
             * @implements IConfigQuery
             * @constructor
             * @param {discovery.IConfigQuery=} [properties] Properties to set
             */
            function ConfigQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ConfigQuery instance using the specified properties.
             * @function create
             * @memberof discovery.ConfigQuery
             * @static
             * @param {discovery.IConfigQuery=} [properties] Properties to set
             * @returns {discovery.ConfigQuery} ConfigQuery instance
             */
            ConfigQuery.create = function create(properties) {
                return new ConfigQuery(properties);
            };
    
            /**
             * Encodes the specified ConfigQuery message. Does not implicitly {@link discovery.ConfigQuery.verify|verify} messages.
             * @function encode
             * @memberof discovery.ConfigQuery
             * @static
             * @param {discovery.IConfigQuery} message ConfigQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigQuery message, length delimited. Does not implicitly {@link discovery.ConfigQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.ConfigQuery
             * @static
             * @param {discovery.IConfigQuery} message ConfigQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigQuery message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.ConfigQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.ConfigQuery} ConfigQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.ConfigQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.ConfigQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.ConfigQuery} ConfigQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigQuery message.
             * @function verify
             * @memberof discovery.ConfigQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a ConfigQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.ConfigQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.ConfigQuery} ConfigQuery
             */
            ConfigQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.ConfigQuery)
                    return object;
                return new $root.discovery.ConfigQuery();
            };
    
            /**
             * Creates a plain object from a ConfigQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.ConfigQuery
             * @static
             * @param {discovery.ConfigQuery} message ConfigQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigQuery.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this ConfigQuery to JSON.
             * @function toJSON
             * @memberof discovery.ConfigQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigQuery;
        })();
    
        discovery.ConfigResult = (function() {
    
            /**
             * Properties of a ConfigResult.
             * @memberof discovery
             * @interface IConfigResult
             * @property {Object.<string,msp.IFabricMSPConfig>|null} [msps] ConfigResult msps
             * @property {Object.<string,discovery.IEndpoints>|null} [orderers] ConfigResult orderers
             */
    
            /**
             * Constructs a new ConfigResult.
             * @memberof discovery
             * @classdesc Represents a ConfigResult.
             * @implements IConfigResult
             * @constructor
             * @param {discovery.IConfigResult=} [properties] Properties to set
             */
            function ConfigResult(properties) {
                this.msps = {};
                this.orderers = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigResult msps.
             * @member {Object.<string,msp.IFabricMSPConfig>} msps
             * @memberof discovery.ConfigResult
             * @instance
             */
            ConfigResult.prototype.msps = $util.emptyObject;
    
            /**
             * ConfigResult orderers.
             * @member {Object.<string,discovery.IEndpoints>} orderers
             * @memberof discovery.ConfigResult
             * @instance
             */
            ConfigResult.prototype.orderers = $util.emptyObject;
    
            /**
             * Creates a new ConfigResult instance using the specified properties.
             * @function create
             * @memberof discovery.ConfigResult
             * @static
             * @param {discovery.IConfigResult=} [properties] Properties to set
             * @returns {discovery.ConfigResult} ConfigResult instance
             */
            ConfigResult.create = function create(properties) {
                return new ConfigResult(properties);
            };
    
            /**
             * Encodes the specified ConfigResult message. Does not implicitly {@link discovery.ConfigResult.verify|verify} messages.
             * @function encode
             * @memberof discovery.ConfigResult
             * @static
             * @param {discovery.IConfigResult} message ConfigResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.msps != null && message.hasOwnProperty("msps"))
                    for (var keys = Object.keys(message.msps), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.msp.FabricMSPConfig.encode(message.msps[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.orderers != null && message.hasOwnProperty("orderers"))
                    for (var keys = Object.keys(message.orderers), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.discovery.Endpoints.encode(message.orderers[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified ConfigResult message, length delimited. Does not implicitly {@link discovery.ConfigResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.ConfigResult
             * @static
             * @param {discovery.IConfigResult} message ConfigResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigResult message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.ConfigResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.ConfigResult} ConfigResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.ConfigResult(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.msps === $util.emptyObject)
                            message.msps = {};
                        key = reader.string();
                        reader.pos++;
                        message.msps[key] = $root.msp.FabricMSPConfig.decode(reader, reader.uint32());
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.orderers === $util.emptyObject)
                            message.orderers = {};
                        key = reader.string();
                        reader.pos++;
                        message.orderers[key] = $root.discovery.Endpoints.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.ConfigResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.ConfigResult} ConfigResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigResult message.
             * @function verify
             * @memberof discovery.ConfigResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.msps != null && message.hasOwnProperty("msps")) {
                    if (!$util.isObject(message.msps))
                        return "msps: object expected";
                    var key = Object.keys(message.msps);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.msp.FabricMSPConfig.verify(message.msps[key[i]]);
                        if (error)
                            return "msps." + error;
                    }
                }
                if (message.orderers != null && message.hasOwnProperty("orderers")) {
                    if (!$util.isObject(message.orderers))
                        return "orderers: object expected";
                    var key = Object.keys(message.orderers);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.discovery.Endpoints.verify(message.orderers[key[i]]);
                        if (error)
                            return "orderers." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ConfigResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.ConfigResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.ConfigResult} ConfigResult
             */
            ConfigResult.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.ConfigResult)
                    return object;
                var message = new $root.discovery.ConfigResult();
                if (object.msps) {
                    if (typeof object.msps !== "object")
                        throw TypeError(".discovery.ConfigResult.msps: object expected");
                    message.msps = {};
                    for (var keys = Object.keys(object.msps), i = 0; i < keys.length; ++i) {
                        if (typeof object.msps[keys[i]] !== "object")
                            throw TypeError(".discovery.ConfigResult.msps: object expected");
                        message.msps[keys[i]] = $root.msp.FabricMSPConfig.fromObject(object.msps[keys[i]]);
                    }
                }
                if (object.orderers) {
                    if (typeof object.orderers !== "object")
                        throw TypeError(".discovery.ConfigResult.orderers: object expected");
                    message.orderers = {};
                    for (var keys = Object.keys(object.orderers), i = 0; i < keys.length; ++i) {
                        if (typeof object.orderers[keys[i]] !== "object")
                            throw TypeError(".discovery.ConfigResult.orderers: object expected");
                        message.orderers[keys[i]] = $root.discovery.Endpoints.fromObject(object.orderers[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.ConfigResult
             * @static
             * @param {discovery.ConfigResult} message ConfigResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults) {
                    object.msps = {};
                    object.orderers = {};
                }
                var keys2;
                if (message.msps && (keys2 = Object.keys(message.msps)).length) {
                    object.msps = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.msps[keys2[j]] = $root.msp.FabricMSPConfig.toObject(message.msps[keys2[j]], options);
                }
                if (message.orderers && (keys2 = Object.keys(message.orderers)).length) {
                    object.orderers = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.orderers[keys2[j]] = $root.discovery.Endpoints.toObject(message.orderers[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this ConfigResult to JSON.
             * @function toJSON
             * @memberof discovery.ConfigResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigResult;
        })();
    
        discovery.PeerMembershipQuery = (function() {
    
            /**
             * Properties of a PeerMembershipQuery.
             * @memberof discovery
             * @interface IPeerMembershipQuery
             * @property {discovery.IChaincodeInterest|null} [filter] PeerMembershipQuery filter
             */
    
            /**
             * Constructs a new PeerMembershipQuery.
             * @memberof discovery
             * @classdesc Represents a PeerMembershipQuery.
             * @implements IPeerMembershipQuery
             * @constructor
             * @param {discovery.IPeerMembershipQuery=} [properties] Properties to set
             */
            function PeerMembershipQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PeerMembershipQuery filter.
             * @member {discovery.IChaincodeInterest|null|undefined} filter
             * @memberof discovery.PeerMembershipQuery
             * @instance
             */
            PeerMembershipQuery.prototype.filter = null;
    
            /**
             * Creates a new PeerMembershipQuery instance using the specified properties.
             * @function create
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {discovery.IPeerMembershipQuery=} [properties] Properties to set
             * @returns {discovery.PeerMembershipQuery} PeerMembershipQuery instance
             */
            PeerMembershipQuery.create = function create(properties) {
                return new PeerMembershipQuery(properties);
            };
    
            /**
             * Encodes the specified PeerMembershipQuery message. Does not implicitly {@link discovery.PeerMembershipQuery.verify|verify} messages.
             * @function encode
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {discovery.IPeerMembershipQuery} message PeerMembershipQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerMembershipQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.filter != null && message.hasOwnProperty("filter"))
                    $root.discovery.ChaincodeInterest.encode(message.filter, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PeerMembershipQuery message, length delimited. Does not implicitly {@link discovery.PeerMembershipQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {discovery.IPeerMembershipQuery} message PeerMembershipQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerMembershipQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PeerMembershipQuery message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.PeerMembershipQuery} PeerMembershipQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerMembershipQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.PeerMembershipQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.filter = $root.discovery.ChaincodeInterest.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PeerMembershipQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.PeerMembershipQuery} PeerMembershipQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerMembershipQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PeerMembershipQuery message.
             * @function verify
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerMembershipQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.filter != null && message.hasOwnProperty("filter")) {
                    var error = $root.discovery.ChaincodeInterest.verify(message.filter);
                    if (error)
                        return "filter." + error;
                }
                return null;
            };
    
            /**
             * Creates a PeerMembershipQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.PeerMembershipQuery} PeerMembershipQuery
             */
            PeerMembershipQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.PeerMembershipQuery)
                    return object;
                var message = new $root.discovery.PeerMembershipQuery();
                if (object.filter != null) {
                    if (typeof object.filter !== "object")
                        throw TypeError(".discovery.PeerMembershipQuery.filter: object expected");
                    message.filter = $root.discovery.ChaincodeInterest.fromObject(object.filter);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PeerMembershipQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.PeerMembershipQuery
             * @static
             * @param {discovery.PeerMembershipQuery} message PeerMembershipQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerMembershipQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.filter = null;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = $root.discovery.ChaincodeInterest.toObject(message.filter, options);
                return object;
            };
    
            /**
             * Converts this PeerMembershipQuery to JSON.
             * @function toJSON
             * @memberof discovery.PeerMembershipQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerMembershipQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PeerMembershipQuery;
        })();
    
        discovery.PeerMembershipResult = (function() {
    
            /**
             * Properties of a PeerMembershipResult.
             * @memberof discovery
             * @interface IPeerMembershipResult
             * @property {Object.<string,discovery.IPeers>|null} [peersByOrg] PeerMembershipResult peersByOrg
             */
    
            /**
             * Constructs a new PeerMembershipResult.
             * @memberof discovery
             * @classdesc Represents a PeerMembershipResult.
             * @implements IPeerMembershipResult
             * @constructor
             * @param {discovery.IPeerMembershipResult=} [properties] Properties to set
             */
            function PeerMembershipResult(properties) {
                this.peersByOrg = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PeerMembershipResult peersByOrg.
             * @member {Object.<string,discovery.IPeers>} peersByOrg
             * @memberof discovery.PeerMembershipResult
             * @instance
             */
            PeerMembershipResult.prototype.peersByOrg = $util.emptyObject;
    
            /**
             * Creates a new PeerMembershipResult instance using the specified properties.
             * @function create
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {discovery.IPeerMembershipResult=} [properties] Properties to set
             * @returns {discovery.PeerMembershipResult} PeerMembershipResult instance
             */
            PeerMembershipResult.create = function create(properties) {
                return new PeerMembershipResult(properties);
            };
    
            /**
             * Encodes the specified PeerMembershipResult message. Does not implicitly {@link discovery.PeerMembershipResult.verify|verify} messages.
             * @function encode
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {discovery.IPeerMembershipResult} message PeerMembershipResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerMembershipResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peersByOrg != null && message.hasOwnProperty("peersByOrg"))
                    for (var keys = Object.keys(message.peersByOrg), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.discovery.Peers.encode(message.peersByOrg[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified PeerMembershipResult message, length delimited. Does not implicitly {@link discovery.PeerMembershipResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {discovery.IPeerMembershipResult} message PeerMembershipResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerMembershipResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PeerMembershipResult message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.PeerMembershipResult} PeerMembershipResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerMembershipResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.PeerMembershipResult(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.peersByOrg === $util.emptyObject)
                            message.peersByOrg = {};
                        key = reader.string();
                        reader.pos++;
                        message.peersByOrg[key] = $root.discovery.Peers.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PeerMembershipResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.PeerMembershipResult} PeerMembershipResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerMembershipResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PeerMembershipResult message.
             * @function verify
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerMembershipResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peersByOrg != null && message.hasOwnProperty("peersByOrg")) {
                    if (!$util.isObject(message.peersByOrg))
                        return "peersByOrg: object expected";
                    var key = Object.keys(message.peersByOrg);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.discovery.Peers.verify(message.peersByOrg[key[i]]);
                        if (error)
                            return "peersByOrg." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a PeerMembershipResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.PeerMembershipResult} PeerMembershipResult
             */
            PeerMembershipResult.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.PeerMembershipResult)
                    return object;
                var message = new $root.discovery.PeerMembershipResult();
                if (object.peersByOrg) {
                    if (typeof object.peersByOrg !== "object")
                        throw TypeError(".discovery.PeerMembershipResult.peersByOrg: object expected");
                    message.peersByOrg = {};
                    for (var keys = Object.keys(object.peersByOrg), i = 0; i < keys.length; ++i) {
                        if (typeof object.peersByOrg[keys[i]] !== "object")
                            throw TypeError(".discovery.PeerMembershipResult.peersByOrg: object expected");
                        message.peersByOrg[keys[i]] = $root.discovery.Peers.fromObject(object.peersByOrg[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PeerMembershipResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.PeerMembershipResult
             * @static
             * @param {discovery.PeerMembershipResult} message PeerMembershipResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerMembershipResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.peersByOrg = {};
                var keys2;
                if (message.peersByOrg && (keys2 = Object.keys(message.peersByOrg)).length) {
                    object.peersByOrg = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.peersByOrg[keys2[j]] = $root.discovery.Peers.toObject(message.peersByOrg[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this PeerMembershipResult to JSON.
             * @function toJSON
             * @memberof discovery.PeerMembershipResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerMembershipResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PeerMembershipResult;
        })();
    
        discovery.ChaincodeQuery = (function() {
    
            /**
             * Properties of a ChaincodeQuery.
             * @memberof discovery
             * @interface IChaincodeQuery
             * @property {Array.<discovery.IChaincodeInterest>|null} [interests] ChaincodeQuery interests
             */
    
            /**
             * Constructs a new ChaincodeQuery.
             * @memberof discovery
             * @classdesc Represents a ChaincodeQuery.
             * @implements IChaincodeQuery
             * @constructor
             * @param {discovery.IChaincodeQuery=} [properties] Properties to set
             */
            function ChaincodeQuery(properties) {
                this.interests = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeQuery interests.
             * @member {Array.<discovery.IChaincodeInterest>} interests
             * @memberof discovery.ChaincodeQuery
             * @instance
             */
            ChaincodeQuery.prototype.interests = $util.emptyArray;
    
            /**
             * Creates a new ChaincodeQuery instance using the specified properties.
             * @function create
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {discovery.IChaincodeQuery=} [properties] Properties to set
             * @returns {discovery.ChaincodeQuery} ChaincodeQuery instance
             */
            ChaincodeQuery.create = function create(properties) {
                return new ChaincodeQuery(properties);
            };
    
            /**
             * Encodes the specified ChaincodeQuery message. Does not implicitly {@link discovery.ChaincodeQuery.verify|verify} messages.
             * @function encode
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {discovery.IChaincodeQuery} message ChaincodeQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.interests != null && message.interests.length)
                    for (var i = 0; i < message.interests.length; ++i)
                        $root.discovery.ChaincodeInterest.encode(message.interests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeQuery message, length delimited. Does not implicitly {@link discovery.ChaincodeQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {discovery.IChaincodeQuery} message ChaincodeQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeQuery message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.ChaincodeQuery} ChaincodeQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.ChaincodeQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.interests && message.interests.length))
                            message.interests = [];
                        message.interests.push($root.discovery.ChaincodeInterest.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.ChaincodeQuery} ChaincodeQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeQuery message.
             * @function verify
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.interests != null && message.hasOwnProperty("interests")) {
                    if (!Array.isArray(message.interests))
                        return "interests: array expected";
                    for (var i = 0; i < message.interests.length; ++i) {
                        var error = $root.discovery.ChaincodeInterest.verify(message.interests[i]);
                        if (error)
                            return "interests." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.ChaincodeQuery} ChaincodeQuery
             */
            ChaincodeQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.ChaincodeQuery)
                    return object;
                var message = new $root.discovery.ChaincodeQuery();
                if (object.interests) {
                    if (!Array.isArray(object.interests))
                        throw TypeError(".discovery.ChaincodeQuery.interests: array expected");
                    message.interests = [];
                    for (var i = 0; i < object.interests.length; ++i) {
                        if (typeof object.interests[i] !== "object")
                            throw TypeError(".discovery.ChaincodeQuery.interests: object expected");
                        message.interests[i] = $root.discovery.ChaincodeInterest.fromObject(object.interests[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.ChaincodeQuery
             * @static
             * @param {discovery.ChaincodeQuery} message ChaincodeQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.interests = [];
                if (message.interests && message.interests.length) {
                    object.interests = [];
                    for (var j = 0; j < message.interests.length; ++j)
                        object.interests[j] = $root.discovery.ChaincodeInterest.toObject(message.interests[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeQuery to JSON.
             * @function toJSON
             * @memberof discovery.ChaincodeQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeQuery;
        })();
    
        discovery.ChaincodeInterest = (function() {
    
            /**
             * Properties of a ChaincodeInterest.
             * @memberof discovery
             * @interface IChaincodeInterest
             * @property {Array.<discovery.IChaincodeCall>|null} [chaincodes] ChaincodeInterest chaincodes
             */
    
            /**
             * Constructs a new ChaincodeInterest.
             * @memberof discovery
             * @classdesc Represents a ChaincodeInterest.
             * @implements IChaincodeInterest
             * @constructor
             * @param {discovery.IChaincodeInterest=} [properties] Properties to set
             */
            function ChaincodeInterest(properties) {
                this.chaincodes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeInterest chaincodes.
             * @member {Array.<discovery.IChaincodeCall>} chaincodes
             * @memberof discovery.ChaincodeInterest
             * @instance
             */
            ChaincodeInterest.prototype.chaincodes = $util.emptyArray;
    
            /**
             * Creates a new ChaincodeInterest instance using the specified properties.
             * @function create
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {discovery.IChaincodeInterest=} [properties] Properties to set
             * @returns {discovery.ChaincodeInterest} ChaincodeInterest instance
             */
            ChaincodeInterest.create = function create(properties) {
                return new ChaincodeInterest(properties);
            };
    
            /**
             * Encodes the specified ChaincodeInterest message. Does not implicitly {@link discovery.ChaincodeInterest.verify|verify} messages.
             * @function encode
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {discovery.IChaincodeInterest} message ChaincodeInterest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInterest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodes != null && message.chaincodes.length)
                    for (var i = 0; i < message.chaincodes.length; ++i)
                        $root.discovery.ChaincodeCall.encode(message.chaincodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeInterest message, length delimited. Does not implicitly {@link discovery.ChaincodeInterest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {discovery.IChaincodeInterest} message ChaincodeInterest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInterest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeInterest message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.ChaincodeInterest} ChaincodeInterest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInterest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.ChaincodeInterest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.chaincodes && message.chaincodes.length))
                            message.chaincodes = [];
                        message.chaincodes.push($root.discovery.ChaincodeCall.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeInterest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.ChaincodeInterest} ChaincodeInterest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInterest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeInterest message.
             * @function verify
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeInterest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodes != null && message.hasOwnProperty("chaincodes")) {
                    if (!Array.isArray(message.chaincodes))
                        return "chaincodes: array expected";
                    for (var i = 0; i < message.chaincodes.length; ++i) {
                        var error = $root.discovery.ChaincodeCall.verify(message.chaincodes[i]);
                        if (error)
                            return "chaincodes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeInterest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.ChaincodeInterest} ChaincodeInterest
             */
            ChaincodeInterest.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.ChaincodeInterest)
                    return object;
                var message = new $root.discovery.ChaincodeInterest();
                if (object.chaincodes) {
                    if (!Array.isArray(object.chaincodes))
                        throw TypeError(".discovery.ChaincodeInterest.chaincodes: array expected");
                    message.chaincodes = [];
                    for (var i = 0; i < object.chaincodes.length; ++i) {
                        if (typeof object.chaincodes[i] !== "object")
                            throw TypeError(".discovery.ChaincodeInterest.chaincodes: object expected");
                        message.chaincodes[i] = $root.discovery.ChaincodeCall.fromObject(object.chaincodes[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeInterest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.ChaincodeInterest
             * @static
             * @param {discovery.ChaincodeInterest} message ChaincodeInterest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeInterest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.chaincodes = [];
                if (message.chaincodes && message.chaincodes.length) {
                    object.chaincodes = [];
                    for (var j = 0; j < message.chaincodes.length; ++j)
                        object.chaincodes[j] = $root.discovery.ChaincodeCall.toObject(message.chaincodes[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeInterest to JSON.
             * @function toJSON
             * @memberof discovery.ChaincodeInterest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeInterest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeInterest;
        })();
    
        discovery.ChaincodeCall = (function() {
    
            /**
             * Properties of a ChaincodeCall.
             * @memberof discovery
             * @interface IChaincodeCall
             * @property {string|null} [name] ChaincodeCall name
             * @property {Array.<string>|null} [collectionNames] ChaincodeCall collectionNames
             */
    
            /**
             * Constructs a new ChaincodeCall.
             * @memberof discovery
             * @classdesc Represents a ChaincodeCall.
             * @implements IChaincodeCall
             * @constructor
             * @param {discovery.IChaincodeCall=} [properties] Properties to set
             */
            function ChaincodeCall(properties) {
                this.collectionNames = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeCall name.
             * @member {string} name
             * @memberof discovery.ChaincodeCall
             * @instance
             */
            ChaincodeCall.prototype.name = "";
    
            /**
             * ChaincodeCall collectionNames.
             * @member {Array.<string>} collectionNames
             * @memberof discovery.ChaincodeCall
             * @instance
             */
            ChaincodeCall.prototype.collectionNames = $util.emptyArray;
    
            /**
             * Creates a new ChaincodeCall instance using the specified properties.
             * @function create
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {discovery.IChaincodeCall=} [properties] Properties to set
             * @returns {discovery.ChaincodeCall} ChaincodeCall instance
             */
            ChaincodeCall.create = function create(properties) {
                return new ChaincodeCall(properties);
            };
    
            /**
             * Encodes the specified ChaincodeCall message. Does not implicitly {@link discovery.ChaincodeCall.verify|verify} messages.
             * @function encode
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {discovery.IChaincodeCall} message ChaincodeCall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeCall.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.collectionNames != null && message.collectionNames.length)
                    for (var i = 0; i < message.collectionNames.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.collectionNames[i]);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeCall message, length delimited. Does not implicitly {@link discovery.ChaincodeCall.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {discovery.IChaincodeCall} message ChaincodeCall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeCall.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeCall message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.ChaincodeCall} ChaincodeCall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeCall.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.ChaincodeCall();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.collectionNames && message.collectionNames.length))
                            message.collectionNames = [];
                        message.collectionNames.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeCall message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.ChaincodeCall} ChaincodeCall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeCall.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeCall message.
             * @function verify
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeCall.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.collectionNames != null && message.hasOwnProperty("collectionNames")) {
                    if (!Array.isArray(message.collectionNames))
                        return "collectionNames: array expected";
                    for (var i = 0; i < message.collectionNames.length; ++i)
                        if (!$util.isString(message.collectionNames[i]))
                            return "collectionNames: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeCall message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.ChaincodeCall} ChaincodeCall
             */
            ChaincodeCall.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.ChaincodeCall)
                    return object;
                var message = new $root.discovery.ChaincodeCall();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.collectionNames) {
                    if (!Array.isArray(object.collectionNames))
                        throw TypeError(".discovery.ChaincodeCall.collectionNames: array expected");
                    message.collectionNames = [];
                    for (var i = 0; i < object.collectionNames.length; ++i)
                        message.collectionNames[i] = String(object.collectionNames[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeCall message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.ChaincodeCall
             * @static
             * @param {discovery.ChaincodeCall} message ChaincodeCall
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeCall.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.collectionNames = [];
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.collectionNames && message.collectionNames.length) {
                    object.collectionNames = [];
                    for (var j = 0; j < message.collectionNames.length; ++j)
                        object.collectionNames[j] = message.collectionNames[j];
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeCall to JSON.
             * @function toJSON
             * @memberof discovery.ChaincodeCall
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeCall.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeCall;
        })();
    
        discovery.ChaincodeQueryResult = (function() {
    
            /**
             * Properties of a ChaincodeQueryResult.
             * @memberof discovery
             * @interface IChaincodeQueryResult
             * @property {Array.<discovery.IEndorsementDescriptor>|null} [content] ChaincodeQueryResult content
             */
    
            /**
             * Constructs a new ChaincodeQueryResult.
             * @memberof discovery
             * @classdesc Represents a ChaincodeQueryResult.
             * @implements IChaincodeQueryResult
             * @constructor
             * @param {discovery.IChaincodeQueryResult=} [properties] Properties to set
             */
            function ChaincodeQueryResult(properties) {
                this.content = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeQueryResult content.
             * @member {Array.<discovery.IEndorsementDescriptor>} content
             * @memberof discovery.ChaincodeQueryResult
             * @instance
             */
            ChaincodeQueryResult.prototype.content = $util.emptyArray;
    
            /**
             * Creates a new ChaincodeQueryResult instance using the specified properties.
             * @function create
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {discovery.IChaincodeQueryResult=} [properties] Properties to set
             * @returns {discovery.ChaincodeQueryResult} ChaincodeQueryResult instance
             */
            ChaincodeQueryResult.create = function create(properties) {
                return new ChaincodeQueryResult(properties);
            };
    
            /**
             * Encodes the specified ChaincodeQueryResult message. Does not implicitly {@link discovery.ChaincodeQueryResult.verify|verify} messages.
             * @function encode
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {discovery.IChaincodeQueryResult} message ChaincodeQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeQueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.content != null && message.content.length)
                    for (var i = 0; i < message.content.length; ++i)
                        $root.discovery.EndorsementDescriptor.encode(message.content[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeQueryResult message, length delimited. Does not implicitly {@link discovery.ChaincodeQueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {discovery.IChaincodeQueryResult} message ChaincodeQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeQueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeQueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.ChaincodeQueryResult} ChaincodeQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeQueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.ChaincodeQueryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.content && message.content.length))
                            message.content = [];
                        message.content.push($root.discovery.EndorsementDescriptor.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeQueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.ChaincodeQueryResult} ChaincodeQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeQueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeQueryResult message.
             * @function verify
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeQueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.content != null && message.hasOwnProperty("content")) {
                    if (!Array.isArray(message.content))
                        return "content: array expected";
                    for (var i = 0; i < message.content.length; ++i) {
                        var error = $root.discovery.EndorsementDescriptor.verify(message.content[i]);
                        if (error)
                            return "content." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeQueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.ChaincodeQueryResult} ChaincodeQueryResult
             */
            ChaincodeQueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.ChaincodeQueryResult)
                    return object;
                var message = new $root.discovery.ChaincodeQueryResult();
                if (object.content) {
                    if (!Array.isArray(object.content))
                        throw TypeError(".discovery.ChaincodeQueryResult.content: array expected");
                    message.content = [];
                    for (var i = 0; i < object.content.length; ++i) {
                        if (typeof object.content[i] !== "object")
                            throw TypeError(".discovery.ChaincodeQueryResult.content: object expected");
                        message.content[i] = $root.discovery.EndorsementDescriptor.fromObject(object.content[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeQueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.ChaincodeQueryResult
             * @static
             * @param {discovery.ChaincodeQueryResult} message ChaincodeQueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeQueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.content = [];
                if (message.content && message.content.length) {
                    object.content = [];
                    for (var j = 0; j < message.content.length; ++j)
                        object.content[j] = $root.discovery.EndorsementDescriptor.toObject(message.content[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeQueryResult to JSON.
             * @function toJSON
             * @memberof discovery.ChaincodeQueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeQueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeQueryResult;
        })();
    
        discovery.LocalPeerQuery = (function() {
    
            /**
             * Properties of a LocalPeerQuery.
             * @memberof discovery
             * @interface ILocalPeerQuery
             */
    
            /**
             * Constructs a new LocalPeerQuery.
             * @memberof discovery
             * @classdesc Represents a LocalPeerQuery.
             * @implements ILocalPeerQuery
             * @constructor
             * @param {discovery.ILocalPeerQuery=} [properties] Properties to set
             */
            function LocalPeerQuery(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new LocalPeerQuery instance using the specified properties.
             * @function create
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {discovery.ILocalPeerQuery=} [properties] Properties to set
             * @returns {discovery.LocalPeerQuery} LocalPeerQuery instance
             */
            LocalPeerQuery.create = function create(properties) {
                return new LocalPeerQuery(properties);
            };
    
            /**
             * Encodes the specified LocalPeerQuery message. Does not implicitly {@link discovery.LocalPeerQuery.verify|verify} messages.
             * @function encode
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {discovery.ILocalPeerQuery} message LocalPeerQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalPeerQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified LocalPeerQuery message, length delimited. Does not implicitly {@link discovery.LocalPeerQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {discovery.ILocalPeerQuery} message LocalPeerQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocalPeerQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LocalPeerQuery message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.LocalPeerQuery} LocalPeerQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalPeerQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.LocalPeerQuery();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LocalPeerQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.LocalPeerQuery} LocalPeerQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocalPeerQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LocalPeerQuery message.
             * @function verify
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocalPeerQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a LocalPeerQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.LocalPeerQuery} LocalPeerQuery
             */
            LocalPeerQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.LocalPeerQuery)
                    return object;
                return new $root.discovery.LocalPeerQuery();
            };
    
            /**
             * Creates a plain object from a LocalPeerQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.LocalPeerQuery
             * @static
             * @param {discovery.LocalPeerQuery} message LocalPeerQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocalPeerQuery.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this LocalPeerQuery to JSON.
             * @function toJSON
             * @memberof discovery.LocalPeerQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocalPeerQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LocalPeerQuery;
        })();
    
        discovery.EndorsementDescriptor = (function() {
    
            /**
             * Properties of an EndorsementDescriptor.
             * @memberof discovery
             * @interface IEndorsementDescriptor
             * @property {string|null} [chaincode] EndorsementDescriptor chaincode
             * @property {Object.<string,discovery.IPeers>|null} [endorsersByGroups] EndorsementDescriptor endorsersByGroups
             * @property {Array.<discovery.ILayout>|null} [layouts] EndorsementDescriptor layouts
             */
    
            /**
             * Constructs a new EndorsementDescriptor.
             * @memberof discovery
             * @classdesc Represents an EndorsementDescriptor.
             * @implements IEndorsementDescriptor
             * @constructor
             * @param {discovery.IEndorsementDescriptor=} [properties] Properties to set
             */
            function EndorsementDescriptor(properties) {
                this.endorsersByGroups = {};
                this.layouts = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * EndorsementDescriptor chaincode.
             * @member {string} chaincode
             * @memberof discovery.EndorsementDescriptor
             * @instance
             */
            EndorsementDescriptor.prototype.chaincode = "";
    
            /**
             * EndorsementDescriptor endorsersByGroups.
             * @member {Object.<string,discovery.IPeers>} endorsersByGroups
             * @memberof discovery.EndorsementDescriptor
             * @instance
             */
            EndorsementDescriptor.prototype.endorsersByGroups = $util.emptyObject;
    
            /**
             * EndorsementDescriptor layouts.
             * @member {Array.<discovery.ILayout>} layouts
             * @memberof discovery.EndorsementDescriptor
             * @instance
             */
            EndorsementDescriptor.prototype.layouts = $util.emptyArray;
    
            /**
             * Creates a new EndorsementDescriptor instance using the specified properties.
             * @function create
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {discovery.IEndorsementDescriptor=} [properties] Properties to set
             * @returns {discovery.EndorsementDescriptor} EndorsementDescriptor instance
             */
            EndorsementDescriptor.create = function create(properties) {
                return new EndorsementDescriptor(properties);
            };
    
            /**
             * Encodes the specified EndorsementDescriptor message. Does not implicitly {@link discovery.EndorsementDescriptor.verify|verify} messages.
             * @function encode
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {discovery.IEndorsementDescriptor} message EndorsementDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EndorsementDescriptor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincode != null && message.hasOwnProperty("chaincode"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.chaincode);
                if (message.endorsersByGroups != null && message.hasOwnProperty("endorsersByGroups"))
                    for (var keys = Object.keys(message.endorsersByGroups), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.discovery.Peers.encode(message.endorsersByGroups[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.layouts != null && message.layouts.length)
                    for (var i = 0; i < message.layouts.length; ++i)
                        $root.discovery.Layout.encode(message.layouts[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified EndorsementDescriptor message, length delimited. Does not implicitly {@link discovery.EndorsementDescriptor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {discovery.IEndorsementDescriptor} message EndorsementDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EndorsementDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an EndorsementDescriptor message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.EndorsementDescriptor} EndorsementDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EndorsementDescriptor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.EndorsementDescriptor(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincode = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.endorsersByGroups === $util.emptyObject)
                            message.endorsersByGroups = {};
                        key = reader.string();
                        reader.pos++;
                        message.endorsersByGroups[key] = $root.discovery.Peers.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.layouts && message.layouts.length))
                            message.layouts = [];
                        message.layouts.push($root.discovery.Layout.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an EndorsementDescriptor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.EndorsementDescriptor} EndorsementDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EndorsementDescriptor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an EndorsementDescriptor message.
             * @function verify
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EndorsementDescriptor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincode != null && message.hasOwnProperty("chaincode"))
                    if (!$util.isString(message.chaincode))
                        return "chaincode: string expected";
                if (message.endorsersByGroups != null && message.hasOwnProperty("endorsersByGroups")) {
                    if (!$util.isObject(message.endorsersByGroups))
                        return "endorsersByGroups: object expected";
                    var key = Object.keys(message.endorsersByGroups);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.discovery.Peers.verify(message.endorsersByGroups[key[i]]);
                        if (error)
                            return "endorsersByGroups." + error;
                    }
                }
                if (message.layouts != null && message.hasOwnProperty("layouts")) {
                    if (!Array.isArray(message.layouts))
                        return "layouts: array expected";
                    for (var i = 0; i < message.layouts.length; ++i) {
                        var error = $root.discovery.Layout.verify(message.layouts[i]);
                        if (error)
                            return "layouts." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates an EndorsementDescriptor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.EndorsementDescriptor} EndorsementDescriptor
             */
            EndorsementDescriptor.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.EndorsementDescriptor)
                    return object;
                var message = new $root.discovery.EndorsementDescriptor();
                if (object.chaincode != null)
                    message.chaincode = String(object.chaincode);
                if (object.endorsersByGroups) {
                    if (typeof object.endorsersByGroups !== "object")
                        throw TypeError(".discovery.EndorsementDescriptor.endorsersByGroups: object expected");
                    message.endorsersByGroups = {};
                    for (var keys = Object.keys(object.endorsersByGroups), i = 0; i < keys.length; ++i) {
                        if (typeof object.endorsersByGroups[keys[i]] !== "object")
                            throw TypeError(".discovery.EndorsementDescriptor.endorsersByGroups: object expected");
                        message.endorsersByGroups[keys[i]] = $root.discovery.Peers.fromObject(object.endorsersByGroups[keys[i]]);
                    }
                }
                if (object.layouts) {
                    if (!Array.isArray(object.layouts))
                        throw TypeError(".discovery.EndorsementDescriptor.layouts: array expected");
                    message.layouts = [];
                    for (var i = 0; i < object.layouts.length; ++i) {
                        if (typeof object.layouts[i] !== "object")
                            throw TypeError(".discovery.EndorsementDescriptor.layouts: object expected");
                        message.layouts[i] = $root.discovery.Layout.fromObject(object.layouts[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from an EndorsementDescriptor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.EndorsementDescriptor
             * @static
             * @param {discovery.EndorsementDescriptor} message EndorsementDescriptor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EndorsementDescriptor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.layouts = [];
                if (options.objects || options.defaults)
                    object.endorsersByGroups = {};
                if (options.defaults)
                    object.chaincode = "";
                if (message.chaincode != null && message.hasOwnProperty("chaincode"))
                    object.chaincode = message.chaincode;
                var keys2;
                if (message.endorsersByGroups && (keys2 = Object.keys(message.endorsersByGroups)).length) {
                    object.endorsersByGroups = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.endorsersByGroups[keys2[j]] = $root.discovery.Peers.toObject(message.endorsersByGroups[keys2[j]], options);
                }
                if (message.layouts && message.layouts.length) {
                    object.layouts = [];
                    for (var j = 0; j < message.layouts.length; ++j)
                        object.layouts[j] = $root.discovery.Layout.toObject(message.layouts[j], options);
                }
                return object;
            };
    
            /**
             * Converts this EndorsementDescriptor to JSON.
             * @function toJSON
             * @memberof discovery.EndorsementDescriptor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EndorsementDescriptor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return EndorsementDescriptor;
        })();
    
        discovery.Layout = (function() {
    
            /**
             * Properties of a Layout.
             * @memberof discovery
             * @interface ILayout
             * @property {Object.<string,number>|null} [quantitiesByGroup] Layout quantitiesByGroup
             */
    
            /**
             * Constructs a new Layout.
             * @memberof discovery
             * @classdesc Represents a Layout.
             * @implements ILayout
             * @constructor
             * @param {discovery.ILayout=} [properties] Properties to set
             */
            function Layout(properties) {
                this.quantitiesByGroup = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Layout quantitiesByGroup.
             * @member {Object.<string,number>} quantitiesByGroup
             * @memberof discovery.Layout
             * @instance
             */
            Layout.prototype.quantitiesByGroup = $util.emptyObject;
    
            /**
             * Creates a new Layout instance using the specified properties.
             * @function create
             * @memberof discovery.Layout
             * @static
             * @param {discovery.ILayout=} [properties] Properties to set
             * @returns {discovery.Layout} Layout instance
             */
            Layout.create = function create(properties) {
                return new Layout(properties);
            };
    
            /**
             * Encodes the specified Layout message. Does not implicitly {@link discovery.Layout.verify|verify} messages.
             * @function encode
             * @memberof discovery.Layout
             * @static
             * @param {discovery.ILayout} message Layout message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Layout.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.quantitiesByGroup != null && message.hasOwnProperty("quantitiesByGroup"))
                    for (var keys = Object.keys(message.quantitiesByGroup), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint32(message.quantitiesByGroup[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Layout message, length delimited. Does not implicitly {@link discovery.Layout.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Layout
             * @static
             * @param {discovery.ILayout} message Layout message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Layout.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Layout message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Layout
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Layout} Layout
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Layout.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Layout(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.quantitiesByGroup === $util.emptyObject)
                            message.quantitiesByGroup = {};
                        key = reader.string();
                        reader.pos++;
                        message.quantitiesByGroup[key] = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Layout message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Layout
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Layout} Layout
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Layout.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Layout message.
             * @function verify
             * @memberof discovery.Layout
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Layout.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.quantitiesByGroup != null && message.hasOwnProperty("quantitiesByGroup")) {
                    if (!$util.isObject(message.quantitiesByGroup))
                        return "quantitiesByGroup: object expected";
                    var key = Object.keys(message.quantitiesByGroup);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isInteger(message.quantitiesByGroup[key[i]]))
                            return "quantitiesByGroup: integer{k:string} expected";
                }
                return null;
            };
    
            /**
             * Creates a Layout message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Layout
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Layout} Layout
             */
            Layout.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Layout)
                    return object;
                var message = new $root.discovery.Layout();
                if (object.quantitiesByGroup) {
                    if (typeof object.quantitiesByGroup !== "object")
                        throw TypeError(".discovery.Layout.quantitiesByGroup: object expected");
                    message.quantitiesByGroup = {};
                    for (var keys = Object.keys(object.quantitiesByGroup), i = 0; i < keys.length; ++i)
                        message.quantitiesByGroup[keys[i]] = object.quantitiesByGroup[keys[i]] >>> 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Layout message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Layout
             * @static
             * @param {discovery.Layout} message Layout
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Layout.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.quantitiesByGroup = {};
                var keys2;
                if (message.quantitiesByGroup && (keys2 = Object.keys(message.quantitiesByGroup)).length) {
                    object.quantitiesByGroup = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.quantitiesByGroup[keys2[j]] = message.quantitiesByGroup[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this Layout to JSON.
             * @function toJSON
             * @memberof discovery.Layout
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Layout.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Layout;
        })();
    
        discovery.Peers = (function() {
    
            /**
             * Properties of a Peers.
             * @memberof discovery
             * @interface IPeers
             * @property {Array.<discovery.IPeer>|null} [peers] Peers peers
             */
    
            /**
             * Constructs a new Peers.
             * @memberof discovery
             * @classdesc Represents a Peers.
             * @implements IPeers
             * @constructor
             * @param {discovery.IPeers=} [properties] Properties to set
             */
            function Peers(properties) {
                this.peers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Peers peers.
             * @member {Array.<discovery.IPeer>} peers
             * @memberof discovery.Peers
             * @instance
             */
            Peers.prototype.peers = $util.emptyArray;
    
            /**
             * Creates a new Peers instance using the specified properties.
             * @function create
             * @memberof discovery.Peers
             * @static
             * @param {discovery.IPeers=} [properties] Properties to set
             * @returns {discovery.Peers} Peers instance
             */
            Peers.create = function create(properties) {
                return new Peers(properties);
            };
    
            /**
             * Encodes the specified Peers message. Does not implicitly {@link discovery.Peers.verify|verify} messages.
             * @function encode
             * @memberof discovery.Peers
             * @static
             * @param {discovery.IPeers} message Peers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Peers.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.peers != null && message.peers.length)
                    for (var i = 0; i < message.peers.length; ++i)
                        $root.discovery.Peer.encode(message.peers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Peers message, length delimited. Does not implicitly {@link discovery.Peers.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Peers
             * @static
             * @param {discovery.IPeers} message Peers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Peers.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Peers message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Peers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Peers} Peers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Peers.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Peers();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.peers && message.peers.length))
                            message.peers = [];
                        message.peers.push($root.discovery.Peer.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Peers message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Peers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Peers} Peers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Peers.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Peers message.
             * @function verify
             * @memberof discovery.Peers
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Peers.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.peers != null && message.hasOwnProperty("peers")) {
                    if (!Array.isArray(message.peers))
                        return "peers: array expected";
                    for (var i = 0; i < message.peers.length; ++i) {
                        var error = $root.discovery.Peer.verify(message.peers[i]);
                        if (error)
                            return "peers." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Peers message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Peers
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Peers} Peers
             */
            Peers.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Peers)
                    return object;
                var message = new $root.discovery.Peers();
                if (object.peers) {
                    if (!Array.isArray(object.peers))
                        throw TypeError(".discovery.Peers.peers: array expected");
                    message.peers = [];
                    for (var i = 0; i < object.peers.length; ++i) {
                        if (typeof object.peers[i] !== "object")
                            throw TypeError(".discovery.Peers.peers: object expected");
                        message.peers[i] = $root.discovery.Peer.fromObject(object.peers[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Peers message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Peers
             * @static
             * @param {discovery.Peers} message Peers
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Peers.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.peers = [];
                if (message.peers && message.peers.length) {
                    object.peers = [];
                    for (var j = 0; j < message.peers.length; ++j)
                        object.peers[j] = $root.discovery.Peer.toObject(message.peers[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Peers to JSON.
             * @function toJSON
             * @memberof discovery.Peers
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Peers.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Peers;
        })();
    
        discovery.Peer = (function() {
    
            /**
             * Properties of a Peer.
             * @memberof discovery
             * @interface IPeer
             * @property {gossip.IEnvelope|null} [stateInfo] Peer stateInfo
             * @property {gossip.IEnvelope|null} [membershipInfo] Peer membershipInfo
             * @property {Uint8Array|null} [identity] Peer identity
             */
    
            /**
             * Constructs a new Peer.
             * @memberof discovery
             * @classdesc Represents a Peer.
             * @implements IPeer
             * @constructor
             * @param {discovery.IPeer=} [properties] Properties to set
             */
            function Peer(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Peer stateInfo.
             * @member {gossip.IEnvelope|null|undefined} stateInfo
             * @memberof discovery.Peer
             * @instance
             */
            Peer.prototype.stateInfo = null;
    
            /**
             * Peer membershipInfo.
             * @member {gossip.IEnvelope|null|undefined} membershipInfo
             * @memberof discovery.Peer
             * @instance
             */
            Peer.prototype.membershipInfo = null;
    
            /**
             * Peer identity.
             * @member {Uint8Array} identity
             * @memberof discovery.Peer
             * @instance
             */
            Peer.prototype.identity = $util.newBuffer([]);
    
            /**
             * Creates a new Peer instance using the specified properties.
             * @function create
             * @memberof discovery.Peer
             * @static
             * @param {discovery.IPeer=} [properties] Properties to set
             * @returns {discovery.Peer} Peer instance
             */
            Peer.create = function create(properties) {
                return new Peer(properties);
            };
    
            /**
             * Encodes the specified Peer message. Does not implicitly {@link discovery.Peer.verify|verify} messages.
             * @function encode
             * @memberof discovery.Peer
             * @static
             * @param {discovery.IPeer} message Peer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Peer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stateInfo != null && message.hasOwnProperty("stateInfo"))
                    $root.gossip.Envelope.encode(message.stateInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.membershipInfo != null && message.hasOwnProperty("membershipInfo"))
                    $root.gossip.Envelope.encode(message.membershipInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identity != null && message.hasOwnProperty("identity"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.identity);
                return writer;
            };
    
            /**
             * Encodes the specified Peer message, length delimited. Does not implicitly {@link discovery.Peer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Peer
             * @static
             * @param {discovery.IPeer} message Peer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Peer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Peer message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Peer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Peer} Peer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Peer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Peer();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stateInfo = $root.gossip.Envelope.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.membershipInfo = $root.gossip.Envelope.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.identity = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Peer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Peer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Peer} Peer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Peer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Peer message.
             * @function verify
             * @memberof discovery.Peer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Peer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.stateInfo != null && message.hasOwnProperty("stateInfo")) {
                    var error = $root.gossip.Envelope.verify(message.stateInfo);
                    if (error)
                        return "stateInfo." + error;
                }
                if (message.membershipInfo != null && message.hasOwnProperty("membershipInfo")) {
                    var error = $root.gossip.Envelope.verify(message.membershipInfo);
                    if (error)
                        return "membershipInfo." + error;
                }
                if (message.identity != null && message.hasOwnProperty("identity"))
                    if (!(message.identity && typeof message.identity.length === "number" || $util.isString(message.identity)))
                        return "identity: buffer expected";
                return null;
            };
    
            /**
             * Creates a Peer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Peer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Peer} Peer
             */
            Peer.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Peer)
                    return object;
                var message = new $root.discovery.Peer();
                if (object.stateInfo != null) {
                    if (typeof object.stateInfo !== "object")
                        throw TypeError(".discovery.Peer.stateInfo: object expected");
                    message.stateInfo = $root.gossip.Envelope.fromObject(object.stateInfo);
                }
                if (object.membershipInfo != null) {
                    if (typeof object.membershipInfo !== "object")
                        throw TypeError(".discovery.Peer.membershipInfo: object expected");
                    message.membershipInfo = $root.gossip.Envelope.fromObject(object.membershipInfo);
                }
                if (object.identity != null)
                    if (typeof object.identity === "string")
                        $util.base64.decode(object.identity, message.identity = $util.newBuffer($util.base64.length(object.identity)), 0);
                    else if (object.identity.length)
                        message.identity = object.identity;
                return message;
            };
    
            /**
             * Creates a plain object from a Peer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Peer
             * @static
             * @param {discovery.Peer} message Peer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Peer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.stateInfo = null;
                    object.membershipInfo = null;
                    if (options.bytes === String)
                        object.identity = "";
                    else {
                        object.identity = [];
                        if (options.bytes !== Array)
                            object.identity = $util.newBuffer(object.identity);
                    }
                }
                if (message.stateInfo != null && message.hasOwnProperty("stateInfo"))
                    object.stateInfo = $root.gossip.Envelope.toObject(message.stateInfo, options);
                if (message.membershipInfo != null && message.hasOwnProperty("membershipInfo"))
                    object.membershipInfo = $root.gossip.Envelope.toObject(message.membershipInfo, options);
                if (message.identity != null && message.hasOwnProperty("identity"))
                    object.identity = options.bytes === String ? $util.base64.encode(message.identity, 0, message.identity.length) : options.bytes === Array ? Array.prototype.slice.call(message.identity) : message.identity;
                return object;
            };
    
            /**
             * Converts this Peer to JSON.
             * @function toJSON
             * @memberof discovery.Peer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Peer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Peer;
        })();
    
        discovery.Error = (function() {
    
            /**
             * Properties of an Error.
             * @memberof discovery
             * @interface IError
             * @property {string|null} [content] Error content
             */
    
            /**
             * Constructs a new Error.
             * @memberof discovery
             * @classdesc Represents an Error.
             * @implements IError
             * @constructor
             * @param {discovery.IError=} [properties] Properties to set
             */
            function Error(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Error content.
             * @member {string} content
             * @memberof discovery.Error
             * @instance
             */
            Error.prototype.content = "";
    
            /**
             * Creates a new Error instance using the specified properties.
             * @function create
             * @memberof discovery.Error
             * @static
             * @param {discovery.IError=} [properties] Properties to set
             * @returns {discovery.Error} Error instance
             */
            Error.create = function create(properties) {
                return new Error(properties);
            };
    
            /**
             * Encodes the specified Error message. Does not implicitly {@link discovery.Error.verify|verify} messages.
             * @function encode
             * @memberof discovery.Error
             * @static
             * @param {discovery.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.content != null && message.hasOwnProperty("content"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
                return writer;
            };
    
            /**
             * Encodes the specified Error message, length delimited. Does not implicitly {@link discovery.Error.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Error
             * @static
             * @param {discovery.IError} message Error message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Error.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Error message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Error();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.content = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Error message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Error
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Error} Error
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Error.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Error message.
             * @function verify
             * @memberof discovery.Error
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Error.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!$util.isString(message.content))
                        return "content: string expected";
                return null;
            };
    
            /**
             * Creates an Error message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Error
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Error} Error
             */
            Error.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Error)
                    return object;
                var message = new $root.discovery.Error();
                if (object.content != null)
                    message.content = String(object.content);
                return message;
            };
    
            /**
             * Creates a plain object from an Error message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Error
             * @static
             * @param {discovery.Error} message Error
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Error.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.content = "";
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = message.content;
                return object;
            };
    
            /**
             * Converts this Error to JSON.
             * @function toJSON
             * @memberof discovery.Error
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Error.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Error;
        })();
    
        discovery.Endpoints = (function() {
    
            /**
             * Properties of an Endpoints.
             * @memberof discovery
             * @interface IEndpoints
             * @property {Array.<discovery.IEndpoint>|null} [endpoint] Endpoints endpoint
             */
    
            /**
             * Constructs a new Endpoints.
             * @memberof discovery
             * @classdesc Represents an Endpoints.
             * @implements IEndpoints
             * @constructor
             * @param {discovery.IEndpoints=} [properties] Properties to set
             */
            function Endpoints(properties) {
                this.endpoint = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Endpoints endpoint.
             * @member {Array.<discovery.IEndpoint>} endpoint
             * @memberof discovery.Endpoints
             * @instance
             */
            Endpoints.prototype.endpoint = $util.emptyArray;
    
            /**
             * Creates a new Endpoints instance using the specified properties.
             * @function create
             * @memberof discovery.Endpoints
             * @static
             * @param {discovery.IEndpoints=} [properties] Properties to set
             * @returns {discovery.Endpoints} Endpoints instance
             */
            Endpoints.create = function create(properties) {
                return new Endpoints(properties);
            };
    
            /**
             * Encodes the specified Endpoints message. Does not implicitly {@link discovery.Endpoints.verify|verify} messages.
             * @function encode
             * @memberof discovery.Endpoints
             * @static
             * @param {discovery.IEndpoints} message Endpoints message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Endpoints.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endpoint != null && message.endpoint.length)
                    for (var i = 0; i < message.endpoint.length; ++i)
                        $root.discovery.Endpoint.encode(message.endpoint[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Endpoints message, length delimited. Does not implicitly {@link discovery.Endpoints.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Endpoints
             * @static
             * @param {discovery.IEndpoints} message Endpoints message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Endpoints.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Endpoints message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Endpoints
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Endpoints} Endpoints
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Endpoints.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Endpoints();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.endpoint && message.endpoint.length))
                            message.endpoint = [];
                        message.endpoint.push($root.discovery.Endpoint.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Endpoints message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Endpoints
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Endpoints} Endpoints
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Endpoints.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Endpoints message.
             * @function verify
             * @memberof discovery.Endpoints
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Endpoints.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endpoint != null && message.hasOwnProperty("endpoint")) {
                    if (!Array.isArray(message.endpoint))
                        return "endpoint: array expected";
                    for (var i = 0; i < message.endpoint.length; ++i) {
                        var error = $root.discovery.Endpoint.verify(message.endpoint[i]);
                        if (error)
                            return "endpoint." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates an Endpoints message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Endpoints
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Endpoints} Endpoints
             */
            Endpoints.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Endpoints)
                    return object;
                var message = new $root.discovery.Endpoints();
                if (object.endpoint) {
                    if (!Array.isArray(object.endpoint))
                        throw TypeError(".discovery.Endpoints.endpoint: array expected");
                    message.endpoint = [];
                    for (var i = 0; i < object.endpoint.length; ++i) {
                        if (typeof object.endpoint[i] !== "object")
                            throw TypeError(".discovery.Endpoints.endpoint: object expected");
                        message.endpoint[i] = $root.discovery.Endpoint.fromObject(object.endpoint[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from an Endpoints message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Endpoints
             * @static
             * @param {discovery.Endpoints} message Endpoints
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Endpoints.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.endpoint = [];
                if (message.endpoint && message.endpoint.length) {
                    object.endpoint = [];
                    for (var j = 0; j < message.endpoint.length; ++j)
                        object.endpoint[j] = $root.discovery.Endpoint.toObject(message.endpoint[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Endpoints to JSON.
             * @function toJSON
             * @memberof discovery.Endpoints
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Endpoints.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Endpoints;
        })();
    
        discovery.Endpoint = (function() {
    
            /**
             * Properties of an Endpoint.
             * @memberof discovery
             * @interface IEndpoint
             * @property {string|null} [host] Endpoint host
             * @property {number|null} [port] Endpoint port
             */
    
            /**
             * Constructs a new Endpoint.
             * @memberof discovery
             * @classdesc Represents an Endpoint.
             * @implements IEndpoint
             * @constructor
             * @param {discovery.IEndpoint=} [properties] Properties to set
             */
            function Endpoint(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Endpoint host.
             * @member {string} host
             * @memberof discovery.Endpoint
             * @instance
             */
            Endpoint.prototype.host = "";
    
            /**
             * Endpoint port.
             * @member {number} port
             * @memberof discovery.Endpoint
             * @instance
             */
            Endpoint.prototype.port = 0;
    
            /**
             * Creates a new Endpoint instance using the specified properties.
             * @function create
             * @memberof discovery.Endpoint
             * @static
             * @param {discovery.IEndpoint=} [properties] Properties to set
             * @returns {discovery.Endpoint} Endpoint instance
             */
            Endpoint.create = function create(properties) {
                return new Endpoint(properties);
            };
    
            /**
             * Encodes the specified Endpoint message. Does not implicitly {@link discovery.Endpoint.verify|verify} messages.
             * @function encode
             * @memberof discovery.Endpoint
             * @static
             * @param {discovery.IEndpoint} message Endpoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Endpoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.host != null && message.hasOwnProperty("host"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
                if (message.port != null && message.hasOwnProperty("port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                return writer;
            };
    
            /**
             * Encodes the specified Endpoint message, length delimited. Does not implicitly {@link discovery.Endpoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof discovery.Endpoint
             * @static
             * @param {discovery.IEndpoint} message Endpoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Endpoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Endpoint message from the specified reader or buffer.
             * @function decode
             * @memberof discovery.Endpoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {discovery.Endpoint} Endpoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Endpoint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.discovery.Endpoint();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.host = reader.string();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Endpoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof discovery.Endpoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {discovery.Endpoint} Endpoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Endpoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Endpoint message.
             * @function verify
             * @memberof discovery.Endpoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Endpoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                return null;
            };
    
            /**
             * Creates an Endpoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof discovery.Endpoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {discovery.Endpoint} Endpoint
             */
            Endpoint.fromObject = function fromObject(object) {
                if (object instanceof $root.discovery.Endpoint)
                    return object;
                var message = new $root.discovery.Endpoint();
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from an Endpoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof discovery.Endpoint
             * @static
             * @param {discovery.Endpoint} message Endpoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Endpoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.host = "";
                    object.port = 0;
                }
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                return object;
            };
    
            /**
             * Converts this Endpoint to JSON.
             * @function toJSON
             * @memberof discovery.Endpoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Endpoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Endpoint;
        })();
    
        return discovery;
    })();
    
    $root.gossip = (function() {
    
        /**
         * Namespace gossip.
         * @exports gossip
         * @namespace
         */
        var gossip = {};
    
        gossip.Gossip = (function() {
    
            /**
             * Constructs a new Gossip service.
             * @memberof gossip
             * @classdesc Represents a Gossip
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Gossip(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (Gossip.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Gossip;
    
            /**
             * Creates new Gossip service using the specified rpc implementation.
             * @function create
             * @memberof gossip.Gossip
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Gossip} RPC service. Useful where requests and/or responses are streamed.
             */
            Gossip.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link gossip.Gossip#gossipStream}.
             * @memberof gossip.Gossip
             * @typedef GossipStreamCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gossip.Envelope} [response] Envelope
             */
    
            /**
             * Calls GossipStream.
             * @function gossipStream
             * @memberof gossip.Gossip
             * @instance
             * @param {gossip.IEnvelope} request Envelope message or plain object
             * @param {gossip.Gossip.GossipStreamCallback} callback Node-style callback called with the error, if any, and Envelope
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Gossip.prototype.gossipStream = function gossipStream(request, callback) {
                return this.rpcCall(gossipStream, $root.gossip.Envelope, $root.gossip.Envelope, request, callback);
            }, "name", { value: "GossipStream" });
    
            /**
             * Calls GossipStream.
             * @function gossipStream
             * @memberof gossip.Gossip
             * @instance
             * @param {gossip.IEnvelope} request Envelope message or plain object
             * @returns {Promise<gossip.Envelope>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link gossip.Gossip#ping}.
             * @memberof gossip.Gossip
             * @typedef PingCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {gossip.Empty} [response] Empty
             */
    
            /**
             * Calls Ping.
             * @function ping
             * @memberof gossip.Gossip
             * @instance
             * @param {gossip.IEmpty} request Empty message or plain object
             * @param {gossip.Gossip.PingCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Gossip.prototype.ping = function ping(request, callback) {
                return this.rpcCall(ping, $root.gossip.Empty, $root.gossip.Empty, request, callback);
            }, "name", { value: "Ping" });
    
            /**
             * Calls Ping.
             * @function ping
             * @memberof gossip.Gossip
             * @instance
             * @param {gossip.IEmpty} request Empty message or plain object
             * @returns {Promise<gossip.Empty>} Promise
             * @variation 2
             */
    
            return Gossip;
        })();
    
        gossip.Envelope = (function() {
    
            /**
             * Properties of an Envelope.
             * @memberof gossip
             * @interface IEnvelope
             * @property {Uint8Array|null} [payload] Envelope payload
             * @property {Uint8Array|null} [signature] Envelope signature
             * @property {gossip.ISecretEnvelope|null} [secretEnvelope] Envelope secretEnvelope
             */
    
            /**
             * Constructs a new Envelope.
             * @memberof gossip
             * @classdesc Represents an Envelope.
             * @implements IEnvelope
             * @constructor
             * @param {gossip.IEnvelope=} [properties] Properties to set
             */
            function Envelope(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Envelope payload.
             * @member {Uint8Array} payload
             * @memberof gossip.Envelope
             * @instance
             */
            Envelope.prototype.payload = $util.newBuffer([]);
    
            /**
             * Envelope signature.
             * @member {Uint8Array} signature
             * @memberof gossip.Envelope
             * @instance
             */
            Envelope.prototype.signature = $util.newBuffer([]);
    
            /**
             * Envelope secretEnvelope.
             * @member {gossip.ISecretEnvelope|null|undefined} secretEnvelope
             * @memberof gossip.Envelope
             * @instance
             */
            Envelope.prototype.secretEnvelope = null;
    
            /**
             * Creates a new Envelope instance using the specified properties.
             * @function create
             * @memberof gossip.Envelope
             * @static
             * @param {gossip.IEnvelope=} [properties] Properties to set
             * @returns {gossip.Envelope} Envelope instance
             */
            Envelope.create = function create(properties) {
                return new Envelope(properties);
            };
    
            /**
             * Encodes the specified Envelope message. Does not implicitly {@link gossip.Envelope.verify|verify} messages.
             * @function encode
             * @memberof gossip.Envelope
             * @static
             * @param {gossip.IEnvelope} message Envelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Envelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                if (message.secretEnvelope != null && message.hasOwnProperty("secretEnvelope"))
                    $root.gossip.SecretEnvelope.encode(message.secretEnvelope, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Envelope message, length delimited. Does not implicitly {@link gossip.Envelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Envelope
             * @static
             * @param {gossip.IEnvelope} message Envelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Envelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Envelope message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Envelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Envelope} Envelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Envelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Envelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    case 3:
                        message.secretEnvelope = $root.gossip.SecretEnvelope.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Envelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Envelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Envelope} Envelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Envelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Envelope message.
             * @function verify
             * @memberof gossip.Envelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Envelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.secretEnvelope != null && message.hasOwnProperty("secretEnvelope")) {
                    var error = $root.gossip.SecretEnvelope.verify(message.secretEnvelope);
                    if (error)
                        return "secretEnvelope." + error;
                }
                return null;
            };
    
            /**
             * Creates an Envelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Envelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Envelope} Envelope
             */
            Envelope.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Envelope)
                    return object;
                var message = new $root.gossip.Envelope();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                if (object.secretEnvelope != null) {
                    if (typeof object.secretEnvelope !== "object")
                        throw TypeError(".gossip.Envelope.secretEnvelope: object expected");
                    message.secretEnvelope = $root.gossip.SecretEnvelope.fromObject(object.secretEnvelope);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an Envelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Envelope
             * @static
             * @param {gossip.Envelope} message Envelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Envelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    object.secretEnvelope = null;
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.secretEnvelope != null && message.hasOwnProperty("secretEnvelope"))
                    object.secretEnvelope = $root.gossip.SecretEnvelope.toObject(message.secretEnvelope, options);
                return object;
            };
    
            /**
             * Converts this Envelope to JSON.
             * @function toJSON
             * @memberof gossip.Envelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Envelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Envelope;
        })();
    
        gossip.SecretEnvelope = (function() {
    
            /**
             * Properties of a SecretEnvelope.
             * @memberof gossip
             * @interface ISecretEnvelope
             * @property {Uint8Array|null} [payload] SecretEnvelope payload
             * @property {Uint8Array|null} [signature] SecretEnvelope signature
             */
    
            /**
             * Constructs a new SecretEnvelope.
             * @memberof gossip
             * @classdesc Represents a SecretEnvelope.
             * @implements ISecretEnvelope
             * @constructor
             * @param {gossip.ISecretEnvelope=} [properties] Properties to set
             */
            function SecretEnvelope(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SecretEnvelope payload.
             * @member {Uint8Array} payload
             * @memberof gossip.SecretEnvelope
             * @instance
             */
            SecretEnvelope.prototype.payload = $util.newBuffer([]);
    
            /**
             * SecretEnvelope signature.
             * @member {Uint8Array} signature
             * @memberof gossip.SecretEnvelope
             * @instance
             */
            SecretEnvelope.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new SecretEnvelope instance using the specified properties.
             * @function create
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {gossip.ISecretEnvelope=} [properties] Properties to set
             * @returns {gossip.SecretEnvelope} SecretEnvelope instance
             */
            SecretEnvelope.create = function create(properties) {
                return new SecretEnvelope(properties);
            };
    
            /**
             * Encodes the specified SecretEnvelope message. Does not implicitly {@link gossip.SecretEnvelope.verify|verify} messages.
             * @function encode
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {gossip.ISecretEnvelope} message SecretEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecretEnvelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified SecretEnvelope message, length delimited. Does not implicitly {@link gossip.SecretEnvelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {gossip.ISecretEnvelope} message SecretEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecretEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SecretEnvelope message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.SecretEnvelope} SecretEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecretEnvelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.SecretEnvelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SecretEnvelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.SecretEnvelope} SecretEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecretEnvelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SecretEnvelope message.
             * @function verify
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SecretEnvelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates a SecretEnvelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.SecretEnvelope} SecretEnvelope
             */
            SecretEnvelope.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.SecretEnvelope)
                    return object;
                var message = new $root.gossip.SecretEnvelope();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from a SecretEnvelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.SecretEnvelope
             * @static
             * @param {gossip.SecretEnvelope} message SecretEnvelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SecretEnvelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this SecretEnvelope to JSON.
             * @function toJSON
             * @memberof gossip.SecretEnvelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SecretEnvelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SecretEnvelope;
        })();
    
        gossip.Secret = (function() {
    
            /**
             * Properties of a Secret.
             * @memberof gossip
             * @interface ISecret
             * @property {string|null} [internalEndpoint] Secret internalEndpoint
             */
    
            /**
             * Constructs a new Secret.
             * @memberof gossip
             * @classdesc Represents a Secret.
             * @implements ISecret
             * @constructor
             * @param {gossip.ISecret=} [properties] Properties to set
             */
            function Secret(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Secret internalEndpoint.
             * @member {string} internalEndpoint
             * @memberof gossip.Secret
             * @instance
             */
            Secret.prototype.internalEndpoint = "";
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * Secret content.
             * @member {"internalEndpoint"|undefined} content
             * @memberof gossip.Secret
             * @instance
             */
            Object.defineProperty(Secret.prototype, "content", {
                get: $util.oneOfGetter($oneOfFields = ["internalEndpoint"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new Secret instance using the specified properties.
             * @function create
             * @memberof gossip.Secret
             * @static
             * @param {gossip.ISecret=} [properties] Properties to set
             * @returns {gossip.Secret} Secret instance
             */
            Secret.create = function create(properties) {
                return new Secret(properties);
            };
    
            /**
             * Encodes the specified Secret message. Does not implicitly {@link gossip.Secret.verify|verify} messages.
             * @function encode
             * @memberof gossip.Secret
             * @static
             * @param {gossip.ISecret} message Secret message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Secret.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.internalEndpoint != null && message.hasOwnProperty("internalEndpoint"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.internalEndpoint);
                return writer;
            };
    
            /**
             * Encodes the specified Secret message, length delimited. Does not implicitly {@link gossip.Secret.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Secret
             * @static
             * @param {gossip.ISecret} message Secret message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Secret.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Secret message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Secret
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Secret} Secret
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Secret.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Secret();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.internalEndpoint = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Secret message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Secret
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Secret} Secret
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Secret.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Secret message.
             * @function verify
             * @memberof gossip.Secret
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Secret.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.internalEndpoint != null && message.hasOwnProperty("internalEndpoint")) {
                    properties.content = 1;
                    if (!$util.isString(message.internalEndpoint))
                        return "internalEndpoint: string expected";
                }
                return null;
            };
    
            /**
             * Creates a Secret message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Secret
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Secret} Secret
             */
            Secret.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Secret)
                    return object;
                var message = new $root.gossip.Secret();
                if (object.internalEndpoint != null)
                    message.internalEndpoint = String(object.internalEndpoint);
                return message;
            };
    
            /**
             * Creates a plain object from a Secret message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Secret
             * @static
             * @param {gossip.Secret} message Secret
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Secret.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.internalEndpoint != null && message.hasOwnProperty("internalEndpoint")) {
                    object.internalEndpoint = message.internalEndpoint;
                    if (options.oneofs)
                        object.content = "internalEndpoint";
                }
                return object;
            };
    
            /**
             * Converts this Secret to JSON.
             * @function toJSON
             * @memberof gossip.Secret
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Secret.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Secret;
        })();
    
        gossip.GossipMessage = (function() {
    
            /**
             * Properties of a GossipMessage.
             * @memberof gossip
             * @interface IGossipMessage
             * @property {number|Long|null} [nonce] GossipMessage nonce
             * @property {Uint8Array|null} [channel] GossipMessage channel
             * @property {gossip.GossipMessage.Tag|null} [tag] GossipMessage tag
             * @property {gossip.IAliveMessage|null} [aliveMsg] GossipMessage aliveMsg
             * @property {gossip.IMembershipRequest|null} [memReq] GossipMessage memReq
             * @property {gossip.IMembershipResponse|null} [memRes] GossipMessage memRes
             * @property {gossip.IDataMessage|null} [dataMsg] GossipMessage dataMsg
             * @property {gossip.IGossipHello|null} [hello] GossipMessage hello
             * @property {gossip.IDataDigest|null} [dataDig] GossipMessage dataDig
             * @property {gossip.IDataRequest|null} [dataReq] GossipMessage dataReq
             * @property {gossip.IDataUpdate|null} [dataUpdate] GossipMessage dataUpdate
             * @property {gossip.IEmpty|null} [empty] GossipMessage empty
             * @property {gossip.IConnEstablish|null} [conn] GossipMessage conn
             * @property {gossip.IStateInfo|null} [stateInfo] GossipMessage stateInfo
             * @property {gossip.IStateInfoSnapshot|null} [stateSnapshot] GossipMessage stateSnapshot
             * @property {gossip.IStateInfoPullRequest|null} [stateInfoPullReq] GossipMessage stateInfoPullReq
             * @property {gossip.IRemoteStateRequest|null} [stateRequest] GossipMessage stateRequest
             * @property {gossip.IRemoteStateResponse|null} [stateResponse] GossipMessage stateResponse
             * @property {gossip.ILeadershipMessage|null} [leadershipMsg] GossipMessage leadershipMsg
             * @property {gossip.IPeerIdentity|null} [peerIdentity] GossipMessage peerIdentity
             * @property {gossip.IAcknowledgement|null} [ack] GossipMessage ack
             * @property {gossip.IRemotePvtDataRequest|null} [privateReq] GossipMessage privateReq
             * @property {gossip.IRemotePvtDataResponse|null} [privateRes] GossipMessage privateRes
             * @property {gossip.IPrivateDataMessage|null} [privateData] GossipMessage privateData
             */
    
            /**
             * Constructs a new GossipMessage.
             * @memberof gossip
             * @classdesc Represents a GossipMessage.
             * @implements IGossipMessage
             * @constructor
             * @param {gossip.IGossipMessage=} [properties] Properties to set
             */
            function GossipMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GossipMessage nonce.
             * @member {number|Long} nonce
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * GossipMessage channel.
             * @member {Uint8Array} channel
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.channel = $util.newBuffer([]);
    
            /**
             * GossipMessage tag.
             * @member {gossip.GossipMessage.Tag} tag
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.tag = 0;
    
            /**
             * GossipMessage aliveMsg.
             * @member {gossip.IAliveMessage|null|undefined} aliveMsg
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.aliveMsg = null;
    
            /**
             * GossipMessage memReq.
             * @member {gossip.IMembershipRequest|null|undefined} memReq
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.memReq = null;
    
            /**
             * GossipMessage memRes.
             * @member {gossip.IMembershipResponse|null|undefined} memRes
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.memRes = null;
    
            /**
             * GossipMessage dataMsg.
             * @member {gossip.IDataMessage|null|undefined} dataMsg
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.dataMsg = null;
    
            /**
             * GossipMessage hello.
             * @member {gossip.IGossipHello|null|undefined} hello
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.hello = null;
    
            /**
             * GossipMessage dataDig.
             * @member {gossip.IDataDigest|null|undefined} dataDig
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.dataDig = null;
    
            /**
             * GossipMessage dataReq.
             * @member {gossip.IDataRequest|null|undefined} dataReq
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.dataReq = null;
    
            /**
             * GossipMessage dataUpdate.
             * @member {gossip.IDataUpdate|null|undefined} dataUpdate
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.dataUpdate = null;
    
            /**
             * GossipMessage empty.
             * @member {gossip.IEmpty|null|undefined} empty
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.empty = null;
    
            /**
             * GossipMessage conn.
             * @member {gossip.IConnEstablish|null|undefined} conn
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.conn = null;
    
            /**
             * GossipMessage stateInfo.
             * @member {gossip.IStateInfo|null|undefined} stateInfo
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.stateInfo = null;
    
            /**
             * GossipMessage stateSnapshot.
             * @member {gossip.IStateInfoSnapshot|null|undefined} stateSnapshot
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.stateSnapshot = null;
    
            /**
             * GossipMessage stateInfoPullReq.
             * @member {gossip.IStateInfoPullRequest|null|undefined} stateInfoPullReq
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.stateInfoPullReq = null;
    
            /**
             * GossipMessage stateRequest.
             * @member {gossip.IRemoteStateRequest|null|undefined} stateRequest
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.stateRequest = null;
    
            /**
             * GossipMessage stateResponse.
             * @member {gossip.IRemoteStateResponse|null|undefined} stateResponse
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.stateResponse = null;
    
            /**
             * GossipMessage leadershipMsg.
             * @member {gossip.ILeadershipMessage|null|undefined} leadershipMsg
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.leadershipMsg = null;
    
            /**
             * GossipMessage peerIdentity.
             * @member {gossip.IPeerIdentity|null|undefined} peerIdentity
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.peerIdentity = null;
    
            /**
             * GossipMessage ack.
             * @member {gossip.IAcknowledgement|null|undefined} ack
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.ack = null;
    
            /**
             * GossipMessage privateReq.
             * @member {gossip.IRemotePvtDataRequest|null|undefined} privateReq
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.privateReq = null;
    
            /**
             * GossipMessage privateRes.
             * @member {gossip.IRemotePvtDataResponse|null|undefined} privateRes
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.privateRes = null;
    
            /**
             * GossipMessage privateData.
             * @member {gossip.IPrivateDataMessage|null|undefined} privateData
             * @memberof gossip.GossipMessage
             * @instance
             */
            GossipMessage.prototype.privateData = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * GossipMessage content.
             * @member {"aliveMsg"|"memReq"|"memRes"|"dataMsg"|"hello"|"dataDig"|"dataReq"|"dataUpdate"|"empty"|"conn"|"stateInfo"|"stateSnapshot"|"stateInfoPullReq"|"stateRequest"|"stateResponse"|"leadershipMsg"|"peerIdentity"|"ack"|"privateReq"|"privateRes"|"privateData"|undefined} content
             * @memberof gossip.GossipMessage
             * @instance
             */
            Object.defineProperty(GossipMessage.prototype, "content", {
                get: $util.oneOfGetter($oneOfFields = ["aliveMsg", "memReq", "memRes", "dataMsg", "hello", "dataDig", "dataReq", "dataUpdate", "empty", "conn", "stateInfo", "stateSnapshot", "stateInfoPullReq", "stateRequest", "stateResponse", "leadershipMsg", "peerIdentity", "ack", "privateReq", "privateRes", "privateData"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new GossipMessage instance using the specified properties.
             * @function create
             * @memberof gossip.GossipMessage
             * @static
             * @param {gossip.IGossipMessage=} [properties] Properties to set
             * @returns {gossip.GossipMessage} GossipMessage instance
             */
            GossipMessage.create = function create(properties) {
                return new GossipMessage(properties);
            };
    
            /**
             * Encodes the specified GossipMessage message. Does not implicitly {@link gossip.GossipMessage.verify|verify} messages.
             * @function encode
             * @memberof gossip.GossipMessage
             * @static
             * @param {gossip.IGossipMessage} message GossipMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GossipMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.channel != null && message.hasOwnProperty("channel"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.channel);
                if (message.tag != null && message.hasOwnProperty("tag"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tag);
                if (message.aliveMsg != null && message.hasOwnProperty("aliveMsg"))
                    $root.gossip.AliveMessage.encode(message.aliveMsg, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.memReq != null && message.hasOwnProperty("memReq"))
                    $root.gossip.MembershipRequest.encode(message.memReq, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.memRes != null && message.hasOwnProperty("memRes"))
                    $root.gossip.MembershipResponse.encode(message.memRes, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.dataMsg != null && message.hasOwnProperty("dataMsg"))
                    $root.gossip.DataMessage.encode(message.dataMsg, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.hello != null && message.hasOwnProperty("hello"))
                    $root.gossip.GossipHello.encode(message.hello, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.dataDig != null && message.hasOwnProperty("dataDig"))
                    $root.gossip.DataDigest.encode(message.dataDig, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.dataReq != null && message.hasOwnProperty("dataReq"))
                    $root.gossip.DataRequest.encode(message.dataReq, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.dataUpdate != null && message.hasOwnProperty("dataUpdate"))
                    $root.gossip.DataUpdate.encode(message.dataUpdate, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.empty != null && message.hasOwnProperty("empty"))
                    $root.gossip.Empty.encode(message.empty, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.conn != null && message.hasOwnProperty("conn"))
                    $root.gossip.ConnEstablish.encode(message.conn, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.stateInfo != null && message.hasOwnProperty("stateInfo"))
                    $root.gossip.StateInfo.encode(message.stateInfo, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.stateSnapshot != null && message.hasOwnProperty("stateSnapshot"))
                    $root.gossip.StateInfoSnapshot.encode(message.stateSnapshot, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.stateInfoPullReq != null && message.hasOwnProperty("stateInfoPullReq"))
                    $root.gossip.StateInfoPullRequest.encode(message.stateInfoPullReq, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.stateRequest != null && message.hasOwnProperty("stateRequest"))
                    $root.gossip.RemoteStateRequest.encode(message.stateRequest, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.stateResponse != null && message.hasOwnProperty("stateResponse"))
                    $root.gossip.RemoteStateResponse.encode(message.stateResponse, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.leadershipMsg != null && message.hasOwnProperty("leadershipMsg"))
                    $root.gossip.LeadershipMessage.encode(message.leadershipMsg, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.peerIdentity != null && message.hasOwnProperty("peerIdentity"))
                    $root.gossip.PeerIdentity.encode(message.peerIdentity, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.ack != null && message.hasOwnProperty("ack"))
                    $root.gossip.Acknowledgement.encode(message.ack, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.privateReq != null && message.hasOwnProperty("privateReq"))
                    $root.gossip.RemotePvtDataRequest.encode(message.privateReq, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.privateRes != null && message.hasOwnProperty("privateRes"))
                    $root.gossip.RemotePvtDataResponse.encode(message.privateRes, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.privateData != null && message.hasOwnProperty("privateData"))
                    $root.gossip.PrivateDataMessage.encode(message.privateData, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified GossipMessage message, length delimited. Does not implicitly {@link gossip.GossipMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.GossipMessage
             * @static
             * @param {gossip.IGossipMessage} message GossipMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GossipMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GossipMessage message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.GossipMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.GossipMessage} GossipMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GossipMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.GossipMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        message.channel = reader.bytes();
                        break;
                    case 3:
                        message.tag = reader.int32();
                        break;
                    case 5:
                        message.aliveMsg = $root.gossip.AliveMessage.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.memReq = $root.gossip.MembershipRequest.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.memRes = $root.gossip.MembershipResponse.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.dataMsg = $root.gossip.DataMessage.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.hello = $root.gossip.GossipHello.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.dataDig = $root.gossip.DataDigest.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.dataReq = $root.gossip.DataRequest.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.dataUpdate = $root.gossip.DataUpdate.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.empty = $root.gossip.Empty.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.conn = $root.gossip.ConnEstablish.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.stateInfo = $root.gossip.StateInfo.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.stateSnapshot = $root.gossip.StateInfoSnapshot.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.stateInfoPullReq = $root.gossip.StateInfoPullRequest.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.stateRequest = $root.gossip.RemoteStateRequest.decode(reader, reader.uint32());
                        break;
                    case 19:
                        message.stateResponse = $root.gossip.RemoteStateResponse.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message.leadershipMsg = $root.gossip.LeadershipMessage.decode(reader, reader.uint32());
                        break;
                    case 21:
                        message.peerIdentity = $root.gossip.PeerIdentity.decode(reader, reader.uint32());
                        break;
                    case 22:
                        message.ack = $root.gossip.Acknowledgement.decode(reader, reader.uint32());
                        break;
                    case 23:
                        message.privateReq = $root.gossip.RemotePvtDataRequest.decode(reader, reader.uint32());
                        break;
                    case 24:
                        message.privateRes = $root.gossip.RemotePvtDataResponse.decode(reader, reader.uint32());
                        break;
                    case 25:
                        message.privateData = $root.gossip.PrivateDataMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GossipMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.GossipMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.GossipMessage} GossipMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GossipMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GossipMessage message.
             * @function verify
             * @memberof gossip.GossipMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GossipMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!(message.channel && typeof message.channel.length === "number" || $util.isString(message.channel)))
                        return "channel: buffer expected";
                if (message.tag != null && message.hasOwnProperty("tag"))
                    switch (message.tag) {
                    default:
                        return "tag: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.aliveMsg != null && message.hasOwnProperty("aliveMsg")) {
                    properties.content = 1;
                    {
                        var error = $root.gossip.AliveMessage.verify(message.aliveMsg);
                        if (error)
                            return "aliveMsg." + error;
                    }
                }
                if (message.memReq != null && message.hasOwnProperty("memReq")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.MembershipRequest.verify(message.memReq);
                        if (error)
                            return "memReq." + error;
                    }
                }
                if (message.memRes != null && message.hasOwnProperty("memRes")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.MembershipResponse.verify(message.memRes);
                        if (error)
                            return "memRes." + error;
                    }
                }
                if (message.dataMsg != null && message.hasOwnProperty("dataMsg")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.DataMessage.verify(message.dataMsg);
                        if (error)
                            return "dataMsg." + error;
                    }
                }
                if (message.hello != null && message.hasOwnProperty("hello")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.GossipHello.verify(message.hello);
                        if (error)
                            return "hello." + error;
                    }
                }
                if (message.dataDig != null && message.hasOwnProperty("dataDig")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.DataDigest.verify(message.dataDig);
                        if (error)
                            return "dataDig." + error;
                    }
                }
                if (message.dataReq != null && message.hasOwnProperty("dataReq")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.DataRequest.verify(message.dataReq);
                        if (error)
                            return "dataReq." + error;
                    }
                }
                if (message.dataUpdate != null && message.hasOwnProperty("dataUpdate")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.DataUpdate.verify(message.dataUpdate);
                        if (error)
                            return "dataUpdate." + error;
                    }
                }
                if (message.empty != null && message.hasOwnProperty("empty")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.Empty.verify(message.empty);
                        if (error)
                            return "empty." + error;
                    }
                }
                if (message.conn != null && message.hasOwnProperty("conn")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.ConnEstablish.verify(message.conn);
                        if (error)
                            return "conn." + error;
                    }
                }
                if (message.stateInfo != null && message.hasOwnProperty("stateInfo")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.StateInfo.verify(message.stateInfo);
                        if (error)
                            return "stateInfo." + error;
                    }
                }
                if (message.stateSnapshot != null && message.hasOwnProperty("stateSnapshot")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.StateInfoSnapshot.verify(message.stateSnapshot);
                        if (error)
                            return "stateSnapshot." + error;
                    }
                }
                if (message.stateInfoPullReq != null && message.hasOwnProperty("stateInfoPullReq")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.StateInfoPullRequest.verify(message.stateInfoPullReq);
                        if (error)
                            return "stateInfoPullReq." + error;
                    }
                }
                if (message.stateRequest != null && message.hasOwnProperty("stateRequest")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.RemoteStateRequest.verify(message.stateRequest);
                        if (error)
                            return "stateRequest." + error;
                    }
                }
                if (message.stateResponse != null && message.hasOwnProperty("stateResponse")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.RemoteStateResponse.verify(message.stateResponse);
                        if (error)
                            return "stateResponse." + error;
                    }
                }
                if (message.leadershipMsg != null && message.hasOwnProperty("leadershipMsg")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.LeadershipMessage.verify(message.leadershipMsg);
                        if (error)
                            return "leadershipMsg." + error;
                    }
                }
                if (message.peerIdentity != null && message.hasOwnProperty("peerIdentity")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.PeerIdentity.verify(message.peerIdentity);
                        if (error)
                            return "peerIdentity." + error;
                    }
                }
                if (message.ack != null && message.hasOwnProperty("ack")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.Acknowledgement.verify(message.ack);
                        if (error)
                            return "ack." + error;
                    }
                }
                if (message.privateReq != null && message.hasOwnProperty("privateReq")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.RemotePvtDataRequest.verify(message.privateReq);
                        if (error)
                            return "privateReq." + error;
                    }
                }
                if (message.privateRes != null && message.hasOwnProperty("privateRes")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.RemotePvtDataResponse.verify(message.privateRes);
                        if (error)
                            return "privateRes." + error;
                    }
                }
                if (message.privateData != null && message.hasOwnProperty("privateData")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.gossip.PrivateDataMessage.verify(message.privateData);
                        if (error)
                            return "privateData." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a GossipMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.GossipMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.GossipMessage} GossipMessage
             */
            GossipMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.GossipMessage)
                    return object;
                var message = new $root.gossip.GossipMessage();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.channel != null)
                    if (typeof object.channel === "string")
                        $util.base64.decode(object.channel, message.channel = $util.newBuffer($util.base64.length(object.channel)), 0);
                    else if (object.channel.length)
                        message.channel = object.channel;
                switch (object.tag) {
                case "UNDEFINED":
                case 0:
                    message.tag = 0;
                    break;
                case "EMPTY":
                case 1:
                    message.tag = 1;
                    break;
                case "ORG_ONLY":
                case 2:
                    message.tag = 2;
                    break;
                case "CHAN_ONLY":
                case 3:
                    message.tag = 3;
                    break;
                case "CHAN_AND_ORG":
                case 4:
                    message.tag = 4;
                    break;
                case "CHAN_OR_ORG":
                case 5:
                    message.tag = 5;
                    break;
                }
                if (object.aliveMsg != null) {
                    if (typeof object.aliveMsg !== "object")
                        throw TypeError(".gossip.GossipMessage.aliveMsg: object expected");
                    message.aliveMsg = $root.gossip.AliveMessage.fromObject(object.aliveMsg);
                }
                if (object.memReq != null) {
                    if (typeof object.memReq !== "object")
                        throw TypeError(".gossip.GossipMessage.memReq: object expected");
                    message.memReq = $root.gossip.MembershipRequest.fromObject(object.memReq);
                }
                if (object.memRes != null) {
                    if (typeof object.memRes !== "object")
                        throw TypeError(".gossip.GossipMessage.memRes: object expected");
                    message.memRes = $root.gossip.MembershipResponse.fromObject(object.memRes);
                }
                if (object.dataMsg != null) {
                    if (typeof object.dataMsg !== "object")
                        throw TypeError(".gossip.GossipMessage.dataMsg: object expected");
                    message.dataMsg = $root.gossip.DataMessage.fromObject(object.dataMsg);
                }
                if (object.hello != null) {
                    if (typeof object.hello !== "object")
                        throw TypeError(".gossip.GossipMessage.hello: object expected");
                    message.hello = $root.gossip.GossipHello.fromObject(object.hello);
                }
                if (object.dataDig != null) {
                    if (typeof object.dataDig !== "object")
                        throw TypeError(".gossip.GossipMessage.dataDig: object expected");
                    message.dataDig = $root.gossip.DataDigest.fromObject(object.dataDig);
                }
                if (object.dataReq != null) {
                    if (typeof object.dataReq !== "object")
                        throw TypeError(".gossip.GossipMessage.dataReq: object expected");
                    message.dataReq = $root.gossip.DataRequest.fromObject(object.dataReq);
                }
                if (object.dataUpdate != null) {
                    if (typeof object.dataUpdate !== "object")
                        throw TypeError(".gossip.GossipMessage.dataUpdate: object expected");
                    message.dataUpdate = $root.gossip.DataUpdate.fromObject(object.dataUpdate);
                }
                if (object.empty != null) {
                    if (typeof object.empty !== "object")
                        throw TypeError(".gossip.GossipMessage.empty: object expected");
                    message.empty = $root.gossip.Empty.fromObject(object.empty);
                }
                if (object.conn != null) {
                    if (typeof object.conn !== "object")
                        throw TypeError(".gossip.GossipMessage.conn: object expected");
                    message.conn = $root.gossip.ConnEstablish.fromObject(object.conn);
                }
                if (object.stateInfo != null) {
                    if (typeof object.stateInfo !== "object")
                        throw TypeError(".gossip.GossipMessage.stateInfo: object expected");
                    message.stateInfo = $root.gossip.StateInfo.fromObject(object.stateInfo);
                }
                if (object.stateSnapshot != null) {
                    if (typeof object.stateSnapshot !== "object")
                        throw TypeError(".gossip.GossipMessage.stateSnapshot: object expected");
                    message.stateSnapshot = $root.gossip.StateInfoSnapshot.fromObject(object.stateSnapshot);
                }
                if (object.stateInfoPullReq != null) {
                    if (typeof object.stateInfoPullReq !== "object")
                        throw TypeError(".gossip.GossipMessage.stateInfoPullReq: object expected");
                    message.stateInfoPullReq = $root.gossip.StateInfoPullRequest.fromObject(object.stateInfoPullReq);
                }
                if (object.stateRequest != null) {
                    if (typeof object.stateRequest !== "object")
                        throw TypeError(".gossip.GossipMessage.stateRequest: object expected");
                    message.stateRequest = $root.gossip.RemoteStateRequest.fromObject(object.stateRequest);
                }
                if (object.stateResponse != null) {
                    if (typeof object.stateResponse !== "object")
                        throw TypeError(".gossip.GossipMessage.stateResponse: object expected");
                    message.stateResponse = $root.gossip.RemoteStateResponse.fromObject(object.stateResponse);
                }
                if (object.leadershipMsg != null) {
                    if (typeof object.leadershipMsg !== "object")
                        throw TypeError(".gossip.GossipMessage.leadershipMsg: object expected");
                    message.leadershipMsg = $root.gossip.LeadershipMessage.fromObject(object.leadershipMsg);
                }
                if (object.peerIdentity != null) {
                    if (typeof object.peerIdentity !== "object")
                        throw TypeError(".gossip.GossipMessage.peerIdentity: object expected");
                    message.peerIdentity = $root.gossip.PeerIdentity.fromObject(object.peerIdentity);
                }
                if (object.ack != null) {
                    if (typeof object.ack !== "object")
                        throw TypeError(".gossip.GossipMessage.ack: object expected");
                    message.ack = $root.gossip.Acknowledgement.fromObject(object.ack);
                }
                if (object.privateReq != null) {
                    if (typeof object.privateReq !== "object")
                        throw TypeError(".gossip.GossipMessage.privateReq: object expected");
                    message.privateReq = $root.gossip.RemotePvtDataRequest.fromObject(object.privateReq);
                }
                if (object.privateRes != null) {
                    if (typeof object.privateRes !== "object")
                        throw TypeError(".gossip.GossipMessage.privateRes: object expected");
                    message.privateRes = $root.gossip.RemotePvtDataResponse.fromObject(object.privateRes);
                }
                if (object.privateData != null) {
                    if (typeof object.privateData !== "object")
                        throw TypeError(".gossip.GossipMessage.privateData: object expected");
                    message.privateData = $root.gossip.PrivateDataMessage.fromObject(object.privateData);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a GossipMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.GossipMessage
             * @static
             * @param {gossip.GossipMessage} message GossipMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GossipMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.channel = "";
                    else {
                        object.channel = [];
                        if (options.bytes !== Array)
                            object.channel = $util.newBuffer(object.channel);
                    }
                    object.tag = options.enums === String ? "UNDEFINED" : 0;
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = options.bytes === String ? $util.base64.encode(message.channel, 0, message.channel.length) : options.bytes === Array ? Array.prototype.slice.call(message.channel) : message.channel;
                if (message.tag != null && message.hasOwnProperty("tag"))
                    object.tag = options.enums === String ? $root.gossip.GossipMessage.Tag[message.tag] : message.tag;
                if (message.aliveMsg != null && message.hasOwnProperty("aliveMsg")) {
                    object.aliveMsg = $root.gossip.AliveMessage.toObject(message.aliveMsg, options);
                    if (options.oneofs)
                        object.content = "aliveMsg";
                }
                if (message.memReq != null && message.hasOwnProperty("memReq")) {
                    object.memReq = $root.gossip.MembershipRequest.toObject(message.memReq, options);
                    if (options.oneofs)
                        object.content = "memReq";
                }
                if (message.memRes != null && message.hasOwnProperty("memRes")) {
                    object.memRes = $root.gossip.MembershipResponse.toObject(message.memRes, options);
                    if (options.oneofs)
                        object.content = "memRes";
                }
                if (message.dataMsg != null && message.hasOwnProperty("dataMsg")) {
                    object.dataMsg = $root.gossip.DataMessage.toObject(message.dataMsg, options);
                    if (options.oneofs)
                        object.content = "dataMsg";
                }
                if (message.hello != null && message.hasOwnProperty("hello")) {
                    object.hello = $root.gossip.GossipHello.toObject(message.hello, options);
                    if (options.oneofs)
                        object.content = "hello";
                }
                if (message.dataDig != null && message.hasOwnProperty("dataDig")) {
                    object.dataDig = $root.gossip.DataDigest.toObject(message.dataDig, options);
                    if (options.oneofs)
                        object.content = "dataDig";
                }
                if (message.dataReq != null && message.hasOwnProperty("dataReq")) {
                    object.dataReq = $root.gossip.DataRequest.toObject(message.dataReq, options);
                    if (options.oneofs)
                        object.content = "dataReq";
                }
                if (message.dataUpdate != null && message.hasOwnProperty("dataUpdate")) {
                    object.dataUpdate = $root.gossip.DataUpdate.toObject(message.dataUpdate, options);
                    if (options.oneofs)
                        object.content = "dataUpdate";
                }
                if (message.empty != null && message.hasOwnProperty("empty")) {
                    object.empty = $root.gossip.Empty.toObject(message.empty, options);
                    if (options.oneofs)
                        object.content = "empty";
                }
                if (message.conn != null && message.hasOwnProperty("conn")) {
                    object.conn = $root.gossip.ConnEstablish.toObject(message.conn, options);
                    if (options.oneofs)
                        object.content = "conn";
                }
                if (message.stateInfo != null && message.hasOwnProperty("stateInfo")) {
                    object.stateInfo = $root.gossip.StateInfo.toObject(message.stateInfo, options);
                    if (options.oneofs)
                        object.content = "stateInfo";
                }
                if (message.stateSnapshot != null && message.hasOwnProperty("stateSnapshot")) {
                    object.stateSnapshot = $root.gossip.StateInfoSnapshot.toObject(message.stateSnapshot, options);
                    if (options.oneofs)
                        object.content = "stateSnapshot";
                }
                if (message.stateInfoPullReq != null && message.hasOwnProperty("stateInfoPullReq")) {
                    object.stateInfoPullReq = $root.gossip.StateInfoPullRequest.toObject(message.stateInfoPullReq, options);
                    if (options.oneofs)
                        object.content = "stateInfoPullReq";
                }
                if (message.stateRequest != null && message.hasOwnProperty("stateRequest")) {
                    object.stateRequest = $root.gossip.RemoteStateRequest.toObject(message.stateRequest, options);
                    if (options.oneofs)
                        object.content = "stateRequest";
                }
                if (message.stateResponse != null && message.hasOwnProperty("stateResponse")) {
                    object.stateResponse = $root.gossip.RemoteStateResponse.toObject(message.stateResponse, options);
                    if (options.oneofs)
                        object.content = "stateResponse";
                }
                if (message.leadershipMsg != null && message.hasOwnProperty("leadershipMsg")) {
                    object.leadershipMsg = $root.gossip.LeadershipMessage.toObject(message.leadershipMsg, options);
                    if (options.oneofs)
                        object.content = "leadershipMsg";
                }
                if (message.peerIdentity != null && message.hasOwnProperty("peerIdentity")) {
                    object.peerIdentity = $root.gossip.PeerIdentity.toObject(message.peerIdentity, options);
                    if (options.oneofs)
                        object.content = "peerIdentity";
                }
                if (message.ack != null && message.hasOwnProperty("ack")) {
                    object.ack = $root.gossip.Acknowledgement.toObject(message.ack, options);
                    if (options.oneofs)
                        object.content = "ack";
                }
                if (message.privateReq != null && message.hasOwnProperty("privateReq")) {
                    object.privateReq = $root.gossip.RemotePvtDataRequest.toObject(message.privateReq, options);
                    if (options.oneofs)
                        object.content = "privateReq";
                }
                if (message.privateRes != null && message.hasOwnProperty("privateRes")) {
                    object.privateRes = $root.gossip.RemotePvtDataResponse.toObject(message.privateRes, options);
                    if (options.oneofs)
                        object.content = "privateRes";
                }
                if (message.privateData != null && message.hasOwnProperty("privateData")) {
                    object.privateData = $root.gossip.PrivateDataMessage.toObject(message.privateData, options);
                    if (options.oneofs)
                        object.content = "privateData";
                }
                return object;
            };
    
            /**
             * Converts this GossipMessage to JSON.
             * @function toJSON
             * @memberof gossip.GossipMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GossipMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Tag enum.
             * @name gossip.GossipMessage.Tag
             * @enum {string}
             * @property {number} UNDEFINED=0 UNDEFINED value
             * @property {number} EMPTY=1 EMPTY value
             * @property {number} ORG_ONLY=2 ORG_ONLY value
             * @property {number} CHAN_ONLY=3 CHAN_ONLY value
             * @property {number} CHAN_AND_ORG=4 CHAN_AND_ORG value
             * @property {number} CHAN_OR_ORG=5 CHAN_OR_ORG value
             */
            GossipMessage.Tag = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNDEFINED"] = 0;
                values[valuesById[1] = "EMPTY"] = 1;
                values[valuesById[2] = "ORG_ONLY"] = 2;
                values[valuesById[3] = "CHAN_ONLY"] = 3;
                values[valuesById[4] = "CHAN_AND_ORG"] = 4;
                values[valuesById[5] = "CHAN_OR_ORG"] = 5;
                return values;
            })();
    
            return GossipMessage;
        })();
    
        gossip.StateInfo = (function() {
    
            /**
             * Properties of a StateInfo.
             * @memberof gossip
             * @interface IStateInfo
             * @property {gossip.IPeerTime|null} [timestamp] StateInfo timestamp
             * @property {Uint8Array|null} [pkiId] StateInfo pkiId
             * @property {Uint8Array|null} [channel_MAC] StateInfo channel_MAC
             * @property {gossip.IProperties|null} [properties] StateInfo properties
             */
    
            /**
             * Constructs a new StateInfo.
             * @memberof gossip
             * @classdesc Represents a StateInfo.
             * @implements IStateInfo
             * @constructor
             * @param {gossip.IStateInfo=} [properties] Properties to set
             */
            function StateInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateInfo timestamp.
             * @member {gossip.IPeerTime|null|undefined} timestamp
             * @memberof gossip.StateInfo
             * @instance
             */
            StateInfo.prototype.timestamp = null;
    
            /**
             * StateInfo pkiId.
             * @member {Uint8Array} pkiId
             * @memberof gossip.StateInfo
             * @instance
             */
            StateInfo.prototype.pkiId = $util.newBuffer([]);
    
            /**
             * StateInfo channel_MAC.
             * @member {Uint8Array} channel_MAC
             * @memberof gossip.StateInfo
             * @instance
             */
            StateInfo.prototype.channel_MAC = $util.newBuffer([]);
    
            /**
             * StateInfo properties.
             * @member {gossip.IProperties|null|undefined} properties
             * @memberof gossip.StateInfo
             * @instance
             */
            StateInfo.prototype.properties = null;
    
            /**
             * Creates a new StateInfo instance using the specified properties.
             * @function create
             * @memberof gossip.StateInfo
             * @static
             * @param {gossip.IStateInfo=} [properties] Properties to set
             * @returns {gossip.StateInfo} StateInfo instance
             */
            StateInfo.create = function create(properties) {
                return new StateInfo(properties);
            };
    
            /**
             * Encodes the specified StateInfo message. Does not implicitly {@link gossip.StateInfo.verify|verify} messages.
             * @function encode
             * @memberof gossip.StateInfo
             * @static
             * @param {gossip.IStateInfo} message StateInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.gossip.PeerTime.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pkiId);
                if (message.channel_MAC != null && message.hasOwnProperty("channel_MAC"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.channel_MAC);
                if (message.properties != null && message.hasOwnProperty("properties"))
                    $root.gossip.Properties.encode(message.properties, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StateInfo message, length delimited. Does not implicitly {@link gossip.StateInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.StateInfo
             * @static
             * @param {gossip.IStateInfo} message StateInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateInfo message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.StateInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.StateInfo} StateInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.StateInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.timestamp = $root.gossip.PeerTime.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.pkiId = reader.bytes();
                        break;
                    case 4:
                        message.channel_MAC = reader.bytes();
                        break;
                    case 5:
                        message.properties = $root.gossip.Properties.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.StateInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.StateInfo} StateInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateInfo message.
             * @function verify
             * @memberof gossip.StateInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.gossip.PeerTime.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    if (!(message.pkiId && typeof message.pkiId.length === "number" || $util.isString(message.pkiId)))
                        return "pkiId: buffer expected";
                if (message.channel_MAC != null && message.hasOwnProperty("channel_MAC"))
                    if (!(message.channel_MAC && typeof message.channel_MAC.length === "number" || $util.isString(message.channel_MAC)))
                        return "channel_MAC: buffer expected";
                if (message.properties != null && message.hasOwnProperty("properties")) {
                    var error = $root.gossip.Properties.verify(message.properties);
                    if (error)
                        return "properties." + error;
                }
                return null;
            };
    
            /**
             * Creates a StateInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.StateInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.StateInfo} StateInfo
             */
            StateInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.StateInfo)
                    return object;
                var message = new $root.gossip.StateInfo();
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".gossip.StateInfo.timestamp: object expected");
                    message.timestamp = $root.gossip.PeerTime.fromObject(object.timestamp);
                }
                if (object.pkiId != null)
                    if (typeof object.pkiId === "string")
                        $util.base64.decode(object.pkiId, message.pkiId = $util.newBuffer($util.base64.length(object.pkiId)), 0);
                    else if (object.pkiId.length)
                        message.pkiId = object.pkiId;
                if (object.channel_MAC != null)
                    if (typeof object.channel_MAC === "string")
                        $util.base64.decode(object.channel_MAC, message.channel_MAC = $util.newBuffer($util.base64.length(object.channel_MAC)), 0);
                    else if (object.channel_MAC.length)
                        message.channel_MAC = object.channel_MAC;
                if (object.properties != null) {
                    if (typeof object.properties !== "object")
                        throw TypeError(".gossip.StateInfo.properties: object expected");
                    message.properties = $root.gossip.Properties.fromObject(object.properties);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StateInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.StateInfo
             * @static
             * @param {gossip.StateInfo} message StateInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.timestamp = null;
                    if (options.bytes === String)
                        object.pkiId = "";
                    else {
                        object.pkiId = [];
                        if (options.bytes !== Array)
                            object.pkiId = $util.newBuffer(object.pkiId);
                    }
                    if (options.bytes === String)
                        object.channel_MAC = "";
                    else {
                        object.channel_MAC = [];
                        if (options.bytes !== Array)
                            object.channel_MAC = $util.newBuffer(object.channel_MAC);
                    }
                    object.properties = null;
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.gossip.PeerTime.toObject(message.timestamp, options);
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    object.pkiId = options.bytes === String ? $util.base64.encode(message.pkiId, 0, message.pkiId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pkiId) : message.pkiId;
                if (message.channel_MAC != null && message.hasOwnProperty("channel_MAC"))
                    object.channel_MAC = options.bytes === String ? $util.base64.encode(message.channel_MAC, 0, message.channel_MAC.length) : options.bytes === Array ? Array.prototype.slice.call(message.channel_MAC) : message.channel_MAC;
                if (message.properties != null && message.hasOwnProperty("properties"))
                    object.properties = $root.gossip.Properties.toObject(message.properties, options);
                return object;
            };
    
            /**
             * Converts this StateInfo to JSON.
             * @function toJSON
             * @memberof gossip.StateInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateInfo;
        })();
    
        gossip.Properties = (function() {
    
            /**
             * Properties of a Properties.
             * @memberof gossip
             * @interface IProperties
             * @property {number|Long|null} [ledgerHeight] Properties ledgerHeight
             * @property {boolean|null} [leftChannel] Properties leftChannel
             * @property {Array.<gossip.IChaincode>|null} [chaincodes] Properties chaincodes
             */
    
            /**
             * Constructs a new Properties.
             * @memberof gossip
             * @classdesc Represents a Properties.
             * @implements IProperties
             * @constructor
             * @param {gossip.IProperties=} [properties] Properties to set
             */
            function Properties(properties) {
                this.chaincodes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Properties ledgerHeight.
             * @member {number|Long} ledgerHeight
             * @memberof gossip.Properties
             * @instance
             */
            Properties.prototype.ledgerHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Properties leftChannel.
             * @member {boolean} leftChannel
             * @memberof gossip.Properties
             * @instance
             */
            Properties.prototype.leftChannel = false;
    
            /**
             * Properties chaincodes.
             * @member {Array.<gossip.IChaincode>} chaincodes
             * @memberof gossip.Properties
             * @instance
             */
            Properties.prototype.chaincodes = $util.emptyArray;
    
            /**
             * Creates a new Properties instance using the specified properties.
             * @function create
             * @memberof gossip.Properties
             * @static
             * @param {gossip.IProperties=} [properties] Properties to set
             * @returns {gossip.Properties} Properties instance
             */
            Properties.create = function create(properties) {
                return new Properties(properties);
            };
    
            /**
             * Encodes the specified Properties message. Does not implicitly {@link gossip.Properties.verify|verify} messages.
             * @function encode
             * @memberof gossip.Properties
             * @static
             * @param {gossip.IProperties} message Properties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Properties.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ledgerHeight != null && message.hasOwnProperty("ledgerHeight"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ledgerHeight);
                if (message.leftChannel != null && message.hasOwnProperty("leftChannel"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.leftChannel);
                if (message.chaincodes != null && message.chaincodes.length)
                    for (var i = 0; i < message.chaincodes.length; ++i)
                        $root.gossip.Chaincode.encode(message.chaincodes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Properties message, length delimited. Does not implicitly {@link gossip.Properties.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Properties
             * @static
             * @param {gossip.IProperties} message Properties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Properties.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Properties message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Properties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Properties} Properties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Properties.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Properties();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ledgerHeight = reader.uint64();
                        break;
                    case 2:
                        message.leftChannel = reader.bool();
                        break;
                    case 3:
                        if (!(message.chaincodes && message.chaincodes.length))
                            message.chaincodes = [];
                        message.chaincodes.push($root.gossip.Chaincode.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Properties message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Properties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Properties} Properties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Properties.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Properties message.
             * @function verify
             * @memberof gossip.Properties
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Properties.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ledgerHeight != null && message.hasOwnProperty("ledgerHeight"))
                    if (!$util.isInteger(message.ledgerHeight) && !(message.ledgerHeight && $util.isInteger(message.ledgerHeight.low) && $util.isInteger(message.ledgerHeight.high)))
                        return "ledgerHeight: integer|Long expected";
                if (message.leftChannel != null && message.hasOwnProperty("leftChannel"))
                    if (typeof message.leftChannel !== "boolean")
                        return "leftChannel: boolean expected";
                if (message.chaincodes != null && message.hasOwnProperty("chaincodes")) {
                    if (!Array.isArray(message.chaincodes))
                        return "chaincodes: array expected";
                    for (var i = 0; i < message.chaincodes.length; ++i) {
                        var error = $root.gossip.Chaincode.verify(message.chaincodes[i]);
                        if (error)
                            return "chaincodes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Properties message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Properties
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Properties} Properties
             */
            Properties.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Properties)
                    return object;
                var message = new $root.gossip.Properties();
                if (object.ledgerHeight != null)
                    if ($util.Long)
                        (message.ledgerHeight = $util.Long.fromValue(object.ledgerHeight)).unsigned = true;
                    else if (typeof object.ledgerHeight === "string")
                        message.ledgerHeight = parseInt(object.ledgerHeight, 10);
                    else if (typeof object.ledgerHeight === "number")
                        message.ledgerHeight = object.ledgerHeight;
                    else if (typeof object.ledgerHeight === "object")
                        message.ledgerHeight = new $util.LongBits(object.ledgerHeight.low >>> 0, object.ledgerHeight.high >>> 0).toNumber(true);
                if (object.leftChannel != null)
                    message.leftChannel = Boolean(object.leftChannel);
                if (object.chaincodes) {
                    if (!Array.isArray(object.chaincodes))
                        throw TypeError(".gossip.Properties.chaincodes: array expected");
                    message.chaincodes = [];
                    for (var i = 0; i < object.chaincodes.length; ++i) {
                        if (typeof object.chaincodes[i] !== "object")
                            throw TypeError(".gossip.Properties.chaincodes: object expected");
                        message.chaincodes[i] = $root.gossip.Chaincode.fromObject(object.chaincodes[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Properties message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Properties
             * @static
             * @param {gossip.Properties} message Properties
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Properties.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.chaincodes = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.ledgerHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ledgerHeight = options.longs === String ? "0" : 0;
                    object.leftChannel = false;
                }
                if (message.ledgerHeight != null && message.hasOwnProperty("ledgerHeight"))
                    if (typeof message.ledgerHeight === "number")
                        object.ledgerHeight = options.longs === String ? String(message.ledgerHeight) : message.ledgerHeight;
                    else
                        object.ledgerHeight = options.longs === String ? $util.Long.prototype.toString.call(message.ledgerHeight) : options.longs === Number ? new $util.LongBits(message.ledgerHeight.low >>> 0, message.ledgerHeight.high >>> 0).toNumber(true) : message.ledgerHeight;
                if (message.leftChannel != null && message.hasOwnProperty("leftChannel"))
                    object.leftChannel = message.leftChannel;
                if (message.chaincodes && message.chaincodes.length) {
                    object.chaincodes = [];
                    for (var j = 0; j < message.chaincodes.length; ++j)
                        object.chaincodes[j] = $root.gossip.Chaincode.toObject(message.chaincodes[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Properties to JSON.
             * @function toJSON
             * @memberof gossip.Properties
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Properties.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Properties;
        })();
    
        gossip.StateInfoSnapshot = (function() {
    
            /**
             * Properties of a StateInfoSnapshot.
             * @memberof gossip
             * @interface IStateInfoSnapshot
             * @property {Array.<gossip.IEnvelope>|null} [elements] StateInfoSnapshot elements
             */
    
            /**
             * Constructs a new StateInfoSnapshot.
             * @memberof gossip
             * @classdesc Represents a StateInfoSnapshot.
             * @implements IStateInfoSnapshot
             * @constructor
             * @param {gossip.IStateInfoSnapshot=} [properties] Properties to set
             */
            function StateInfoSnapshot(properties) {
                this.elements = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateInfoSnapshot elements.
             * @member {Array.<gossip.IEnvelope>} elements
             * @memberof gossip.StateInfoSnapshot
             * @instance
             */
            StateInfoSnapshot.prototype.elements = $util.emptyArray;
    
            /**
             * Creates a new StateInfoSnapshot instance using the specified properties.
             * @function create
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {gossip.IStateInfoSnapshot=} [properties] Properties to set
             * @returns {gossip.StateInfoSnapshot} StateInfoSnapshot instance
             */
            StateInfoSnapshot.create = function create(properties) {
                return new StateInfoSnapshot(properties);
            };
    
            /**
             * Encodes the specified StateInfoSnapshot message. Does not implicitly {@link gossip.StateInfoSnapshot.verify|verify} messages.
             * @function encode
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {gossip.IStateInfoSnapshot} message StateInfoSnapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateInfoSnapshot.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.elements != null && message.elements.length)
                    for (var i = 0; i < message.elements.length; ++i)
                        $root.gossip.Envelope.encode(message.elements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StateInfoSnapshot message, length delimited. Does not implicitly {@link gossip.StateInfoSnapshot.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {gossip.IStateInfoSnapshot} message StateInfoSnapshot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateInfoSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateInfoSnapshot message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.StateInfoSnapshot} StateInfoSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateInfoSnapshot.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.StateInfoSnapshot();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.elements && message.elements.length))
                            message.elements = [];
                        message.elements.push($root.gossip.Envelope.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateInfoSnapshot message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.StateInfoSnapshot} StateInfoSnapshot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateInfoSnapshot.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateInfoSnapshot message.
             * @function verify
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateInfoSnapshot.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (var i = 0; i < message.elements.length; ++i) {
                        var error = $root.gossip.Envelope.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a StateInfoSnapshot message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.StateInfoSnapshot} StateInfoSnapshot
             */
            StateInfoSnapshot.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.StateInfoSnapshot)
                    return object;
                var message = new $root.gossip.StateInfoSnapshot();
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".gossip.StateInfoSnapshot.elements: array expected");
                    message.elements = [];
                    for (var i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".gossip.StateInfoSnapshot.elements: object expected");
                        message.elements[i] = $root.gossip.Envelope.fromObject(object.elements[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StateInfoSnapshot message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.StateInfoSnapshot
             * @static
             * @param {gossip.StateInfoSnapshot} message StateInfoSnapshot
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateInfoSnapshot.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (var j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.gossip.Envelope.toObject(message.elements[j], options);
                }
                return object;
            };
    
            /**
             * Converts this StateInfoSnapshot to JSON.
             * @function toJSON
             * @memberof gossip.StateInfoSnapshot
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateInfoSnapshot.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateInfoSnapshot;
        })();
    
        gossip.StateInfoPullRequest = (function() {
    
            /**
             * Properties of a StateInfoPullRequest.
             * @memberof gossip
             * @interface IStateInfoPullRequest
             * @property {Uint8Array|null} [channel_MAC] StateInfoPullRequest channel_MAC
             */
    
            /**
             * Constructs a new StateInfoPullRequest.
             * @memberof gossip
             * @classdesc Represents a StateInfoPullRequest.
             * @implements IStateInfoPullRequest
             * @constructor
             * @param {gossip.IStateInfoPullRequest=} [properties] Properties to set
             */
            function StateInfoPullRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateInfoPullRequest channel_MAC.
             * @member {Uint8Array} channel_MAC
             * @memberof gossip.StateInfoPullRequest
             * @instance
             */
            StateInfoPullRequest.prototype.channel_MAC = $util.newBuffer([]);
    
            /**
             * Creates a new StateInfoPullRequest instance using the specified properties.
             * @function create
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {gossip.IStateInfoPullRequest=} [properties] Properties to set
             * @returns {gossip.StateInfoPullRequest} StateInfoPullRequest instance
             */
            StateInfoPullRequest.create = function create(properties) {
                return new StateInfoPullRequest(properties);
            };
    
            /**
             * Encodes the specified StateInfoPullRequest message. Does not implicitly {@link gossip.StateInfoPullRequest.verify|verify} messages.
             * @function encode
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {gossip.IStateInfoPullRequest} message StateInfoPullRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateInfoPullRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel_MAC != null && message.hasOwnProperty("channel_MAC"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.channel_MAC);
                return writer;
            };
    
            /**
             * Encodes the specified StateInfoPullRequest message, length delimited. Does not implicitly {@link gossip.StateInfoPullRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {gossip.IStateInfoPullRequest} message StateInfoPullRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateInfoPullRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateInfoPullRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.StateInfoPullRequest} StateInfoPullRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateInfoPullRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.StateInfoPullRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel_MAC = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateInfoPullRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.StateInfoPullRequest} StateInfoPullRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateInfoPullRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateInfoPullRequest message.
             * @function verify
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateInfoPullRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel_MAC != null && message.hasOwnProperty("channel_MAC"))
                    if (!(message.channel_MAC && typeof message.channel_MAC.length === "number" || $util.isString(message.channel_MAC)))
                        return "channel_MAC: buffer expected";
                return null;
            };
    
            /**
             * Creates a StateInfoPullRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.StateInfoPullRequest} StateInfoPullRequest
             */
            StateInfoPullRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.StateInfoPullRequest)
                    return object;
                var message = new $root.gossip.StateInfoPullRequest();
                if (object.channel_MAC != null)
                    if (typeof object.channel_MAC === "string")
                        $util.base64.decode(object.channel_MAC, message.channel_MAC = $util.newBuffer($util.base64.length(object.channel_MAC)), 0);
                    else if (object.channel_MAC.length)
                        message.channel_MAC = object.channel_MAC;
                return message;
            };
    
            /**
             * Creates a plain object from a StateInfoPullRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.StateInfoPullRequest
             * @static
             * @param {gossip.StateInfoPullRequest} message StateInfoPullRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateInfoPullRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.channel_MAC = "";
                    else {
                        object.channel_MAC = [];
                        if (options.bytes !== Array)
                            object.channel_MAC = $util.newBuffer(object.channel_MAC);
                    }
                if (message.channel_MAC != null && message.hasOwnProperty("channel_MAC"))
                    object.channel_MAC = options.bytes === String ? $util.base64.encode(message.channel_MAC, 0, message.channel_MAC.length) : options.bytes === Array ? Array.prototype.slice.call(message.channel_MAC) : message.channel_MAC;
                return object;
            };
    
            /**
             * Converts this StateInfoPullRequest to JSON.
             * @function toJSON
             * @memberof gossip.StateInfoPullRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateInfoPullRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateInfoPullRequest;
        })();
    
        gossip.ConnEstablish = (function() {
    
            /**
             * Properties of a ConnEstablish.
             * @memberof gossip
             * @interface IConnEstablish
             * @property {Uint8Array|null} [pkiId] ConnEstablish pkiId
             * @property {Uint8Array|null} [identity] ConnEstablish identity
             * @property {Uint8Array|null} [tlsCertHash] ConnEstablish tlsCertHash
             */
    
            /**
             * Constructs a new ConnEstablish.
             * @memberof gossip
             * @classdesc Represents a ConnEstablish.
             * @implements IConnEstablish
             * @constructor
             * @param {gossip.IConnEstablish=} [properties] Properties to set
             */
            function ConnEstablish(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConnEstablish pkiId.
             * @member {Uint8Array} pkiId
             * @memberof gossip.ConnEstablish
             * @instance
             */
            ConnEstablish.prototype.pkiId = $util.newBuffer([]);
    
            /**
             * ConnEstablish identity.
             * @member {Uint8Array} identity
             * @memberof gossip.ConnEstablish
             * @instance
             */
            ConnEstablish.prototype.identity = $util.newBuffer([]);
    
            /**
             * ConnEstablish tlsCertHash.
             * @member {Uint8Array} tlsCertHash
             * @memberof gossip.ConnEstablish
             * @instance
             */
            ConnEstablish.prototype.tlsCertHash = $util.newBuffer([]);
    
            /**
             * Creates a new ConnEstablish instance using the specified properties.
             * @function create
             * @memberof gossip.ConnEstablish
             * @static
             * @param {gossip.IConnEstablish=} [properties] Properties to set
             * @returns {gossip.ConnEstablish} ConnEstablish instance
             */
            ConnEstablish.create = function create(properties) {
                return new ConnEstablish(properties);
            };
    
            /**
             * Encodes the specified ConnEstablish message. Does not implicitly {@link gossip.ConnEstablish.verify|verify} messages.
             * @function encode
             * @memberof gossip.ConnEstablish
             * @static
             * @param {gossip.IConnEstablish} message ConnEstablish message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnEstablish.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pkiId);
                if (message.identity != null && message.hasOwnProperty("identity"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.identity);
                if (message.tlsCertHash != null && message.hasOwnProperty("tlsCertHash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.tlsCertHash);
                return writer;
            };
    
            /**
             * Encodes the specified ConnEstablish message, length delimited. Does not implicitly {@link gossip.ConnEstablish.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.ConnEstablish
             * @static
             * @param {gossip.IConnEstablish} message ConnEstablish message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConnEstablish.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConnEstablish message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.ConnEstablish
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.ConnEstablish} ConnEstablish
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnEstablish.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.ConnEstablish();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pkiId = reader.bytes();
                        break;
                    case 2:
                        message.identity = reader.bytes();
                        break;
                    case 3:
                        message.tlsCertHash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConnEstablish message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.ConnEstablish
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.ConnEstablish} ConnEstablish
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConnEstablish.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConnEstablish message.
             * @function verify
             * @memberof gossip.ConnEstablish
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConnEstablish.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    if (!(message.pkiId && typeof message.pkiId.length === "number" || $util.isString(message.pkiId)))
                        return "pkiId: buffer expected";
                if (message.identity != null && message.hasOwnProperty("identity"))
                    if (!(message.identity && typeof message.identity.length === "number" || $util.isString(message.identity)))
                        return "identity: buffer expected";
                if (message.tlsCertHash != null && message.hasOwnProperty("tlsCertHash"))
                    if (!(message.tlsCertHash && typeof message.tlsCertHash.length === "number" || $util.isString(message.tlsCertHash)))
                        return "tlsCertHash: buffer expected";
                return null;
            };
    
            /**
             * Creates a ConnEstablish message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.ConnEstablish
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.ConnEstablish} ConnEstablish
             */
            ConnEstablish.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.ConnEstablish)
                    return object;
                var message = new $root.gossip.ConnEstablish();
                if (object.pkiId != null)
                    if (typeof object.pkiId === "string")
                        $util.base64.decode(object.pkiId, message.pkiId = $util.newBuffer($util.base64.length(object.pkiId)), 0);
                    else if (object.pkiId.length)
                        message.pkiId = object.pkiId;
                if (object.identity != null)
                    if (typeof object.identity === "string")
                        $util.base64.decode(object.identity, message.identity = $util.newBuffer($util.base64.length(object.identity)), 0);
                    else if (object.identity.length)
                        message.identity = object.identity;
                if (object.tlsCertHash != null)
                    if (typeof object.tlsCertHash === "string")
                        $util.base64.decode(object.tlsCertHash, message.tlsCertHash = $util.newBuffer($util.base64.length(object.tlsCertHash)), 0);
                    else if (object.tlsCertHash.length)
                        message.tlsCertHash = object.tlsCertHash;
                return message;
            };
    
            /**
             * Creates a plain object from a ConnEstablish message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.ConnEstablish
             * @static
             * @param {gossip.ConnEstablish} message ConnEstablish
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConnEstablish.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.pkiId = "";
                    else {
                        object.pkiId = [];
                        if (options.bytes !== Array)
                            object.pkiId = $util.newBuffer(object.pkiId);
                    }
                    if (options.bytes === String)
                        object.identity = "";
                    else {
                        object.identity = [];
                        if (options.bytes !== Array)
                            object.identity = $util.newBuffer(object.identity);
                    }
                    if (options.bytes === String)
                        object.tlsCertHash = "";
                    else {
                        object.tlsCertHash = [];
                        if (options.bytes !== Array)
                            object.tlsCertHash = $util.newBuffer(object.tlsCertHash);
                    }
                }
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    object.pkiId = options.bytes === String ? $util.base64.encode(message.pkiId, 0, message.pkiId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pkiId) : message.pkiId;
                if (message.identity != null && message.hasOwnProperty("identity"))
                    object.identity = options.bytes === String ? $util.base64.encode(message.identity, 0, message.identity.length) : options.bytes === Array ? Array.prototype.slice.call(message.identity) : message.identity;
                if (message.tlsCertHash != null && message.hasOwnProperty("tlsCertHash"))
                    object.tlsCertHash = options.bytes === String ? $util.base64.encode(message.tlsCertHash, 0, message.tlsCertHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.tlsCertHash) : message.tlsCertHash;
                return object;
            };
    
            /**
             * Converts this ConnEstablish to JSON.
             * @function toJSON
             * @memberof gossip.ConnEstablish
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConnEstablish.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConnEstablish;
        })();
    
        gossip.PeerIdentity = (function() {
    
            /**
             * Properties of a PeerIdentity.
             * @memberof gossip
             * @interface IPeerIdentity
             * @property {Uint8Array|null} [pkiId] PeerIdentity pkiId
             * @property {Uint8Array|null} [cert] PeerIdentity cert
             * @property {Uint8Array|null} [metadata] PeerIdentity metadata
             */
    
            /**
             * Constructs a new PeerIdentity.
             * @memberof gossip
             * @classdesc Represents a PeerIdentity.
             * @implements IPeerIdentity
             * @constructor
             * @param {gossip.IPeerIdentity=} [properties] Properties to set
             */
            function PeerIdentity(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PeerIdentity pkiId.
             * @member {Uint8Array} pkiId
             * @memberof gossip.PeerIdentity
             * @instance
             */
            PeerIdentity.prototype.pkiId = $util.newBuffer([]);
    
            /**
             * PeerIdentity cert.
             * @member {Uint8Array} cert
             * @memberof gossip.PeerIdentity
             * @instance
             */
            PeerIdentity.prototype.cert = $util.newBuffer([]);
    
            /**
             * PeerIdentity metadata.
             * @member {Uint8Array} metadata
             * @memberof gossip.PeerIdentity
             * @instance
             */
            PeerIdentity.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Creates a new PeerIdentity instance using the specified properties.
             * @function create
             * @memberof gossip.PeerIdentity
             * @static
             * @param {gossip.IPeerIdentity=} [properties] Properties to set
             * @returns {gossip.PeerIdentity} PeerIdentity instance
             */
            PeerIdentity.create = function create(properties) {
                return new PeerIdentity(properties);
            };
    
            /**
             * Encodes the specified PeerIdentity message. Does not implicitly {@link gossip.PeerIdentity.verify|verify} messages.
             * @function encode
             * @memberof gossip.PeerIdentity
             * @static
             * @param {gossip.IPeerIdentity} message PeerIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerIdentity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pkiId);
                if (message.cert != null && message.hasOwnProperty("cert"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.cert);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.metadata);
                return writer;
            };
    
            /**
             * Encodes the specified PeerIdentity message, length delimited. Does not implicitly {@link gossip.PeerIdentity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PeerIdentity
             * @static
             * @param {gossip.IPeerIdentity} message PeerIdentity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerIdentity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PeerIdentity message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PeerIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PeerIdentity} PeerIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerIdentity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PeerIdentity();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pkiId = reader.bytes();
                        break;
                    case 2:
                        message.cert = reader.bytes();
                        break;
                    case 3:
                        message.metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PeerIdentity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PeerIdentity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PeerIdentity} PeerIdentity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerIdentity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PeerIdentity message.
             * @function verify
             * @memberof gossip.PeerIdentity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerIdentity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    if (!(message.pkiId && typeof message.pkiId.length === "number" || $util.isString(message.pkiId)))
                        return "pkiId: buffer expected";
                if (message.cert != null && message.hasOwnProperty("cert"))
                    if (!(message.cert && typeof message.cert.length === "number" || $util.isString(message.cert)))
                        return "cert: buffer expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates a PeerIdentity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PeerIdentity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PeerIdentity} PeerIdentity
             */
            PeerIdentity.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PeerIdentity)
                    return object;
                var message = new $root.gossip.PeerIdentity();
                if (object.pkiId != null)
                    if (typeof object.pkiId === "string")
                        $util.base64.decode(object.pkiId, message.pkiId = $util.newBuffer($util.base64.length(object.pkiId)), 0);
                    else if (object.pkiId.length)
                        message.pkiId = object.pkiId;
                if (object.cert != null)
                    if (typeof object.cert === "string")
                        $util.base64.decode(object.cert, message.cert = $util.newBuffer($util.base64.length(object.cert)), 0);
                    else if (object.cert.length)
                        message.cert = object.cert;
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                return message;
            };
    
            /**
             * Creates a plain object from a PeerIdentity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PeerIdentity
             * @static
             * @param {gossip.PeerIdentity} message PeerIdentity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerIdentity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.pkiId = "";
                    else {
                        object.pkiId = [];
                        if (options.bytes !== Array)
                            object.pkiId = $util.newBuffer(object.pkiId);
                    }
                    if (options.bytes === String)
                        object.cert = "";
                    else {
                        object.cert = [];
                        if (options.bytes !== Array)
                            object.cert = $util.newBuffer(object.cert);
                    }
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                }
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    object.pkiId = options.bytes === String ? $util.base64.encode(message.pkiId, 0, message.pkiId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pkiId) : message.pkiId;
                if (message.cert != null && message.hasOwnProperty("cert"))
                    object.cert = options.bytes === String ? $util.base64.encode(message.cert, 0, message.cert.length) : options.bytes === Array ? Array.prototype.slice.call(message.cert) : message.cert;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                return object;
            };
    
            /**
             * Converts this PeerIdentity to JSON.
             * @function toJSON
             * @memberof gossip.PeerIdentity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerIdentity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PeerIdentity;
        })();
    
        /**
         * PullMsgType enum.
         * @name gossip.PullMsgType
         * @enum {string}
         * @property {number} UNDEFINED=0 UNDEFINED value
         * @property {number} BLOCK_MSG=1 BLOCK_MSG value
         * @property {number} IDENTITY_MSG=2 IDENTITY_MSG value
         */
        gossip.PullMsgType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNDEFINED"] = 0;
            values[valuesById[1] = "BLOCK_MSG"] = 1;
            values[valuesById[2] = "IDENTITY_MSG"] = 2;
            return values;
        })();
    
        gossip.DataRequest = (function() {
    
            /**
             * Properties of a DataRequest.
             * @memberof gossip
             * @interface IDataRequest
             * @property {number|Long|null} [nonce] DataRequest nonce
             * @property {Array.<Uint8Array>|null} [digests] DataRequest digests
             * @property {gossip.PullMsgType|null} [msgType] DataRequest msgType
             */
    
            /**
             * Constructs a new DataRequest.
             * @memberof gossip
             * @classdesc Represents a DataRequest.
             * @implements IDataRequest
             * @constructor
             * @param {gossip.IDataRequest=} [properties] Properties to set
             */
            function DataRequest(properties) {
                this.digests = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DataRequest nonce.
             * @member {number|Long} nonce
             * @memberof gossip.DataRequest
             * @instance
             */
            DataRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * DataRequest digests.
             * @member {Array.<Uint8Array>} digests
             * @memberof gossip.DataRequest
             * @instance
             */
            DataRequest.prototype.digests = $util.emptyArray;
    
            /**
             * DataRequest msgType.
             * @member {gossip.PullMsgType} msgType
             * @memberof gossip.DataRequest
             * @instance
             */
            DataRequest.prototype.msgType = 0;
    
            /**
             * Creates a new DataRequest instance using the specified properties.
             * @function create
             * @memberof gossip.DataRequest
             * @static
             * @param {gossip.IDataRequest=} [properties] Properties to set
             * @returns {gossip.DataRequest} DataRequest instance
             */
            DataRequest.create = function create(properties) {
                return new DataRequest(properties);
            };
    
            /**
             * Encodes the specified DataRequest message. Does not implicitly {@link gossip.DataRequest.verify|verify} messages.
             * @function encode
             * @memberof gossip.DataRequest
             * @static
             * @param {gossip.IDataRequest} message DataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.digests != null && message.digests.length)
                    for (var i = 0; i < message.digests.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.digests[i]);
                if (message.msgType != null && message.hasOwnProperty("msgType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.msgType);
                return writer;
            };
    
            /**
             * Encodes the specified DataRequest message, length delimited. Does not implicitly {@link gossip.DataRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.DataRequest
             * @static
             * @param {gossip.IDataRequest} message DataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DataRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.DataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.DataRequest} DataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.DataRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        if (!(message.digests && message.digests.length))
                            message.digests = [];
                        message.digests.push(reader.bytes());
                        break;
                    case 3:
                        message.msgType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DataRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.DataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.DataRequest} DataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DataRequest message.
             * @function verify
             * @memberof gossip.DataRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.digests != null && message.hasOwnProperty("digests")) {
                    if (!Array.isArray(message.digests))
                        return "digests: array expected";
                    for (var i = 0; i < message.digests.length; ++i)
                        if (!(message.digests[i] && typeof message.digests[i].length === "number" || $util.isString(message.digests[i])))
                            return "digests: buffer[] expected";
                }
                if (message.msgType != null && message.hasOwnProperty("msgType"))
                    switch (message.msgType) {
                    default:
                        return "msgType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a DataRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.DataRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.DataRequest} DataRequest
             */
            DataRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.DataRequest)
                    return object;
                var message = new $root.gossip.DataRequest();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.digests) {
                    if (!Array.isArray(object.digests))
                        throw TypeError(".gossip.DataRequest.digests: array expected");
                    message.digests = [];
                    for (var i = 0; i < object.digests.length; ++i)
                        if (typeof object.digests[i] === "string")
                            $util.base64.decode(object.digests[i], message.digests[i] = $util.newBuffer($util.base64.length(object.digests[i])), 0);
                        else if (object.digests[i].length)
                            message.digests[i] = object.digests[i];
                }
                switch (object.msgType) {
                case "UNDEFINED":
                case 0:
                    message.msgType = 0;
                    break;
                case "BLOCK_MSG":
                case 1:
                    message.msgType = 1;
                    break;
                case "IDENTITY_MSG":
                case 2:
                    message.msgType = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DataRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.DataRequest
             * @static
             * @param {gossip.DataRequest} message DataRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.digests = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    object.msgType = options.enums === String ? "UNDEFINED" : 0;
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.digests && message.digests.length) {
                    object.digests = [];
                    for (var j = 0; j < message.digests.length; ++j)
                        object.digests[j] = options.bytes === String ? $util.base64.encode(message.digests[j], 0, message.digests[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.digests[j]) : message.digests[j];
                }
                if (message.msgType != null && message.hasOwnProperty("msgType"))
                    object.msgType = options.enums === String ? $root.gossip.PullMsgType[message.msgType] : message.msgType;
                return object;
            };
    
            /**
             * Converts this DataRequest to JSON.
             * @function toJSON
             * @memberof gossip.DataRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DataRequest;
        })();
    
        gossip.GossipHello = (function() {
    
            /**
             * Properties of a GossipHello.
             * @memberof gossip
             * @interface IGossipHello
             * @property {number|Long|null} [nonce] GossipHello nonce
             * @property {Uint8Array|null} [metadata] GossipHello metadata
             * @property {gossip.PullMsgType|null} [msgType] GossipHello msgType
             */
    
            /**
             * Constructs a new GossipHello.
             * @memberof gossip
             * @classdesc Represents a GossipHello.
             * @implements IGossipHello
             * @constructor
             * @param {gossip.IGossipHello=} [properties] Properties to set
             */
            function GossipHello(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GossipHello nonce.
             * @member {number|Long} nonce
             * @memberof gossip.GossipHello
             * @instance
             */
            GossipHello.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * GossipHello metadata.
             * @member {Uint8Array} metadata
             * @memberof gossip.GossipHello
             * @instance
             */
            GossipHello.prototype.metadata = $util.newBuffer([]);
    
            /**
             * GossipHello msgType.
             * @member {gossip.PullMsgType} msgType
             * @memberof gossip.GossipHello
             * @instance
             */
            GossipHello.prototype.msgType = 0;
    
            /**
             * Creates a new GossipHello instance using the specified properties.
             * @function create
             * @memberof gossip.GossipHello
             * @static
             * @param {gossip.IGossipHello=} [properties] Properties to set
             * @returns {gossip.GossipHello} GossipHello instance
             */
            GossipHello.create = function create(properties) {
                return new GossipHello(properties);
            };
    
            /**
             * Encodes the specified GossipHello message. Does not implicitly {@link gossip.GossipHello.verify|verify} messages.
             * @function encode
             * @memberof gossip.GossipHello
             * @static
             * @param {gossip.IGossipHello} message GossipHello message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GossipHello.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.metadata);
                if (message.msgType != null && message.hasOwnProperty("msgType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.msgType);
                return writer;
            };
    
            /**
             * Encodes the specified GossipHello message, length delimited. Does not implicitly {@link gossip.GossipHello.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.GossipHello
             * @static
             * @param {gossip.IGossipHello} message GossipHello message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GossipHello.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GossipHello message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.GossipHello
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.GossipHello} GossipHello
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GossipHello.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.GossipHello();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        message.metadata = reader.bytes();
                        break;
                    case 3:
                        message.msgType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GossipHello message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.GossipHello
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.GossipHello} GossipHello
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GossipHello.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GossipHello message.
             * @function verify
             * @memberof gossip.GossipHello
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GossipHello.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                if (message.msgType != null && message.hasOwnProperty("msgType"))
                    switch (message.msgType) {
                    default:
                        return "msgType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a GossipHello message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.GossipHello
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.GossipHello} GossipHello
             */
            GossipHello.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.GossipHello)
                    return object;
                var message = new $root.gossip.GossipHello();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                switch (object.msgType) {
                case "UNDEFINED":
                case 0:
                    message.msgType = 0;
                    break;
                case "BLOCK_MSG":
                case 1:
                    message.msgType = 1;
                    break;
                case "IDENTITY_MSG":
                case 2:
                    message.msgType = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a GossipHello message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.GossipHello
             * @static
             * @param {gossip.GossipHello} message GossipHello
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GossipHello.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                    object.msgType = options.enums === String ? "UNDEFINED" : 0;
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                if (message.msgType != null && message.hasOwnProperty("msgType"))
                    object.msgType = options.enums === String ? $root.gossip.PullMsgType[message.msgType] : message.msgType;
                return object;
            };
    
            /**
             * Converts this GossipHello to JSON.
             * @function toJSON
             * @memberof gossip.GossipHello
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GossipHello.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GossipHello;
        })();
    
        gossip.DataUpdate = (function() {
    
            /**
             * Properties of a DataUpdate.
             * @memberof gossip
             * @interface IDataUpdate
             * @property {number|Long|null} [nonce] DataUpdate nonce
             * @property {Array.<gossip.IEnvelope>|null} [data] DataUpdate data
             * @property {gossip.PullMsgType|null} [msgType] DataUpdate msgType
             */
    
            /**
             * Constructs a new DataUpdate.
             * @memberof gossip
             * @classdesc Represents a DataUpdate.
             * @implements IDataUpdate
             * @constructor
             * @param {gossip.IDataUpdate=} [properties] Properties to set
             */
            function DataUpdate(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DataUpdate nonce.
             * @member {number|Long} nonce
             * @memberof gossip.DataUpdate
             * @instance
             */
            DataUpdate.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * DataUpdate data.
             * @member {Array.<gossip.IEnvelope>} data
             * @memberof gossip.DataUpdate
             * @instance
             */
            DataUpdate.prototype.data = $util.emptyArray;
    
            /**
             * DataUpdate msgType.
             * @member {gossip.PullMsgType} msgType
             * @memberof gossip.DataUpdate
             * @instance
             */
            DataUpdate.prototype.msgType = 0;
    
            /**
             * Creates a new DataUpdate instance using the specified properties.
             * @function create
             * @memberof gossip.DataUpdate
             * @static
             * @param {gossip.IDataUpdate=} [properties] Properties to set
             * @returns {gossip.DataUpdate} DataUpdate instance
             */
            DataUpdate.create = function create(properties) {
                return new DataUpdate(properties);
            };
    
            /**
             * Encodes the specified DataUpdate message. Does not implicitly {@link gossip.DataUpdate.verify|verify} messages.
             * @function encode
             * @memberof gossip.DataUpdate
             * @static
             * @param {gossip.IDataUpdate} message DataUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataUpdate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.data != null && message.data.length)
                    for (var i = 0; i < message.data.length; ++i)
                        $root.gossip.Envelope.encode(message.data[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.msgType != null && message.hasOwnProperty("msgType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.msgType);
                return writer;
            };
    
            /**
             * Encodes the specified DataUpdate message, length delimited. Does not implicitly {@link gossip.DataUpdate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.DataUpdate
             * @static
             * @param {gossip.IDataUpdate} message DataUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DataUpdate message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.DataUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.DataUpdate} DataUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataUpdate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.DataUpdate();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        if (!(message.data && message.data.length))
                            message.data = [];
                        message.data.push($root.gossip.Envelope.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.msgType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DataUpdate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.DataUpdate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.DataUpdate} DataUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataUpdate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DataUpdate message.
             * @function verify
             * @memberof gossip.DataUpdate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataUpdate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i) {
                        var error = $root.gossip.Envelope.verify(message.data[i]);
                        if (error)
                            return "data." + error;
                    }
                }
                if (message.msgType != null && message.hasOwnProperty("msgType"))
                    switch (message.msgType) {
                    default:
                        return "msgType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a DataUpdate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.DataUpdate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.DataUpdate} DataUpdate
             */
            DataUpdate.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.DataUpdate)
                    return object;
                var message = new $root.gossip.DataUpdate();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".gossip.DataUpdate.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i) {
                        if (typeof object.data[i] !== "object")
                            throw TypeError(".gossip.DataUpdate.data: object expected");
                        message.data[i] = $root.gossip.Envelope.fromObject(object.data[i]);
                    }
                }
                switch (object.msgType) {
                case "UNDEFINED":
                case 0:
                    message.msgType = 0;
                    break;
                case "BLOCK_MSG":
                case 1:
                    message.msgType = 1;
                    break;
                case "IDENTITY_MSG":
                case 2:
                    message.msgType = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DataUpdate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.DataUpdate
             * @static
             * @param {gossip.DataUpdate} message DataUpdate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataUpdate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    object.msgType = options.enums === String ? "UNDEFINED" : 0;
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = $root.gossip.Envelope.toObject(message.data[j], options);
                }
                if (message.msgType != null && message.hasOwnProperty("msgType"))
                    object.msgType = options.enums === String ? $root.gossip.PullMsgType[message.msgType] : message.msgType;
                return object;
            };
    
            /**
             * Converts this DataUpdate to JSON.
             * @function toJSON
             * @memberof gossip.DataUpdate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataUpdate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DataUpdate;
        })();
    
        gossip.DataDigest = (function() {
    
            /**
             * Properties of a DataDigest.
             * @memberof gossip
             * @interface IDataDigest
             * @property {number|Long|null} [nonce] DataDigest nonce
             * @property {Array.<Uint8Array>|null} [digests] DataDigest digests
             * @property {gossip.PullMsgType|null} [msgType] DataDigest msgType
             */
    
            /**
             * Constructs a new DataDigest.
             * @memberof gossip
             * @classdesc Represents a DataDigest.
             * @implements IDataDigest
             * @constructor
             * @param {gossip.IDataDigest=} [properties] Properties to set
             */
            function DataDigest(properties) {
                this.digests = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DataDigest nonce.
             * @member {number|Long} nonce
             * @memberof gossip.DataDigest
             * @instance
             */
            DataDigest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * DataDigest digests.
             * @member {Array.<Uint8Array>} digests
             * @memberof gossip.DataDigest
             * @instance
             */
            DataDigest.prototype.digests = $util.emptyArray;
    
            /**
             * DataDigest msgType.
             * @member {gossip.PullMsgType} msgType
             * @memberof gossip.DataDigest
             * @instance
             */
            DataDigest.prototype.msgType = 0;
    
            /**
             * Creates a new DataDigest instance using the specified properties.
             * @function create
             * @memberof gossip.DataDigest
             * @static
             * @param {gossip.IDataDigest=} [properties] Properties to set
             * @returns {gossip.DataDigest} DataDigest instance
             */
            DataDigest.create = function create(properties) {
                return new DataDigest(properties);
            };
    
            /**
             * Encodes the specified DataDigest message. Does not implicitly {@link gossip.DataDigest.verify|verify} messages.
             * @function encode
             * @memberof gossip.DataDigest
             * @static
             * @param {gossip.IDataDigest} message DataDigest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataDigest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                if (message.digests != null && message.digests.length)
                    for (var i = 0; i < message.digests.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.digests[i]);
                if (message.msgType != null && message.hasOwnProperty("msgType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.msgType);
                return writer;
            };
    
            /**
             * Encodes the specified DataDigest message, length delimited. Does not implicitly {@link gossip.DataDigest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.DataDigest
             * @static
             * @param {gossip.IDataDigest} message DataDigest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataDigest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DataDigest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.DataDigest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.DataDigest} DataDigest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataDigest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.DataDigest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nonce = reader.uint64();
                        break;
                    case 2:
                        if (!(message.digests && message.digests.length))
                            message.digests = [];
                        message.digests.push(reader.bytes());
                        break;
                    case 3:
                        message.msgType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DataDigest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.DataDigest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.DataDigest} DataDigest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataDigest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DataDigest message.
             * @function verify
             * @memberof gossip.DataDigest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataDigest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                        return "nonce: integer|Long expected";
                if (message.digests != null && message.hasOwnProperty("digests")) {
                    if (!Array.isArray(message.digests))
                        return "digests: array expected";
                    for (var i = 0; i < message.digests.length; ++i)
                        if (!(message.digests[i] && typeof message.digests[i].length === "number" || $util.isString(message.digests[i])))
                            return "digests: buffer[] expected";
                }
                if (message.msgType != null && message.hasOwnProperty("msgType"))
                    switch (message.msgType) {
                    default:
                        return "msgType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a DataDigest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.DataDigest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.DataDigest} DataDigest
             */
            DataDigest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.DataDigest)
                    return object;
                var message = new $root.gossip.DataDigest();
                if (object.nonce != null)
                    if ($util.Long)
                        (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                    else if (typeof object.nonce === "string")
                        message.nonce = parseInt(object.nonce, 10);
                    else if (typeof object.nonce === "number")
                        message.nonce = object.nonce;
                    else if (typeof object.nonce === "object")
                        message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                if (object.digests) {
                    if (!Array.isArray(object.digests))
                        throw TypeError(".gossip.DataDigest.digests: array expected");
                    message.digests = [];
                    for (var i = 0; i < object.digests.length; ++i)
                        if (typeof object.digests[i] === "string")
                            $util.base64.decode(object.digests[i], message.digests[i] = $util.newBuffer($util.base64.length(object.digests[i])), 0);
                        else if (object.digests[i].length)
                            message.digests[i] = object.digests[i];
                }
                switch (object.msgType) {
                case "UNDEFINED":
                case 0:
                    message.msgType = 0;
                    break;
                case "BLOCK_MSG":
                case 1:
                    message.msgType = 1;
                    break;
                case "IDENTITY_MSG":
                case 2:
                    message.msgType = 2;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DataDigest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.DataDigest
             * @static
             * @param {gossip.DataDigest} message DataDigest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataDigest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.digests = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nonce = options.longs === String ? "0" : 0;
                    object.msgType = options.enums === String ? "UNDEFINED" : 0;
                }
                if (message.nonce != null && message.hasOwnProperty("nonce"))
                    if (typeof message.nonce === "number")
                        object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                    else
                        object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                if (message.digests && message.digests.length) {
                    object.digests = [];
                    for (var j = 0; j < message.digests.length; ++j)
                        object.digests[j] = options.bytes === String ? $util.base64.encode(message.digests[j], 0, message.digests[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.digests[j]) : message.digests[j];
                }
                if (message.msgType != null && message.hasOwnProperty("msgType"))
                    object.msgType = options.enums === String ? $root.gossip.PullMsgType[message.msgType] : message.msgType;
                return object;
            };
    
            /**
             * Converts this DataDigest to JSON.
             * @function toJSON
             * @memberof gossip.DataDigest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataDigest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DataDigest;
        })();
    
        gossip.DataMessage = (function() {
    
            /**
             * Properties of a DataMessage.
             * @memberof gossip
             * @interface IDataMessage
             * @property {gossip.IPayload|null} [payload] DataMessage payload
             */
    
            /**
             * Constructs a new DataMessage.
             * @memberof gossip
             * @classdesc Represents a DataMessage.
             * @implements IDataMessage
             * @constructor
             * @param {gossip.IDataMessage=} [properties] Properties to set
             */
            function DataMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DataMessage payload.
             * @member {gossip.IPayload|null|undefined} payload
             * @memberof gossip.DataMessage
             * @instance
             */
            DataMessage.prototype.payload = null;
    
            /**
             * Creates a new DataMessage instance using the specified properties.
             * @function create
             * @memberof gossip.DataMessage
             * @static
             * @param {gossip.IDataMessage=} [properties] Properties to set
             * @returns {gossip.DataMessage} DataMessage instance
             */
            DataMessage.create = function create(properties) {
                return new DataMessage(properties);
            };
    
            /**
             * Encodes the specified DataMessage message. Does not implicitly {@link gossip.DataMessage.verify|verify} messages.
             * @function encode
             * @memberof gossip.DataMessage
             * @static
             * @param {gossip.IDataMessage} message DataMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    $root.gossip.Payload.encode(message.payload, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified DataMessage message, length delimited. Does not implicitly {@link gossip.DataMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.DataMessage
             * @static
             * @param {gossip.IDataMessage} message DataMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DataMessage message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.DataMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.DataMessage} DataMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.DataMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = $root.gossip.Payload.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DataMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.DataMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.DataMessage} DataMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DataMessage message.
             * @function verify
             * @memberof gossip.DataMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    var error = $root.gossip.Payload.verify(message.payload);
                    if (error)
                        return "payload." + error;
                }
                return null;
            };
    
            /**
             * Creates a DataMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.DataMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.DataMessage} DataMessage
             */
            DataMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.DataMessage)
                    return object;
                var message = new $root.gossip.DataMessage();
                if (object.payload != null) {
                    if (typeof object.payload !== "object")
                        throw TypeError(".gossip.DataMessage.payload: object expected");
                    message.payload = $root.gossip.Payload.fromObject(object.payload);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DataMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.DataMessage
             * @static
             * @param {gossip.DataMessage} message DataMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.payload = null;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = $root.gossip.Payload.toObject(message.payload, options);
                return object;
            };
    
            /**
             * Converts this DataMessage to JSON.
             * @function toJSON
             * @memberof gossip.DataMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DataMessage;
        })();
    
        gossip.PrivateDataMessage = (function() {
    
            /**
             * Properties of a PrivateDataMessage.
             * @memberof gossip
             * @interface IPrivateDataMessage
             * @property {gossip.IPrivatePayload|null} [payload] PrivateDataMessage payload
             */
    
            /**
             * Constructs a new PrivateDataMessage.
             * @memberof gossip
             * @classdesc Represents a PrivateDataMessage.
             * @implements IPrivateDataMessage
             * @constructor
             * @param {gossip.IPrivateDataMessage=} [properties] Properties to set
             */
            function PrivateDataMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PrivateDataMessage payload.
             * @member {gossip.IPrivatePayload|null|undefined} payload
             * @memberof gossip.PrivateDataMessage
             * @instance
             */
            PrivateDataMessage.prototype.payload = null;
    
            /**
             * Creates a new PrivateDataMessage instance using the specified properties.
             * @function create
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {gossip.IPrivateDataMessage=} [properties] Properties to set
             * @returns {gossip.PrivateDataMessage} PrivateDataMessage instance
             */
            PrivateDataMessage.create = function create(properties) {
                return new PrivateDataMessage(properties);
            };
    
            /**
             * Encodes the specified PrivateDataMessage message. Does not implicitly {@link gossip.PrivateDataMessage.verify|verify} messages.
             * @function encode
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {gossip.IPrivateDataMessage} message PrivateDataMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivateDataMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    $root.gossip.PrivatePayload.encode(message.payload, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PrivateDataMessage message, length delimited. Does not implicitly {@link gossip.PrivateDataMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {gossip.IPrivateDataMessage} message PrivateDataMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivateDataMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PrivateDataMessage message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PrivateDataMessage} PrivateDataMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivateDataMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PrivateDataMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = $root.gossip.PrivatePayload.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PrivateDataMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PrivateDataMessage} PrivateDataMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivateDataMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PrivateDataMessage message.
             * @function verify
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrivateDataMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    var error = $root.gossip.PrivatePayload.verify(message.payload);
                    if (error)
                        return "payload." + error;
                }
                return null;
            };
    
            /**
             * Creates a PrivateDataMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PrivateDataMessage} PrivateDataMessage
             */
            PrivateDataMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PrivateDataMessage)
                    return object;
                var message = new $root.gossip.PrivateDataMessage();
                if (object.payload != null) {
                    if (typeof object.payload !== "object")
                        throw TypeError(".gossip.PrivateDataMessage.payload: object expected");
                    message.payload = $root.gossip.PrivatePayload.fromObject(object.payload);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PrivateDataMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PrivateDataMessage
             * @static
             * @param {gossip.PrivateDataMessage} message PrivateDataMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrivateDataMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.payload = null;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = $root.gossip.PrivatePayload.toObject(message.payload, options);
                return object;
            };
    
            /**
             * Converts this PrivateDataMessage to JSON.
             * @function toJSON
             * @memberof gossip.PrivateDataMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrivateDataMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PrivateDataMessage;
        })();
    
        gossip.Payload = (function() {
    
            /**
             * Properties of a Payload.
             * @memberof gossip
             * @interface IPayload
             * @property {number|Long|null} [seqNum] Payload seqNum
             * @property {Uint8Array|null} [data] Payload data
             * @property {Array.<Uint8Array>|null} [privateData] Payload privateData
             */
    
            /**
             * Constructs a new Payload.
             * @memberof gossip
             * @classdesc Represents a Payload.
             * @implements IPayload
             * @constructor
             * @param {gossip.IPayload=} [properties] Properties to set
             */
            function Payload(properties) {
                this.privateData = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Payload seqNum.
             * @member {number|Long} seqNum
             * @memberof gossip.Payload
             * @instance
             */
            Payload.prototype.seqNum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Payload data.
             * @member {Uint8Array} data
             * @memberof gossip.Payload
             * @instance
             */
            Payload.prototype.data = $util.newBuffer([]);
    
            /**
             * Payload privateData.
             * @member {Array.<Uint8Array>} privateData
             * @memberof gossip.Payload
             * @instance
             */
            Payload.prototype.privateData = $util.emptyArray;
    
            /**
             * Creates a new Payload instance using the specified properties.
             * @function create
             * @memberof gossip.Payload
             * @static
             * @param {gossip.IPayload=} [properties] Properties to set
             * @returns {gossip.Payload} Payload instance
             */
            Payload.create = function create(properties) {
                return new Payload(properties);
            };
    
            /**
             * Encodes the specified Payload message. Does not implicitly {@link gossip.Payload.verify|verify} messages.
             * @function encode
             * @memberof gossip.Payload
             * @static
             * @param {gossip.IPayload} message Payload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.seqNum);
                if (message.data != null && message.hasOwnProperty("data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                if (message.privateData != null && message.privateData.length)
                    for (var i = 0; i < message.privateData.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.privateData[i]);
                return writer;
            };
    
            /**
             * Encodes the specified Payload message, length delimited. Does not implicitly {@link gossip.Payload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Payload
             * @static
             * @param {gossip.IPayload} message Payload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Payload message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Payload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Payload} Payload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Payload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seqNum = reader.uint64();
                        break;
                    case 2:
                        message.data = reader.bytes();
                        break;
                    case 3:
                        if (!(message.privateData && message.privateData.length))
                            message.privateData = [];
                        message.privateData.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Payload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Payload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Payload} Payload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Payload message.
             * @function verify
             * @memberof gossip.Payload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Payload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                    if (!$util.isInteger(message.seqNum) && !(message.seqNum && $util.isInteger(message.seqNum.low) && $util.isInteger(message.seqNum.high)))
                        return "seqNum: integer|Long expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                if (message.privateData != null && message.hasOwnProperty("privateData")) {
                    if (!Array.isArray(message.privateData))
                        return "privateData: array expected";
                    for (var i = 0; i < message.privateData.length; ++i)
                        if (!(message.privateData[i] && typeof message.privateData[i].length === "number" || $util.isString(message.privateData[i])))
                            return "privateData: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a Payload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Payload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Payload} Payload
             */
            Payload.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Payload)
                    return object;
                var message = new $root.gossip.Payload();
                if (object.seqNum != null)
                    if ($util.Long)
                        (message.seqNum = $util.Long.fromValue(object.seqNum)).unsigned = true;
                    else if (typeof object.seqNum === "string")
                        message.seqNum = parseInt(object.seqNum, 10);
                    else if (typeof object.seqNum === "number")
                        message.seqNum = object.seqNum;
                    else if (typeof object.seqNum === "object")
                        message.seqNum = new $util.LongBits(object.seqNum.low >>> 0, object.seqNum.high >>> 0).toNumber(true);
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                if (object.privateData) {
                    if (!Array.isArray(object.privateData))
                        throw TypeError(".gossip.Payload.privateData: array expected");
                    message.privateData = [];
                    for (var i = 0; i < object.privateData.length; ++i)
                        if (typeof object.privateData[i] === "string")
                            $util.base64.decode(object.privateData[i], message.privateData[i] = $util.newBuffer($util.base64.length(object.privateData[i])), 0);
                        else if (object.privateData[i].length)
                            message.privateData[i] = object.privateData[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Payload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Payload
             * @static
             * @param {gossip.Payload} message Payload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Payload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.privateData = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.seqNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seqNum = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                    if (typeof message.seqNum === "number")
                        object.seqNum = options.longs === String ? String(message.seqNum) : message.seqNum;
                    else
                        object.seqNum = options.longs === String ? $util.Long.prototype.toString.call(message.seqNum) : options.longs === Number ? new $util.LongBits(message.seqNum.low >>> 0, message.seqNum.high >>> 0).toNumber(true) : message.seqNum;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (message.privateData && message.privateData.length) {
                    object.privateData = [];
                    for (var j = 0; j < message.privateData.length; ++j)
                        object.privateData[j] = options.bytes === String ? $util.base64.encode(message.privateData[j], 0, message.privateData[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.privateData[j]) : message.privateData[j];
                }
                return object;
            };
    
            /**
             * Converts this Payload to JSON.
             * @function toJSON
             * @memberof gossip.Payload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Payload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Payload;
        })();
    
        gossip.PrivatePayload = (function() {
    
            /**
             * Properties of a PrivatePayload.
             * @memberof gossip
             * @interface IPrivatePayload
             * @property {string|null} [collectionName] PrivatePayload collectionName
             * @property {string|null} [namespace] PrivatePayload namespace
             * @property {string|null} [txId] PrivatePayload txId
             * @property {Uint8Array|null} [privateRwset] PrivatePayload privateRwset
             * @property {number|Long|null} [privateSimHeight] PrivatePayload privateSimHeight
             * @property {common.ICollectionConfigPackage|null} [collectionConfigs] PrivatePayload collectionConfigs
             */
    
            /**
             * Constructs a new PrivatePayload.
             * @memberof gossip
             * @classdesc Represents a PrivatePayload.
             * @implements IPrivatePayload
             * @constructor
             * @param {gossip.IPrivatePayload=} [properties] Properties to set
             */
            function PrivatePayload(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PrivatePayload collectionName.
             * @member {string} collectionName
             * @memberof gossip.PrivatePayload
             * @instance
             */
            PrivatePayload.prototype.collectionName = "";
    
            /**
             * PrivatePayload namespace.
             * @member {string} namespace
             * @memberof gossip.PrivatePayload
             * @instance
             */
            PrivatePayload.prototype.namespace = "";
    
            /**
             * PrivatePayload txId.
             * @member {string} txId
             * @memberof gossip.PrivatePayload
             * @instance
             */
            PrivatePayload.prototype.txId = "";
    
            /**
             * PrivatePayload privateRwset.
             * @member {Uint8Array} privateRwset
             * @memberof gossip.PrivatePayload
             * @instance
             */
            PrivatePayload.prototype.privateRwset = $util.newBuffer([]);
    
            /**
             * PrivatePayload privateSimHeight.
             * @member {number|Long} privateSimHeight
             * @memberof gossip.PrivatePayload
             * @instance
             */
            PrivatePayload.prototype.privateSimHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * PrivatePayload collectionConfigs.
             * @member {common.ICollectionConfigPackage|null|undefined} collectionConfigs
             * @memberof gossip.PrivatePayload
             * @instance
             */
            PrivatePayload.prototype.collectionConfigs = null;
    
            /**
             * Creates a new PrivatePayload instance using the specified properties.
             * @function create
             * @memberof gossip.PrivatePayload
             * @static
             * @param {gossip.IPrivatePayload=} [properties] Properties to set
             * @returns {gossip.PrivatePayload} PrivatePayload instance
             */
            PrivatePayload.create = function create(properties) {
                return new PrivatePayload(properties);
            };
    
            /**
             * Encodes the specified PrivatePayload message. Does not implicitly {@link gossip.PrivatePayload.verify|verify} messages.
             * @function encode
             * @memberof gossip.PrivatePayload
             * @static
             * @param {gossip.IPrivatePayload} message PrivatePayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivatePayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collectionName != null && message.hasOwnProperty("collectionName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collectionName);
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.namespace);
                if (message.txId != null && message.hasOwnProperty("txId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.txId);
                if (message.privateRwset != null && message.hasOwnProperty("privateRwset"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.privateRwset);
                if (message.privateSimHeight != null && message.hasOwnProperty("privateSimHeight"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.privateSimHeight);
                if (message.collectionConfigs != null && message.hasOwnProperty("collectionConfigs"))
                    $root.common.CollectionConfigPackage.encode(message.collectionConfigs, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PrivatePayload message, length delimited. Does not implicitly {@link gossip.PrivatePayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PrivatePayload
             * @static
             * @param {gossip.IPrivatePayload} message PrivatePayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrivatePayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PrivatePayload message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PrivatePayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PrivatePayload} PrivatePayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivatePayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PrivatePayload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collectionName = reader.string();
                        break;
                    case 2:
                        message.namespace = reader.string();
                        break;
                    case 3:
                        message.txId = reader.string();
                        break;
                    case 4:
                        message.privateRwset = reader.bytes();
                        break;
                    case 5:
                        message.privateSimHeight = reader.uint64();
                        break;
                    case 6:
                        message.collectionConfigs = $root.common.CollectionConfigPackage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PrivatePayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PrivatePayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PrivatePayload} PrivatePayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrivatePayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PrivatePayload message.
             * @function verify
             * @memberof gossip.PrivatePayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrivatePayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collectionName != null && message.hasOwnProperty("collectionName"))
                    if (!$util.isString(message.collectionName))
                        return "collectionName: string expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isString(message.txId))
                        return "txId: string expected";
                if (message.privateRwset != null && message.hasOwnProperty("privateRwset"))
                    if (!(message.privateRwset && typeof message.privateRwset.length === "number" || $util.isString(message.privateRwset)))
                        return "privateRwset: buffer expected";
                if (message.privateSimHeight != null && message.hasOwnProperty("privateSimHeight"))
                    if (!$util.isInteger(message.privateSimHeight) && !(message.privateSimHeight && $util.isInteger(message.privateSimHeight.low) && $util.isInteger(message.privateSimHeight.high)))
                        return "privateSimHeight: integer|Long expected";
                if (message.collectionConfigs != null && message.hasOwnProperty("collectionConfigs")) {
                    var error = $root.common.CollectionConfigPackage.verify(message.collectionConfigs);
                    if (error)
                        return "collectionConfigs." + error;
                }
                return null;
            };
    
            /**
             * Creates a PrivatePayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PrivatePayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PrivatePayload} PrivatePayload
             */
            PrivatePayload.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PrivatePayload)
                    return object;
                var message = new $root.gossip.PrivatePayload();
                if (object.collectionName != null)
                    message.collectionName = String(object.collectionName);
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.txId != null)
                    message.txId = String(object.txId);
                if (object.privateRwset != null)
                    if (typeof object.privateRwset === "string")
                        $util.base64.decode(object.privateRwset, message.privateRwset = $util.newBuffer($util.base64.length(object.privateRwset)), 0);
                    else if (object.privateRwset.length)
                        message.privateRwset = object.privateRwset;
                if (object.privateSimHeight != null)
                    if ($util.Long)
                        (message.privateSimHeight = $util.Long.fromValue(object.privateSimHeight)).unsigned = true;
                    else if (typeof object.privateSimHeight === "string")
                        message.privateSimHeight = parseInt(object.privateSimHeight, 10);
                    else if (typeof object.privateSimHeight === "number")
                        message.privateSimHeight = object.privateSimHeight;
                    else if (typeof object.privateSimHeight === "object")
                        message.privateSimHeight = new $util.LongBits(object.privateSimHeight.low >>> 0, object.privateSimHeight.high >>> 0).toNumber(true);
                if (object.collectionConfigs != null) {
                    if (typeof object.collectionConfigs !== "object")
                        throw TypeError(".gossip.PrivatePayload.collectionConfigs: object expected");
                    message.collectionConfigs = $root.common.CollectionConfigPackage.fromObject(object.collectionConfigs);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PrivatePayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PrivatePayload
             * @static
             * @param {gossip.PrivatePayload} message PrivatePayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrivatePayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collectionName = "";
                    object.namespace = "";
                    object.txId = "";
                    if (options.bytes === String)
                        object.privateRwset = "";
                    else {
                        object.privateRwset = [];
                        if (options.bytes !== Array)
                            object.privateRwset = $util.newBuffer(object.privateRwset);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.privateSimHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.privateSimHeight = options.longs === String ? "0" : 0;
                    object.collectionConfigs = null;
                }
                if (message.collectionName != null && message.hasOwnProperty("collectionName"))
                    object.collectionName = message.collectionName;
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.txId != null && message.hasOwnProperty("txId"))
                    object.txId = message.txId;
                if (message.privateRwset != null && message.hasOwnProperty("privateRwset"))
                    object.privateRwset = options.bytes === String ? $util.base64.encode(message.privateRwset, 0, message.privateRwset.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateRwset) : message.privateRwset;
                if (message.privateSimHeight != null && message.hasOwnProperty("privateSimHeight"))
                    if (typeof message.privateSimHeight === "number")
                        object.privateSimHeight = options.longs === String ? String(message.privateSimHeight) : message.privateSimHeight;
                    else
                        object.privateSimHeight = options.longs === String ? $util.Long.prototype.toString.call(message.privateSimHeight) : options.longs === Number ? new $util.LongBits(message.privateSimHeight.low >>> 0, message.privateSimHeight.high >>> 0).toNumber(true) : message.privateSimHeight;
                if (message.collectionConfigs != null && message.hasOwnProperty("collectionConfigs"))
                    object.collectionConfigs = $root.common.CollectionConfigPackage.toObject(message.collectionConfigs, options);
                return object;
            };
    
            /**
             * Converts this PrivatePayload to JSON.
             * @function toJSON
             * @memberof gossip.PrivatePayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrivatePayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PrivatePayload;
        })();
    
        gossip.AliveMessage = (function() {
    
            /**
             * Properties of an AliveMessage.
             * @memberof gossip
             * @interface IAliveMessage
             * @property {gossip.IMember|null} [membership] AliveMessage membership
             * @property {gossip.IPeerTime|null} [timestamp] AliveMessage timestamp
             * @property {Uint8Array|null} [identity] AliveMessage identity
             */
    
            /**
             * Constructs a new AliveMessage.
             * @memberof gossip
             * @classdesc Represents an AliveMessage.
             * @implements IAliveMessage
             * @constructor
             * @param {gossip.IAliveMessage=} [properties] Properties to set
             */
            function AliveMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AliveMessage membership.
             * @member {gossip.IMember|null|undefined} membership
             * @memberof gossip.AliveMessage
             * @instance
             */
            AliveMessage.prototype.membership = null;
    
            /**
             * AliveMessage timestamp.
             * @member {gossip.IPeerTime|null|undefined} timestamp
             * @memberof gossip.AliveMessage
             * @instance
             */
            AliveMessage.prototype.timestamp = null;
    
            /**
             * AliveMessage identity.
             * @member {Uint8Array} identity
             * @memberof gossip.AliveMessage
             * @instance
             */
            AliveMessage.prototype.identity = $util.newBuffer([]);
    
            /**
             * Creates a new AliveMessage instance using the specified properties.
             * @function create
             * @memberof gossip.AliveMessage
             * @static
             * @param {gossip.IAliveMessage=} [properties] Properties to set
             * @returns {gossip.AliveMessage} AliveMessage instance
             */
            AliveMessage.create = function create(properties) {
                return new AliveMessage(properties);
            };
    
            /**
             * Encodes the specified AliveMessage message. Does not implicitly {@link gossip.AliveMessage.verify|verify} messages.
             * @function encode
             * @memberof gossip.AliveMessage
             * @static
             * @param {gossip.IAliveMessage} message AliveMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AliveMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.membership != null && message.hasOwnProperty("membership"))
                    $root.gossip.Member.encode(message.membership, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.gossip.PeerTime.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identity != null && message.hasOwnProperty("identity"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.identity);
                return writer;
            };
    
            /**
             * Encodes the specified AliveMessage message, length delimited. Does not implicitly {@link gossip.AliveMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.AliveMessage
             * @static
             * @param {gossip.IAliveMessage} message AliveMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AliveMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AliveMessage message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.AliveMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.AliveMessage} AliveMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AliveMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.AliveMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.membership = $root.gossip.Member.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.timestamp = $root.gossip.PeerTime.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.identity = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AliveMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.AliveMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.AliveMessage} AliveMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AliveMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AliveMessage message.
             * @function verify
             * @memberof gossip.AliveMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AliveMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.membership != null && message.hasOwnProperty("membership")) {
                    var error = $root.gossip.Member.verify(message.membership);
                    if (error)
                        return "membership." + error;
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.gossip.PeerTime.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.identity != null && message.hasOwnProperty("identity"))
                    if (!(message.identity && typeof message.identity.length === "number" || $util.isString(message.identity)))
                        return "identity: buffer expected";
                return null;
            };
    
            /**
             * Creates an AliveMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.AliveMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.AliveMessage} AliveMessage
             */
            AliveMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.AliveMessage)
                    return object;
                var message = new $root.gossip.AliveMessage();
                if (object.membership != null) {
                    if (typeof object.membership !== "object")
                        throw TypeError(".gossip.AliveMessage.membership: object expected");
                    message.membership = $root.gossip.Member.fromObject(object.membership);
                }
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".gossip.AliveMessage.timestamp: object expected");
                    message.timestamp = $root.gossip.PeerTime.fromObject(object.timestamp);
                }
                if (object.identity != null)
                    if (typeof object.identity === "string")
                        $util.base64.decode(object.identity, message.identity = $util.newBuffer($util.base64.length(object.identity)), 0);
                    else if (object.identity.length)
                        message.identity = object.identity;
                return message;
            };
    
            /**
             * Creates a plain object from an AliveMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.AliveMessage
             * @static
             * @param {gossip.AliveMessage} message AliveMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AliveMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.membership = null;
                    object.timestamp = null;
                    if (options.bytes === String)
                        object.identity = "";
                    else {
                        object.identity = [];
                        if (options.bytes !== Array)
                            object.identity = $util.newBuffer(object.identity);
                    }
                }
                if (message.membership != null && message.hasOwnProperty("membership"))
                    object.membership = $root.gossip.Member.toObject(message.membership, options);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.gossip.PeerTime.toObject(message.timestamp, options);
                if (message.identity != null && message.hasOwnProperty("identity"))
                    object.identity = options.bytes === String ? $util.base64.encode(message.identity, 0, message.identity.length) : options.bytes === Array ? Array.prototype.slice.call(message.identity) : message.identity;
                return object;
            };
    
            /**
             * Converts this AliveMessage to JSON.
             * @function toJSON
             * @memberof gossip.AliveMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AliveMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AliveMessage;
        })();
    
        gossip.LeadershipMessage = (function() {
    
            /**
             * Properties of a LeadershipMessage.
             * @memberof gossip
             * @interface ILeadershipMessage
             * @property {Uint8Array|null} [pkiId] LeadershipMessage pkiId
             * @property {gossip.IPeerTime|null} [timestamp] LeadershipMessage timestamp
             * @property {boolean|null} [isDeclaration] LeadershipMessage isDeclaration
             */
    
            /**
             * Constructs a new LeadershipMessage.
             * @memberof gossip
             * @classdesc Represents a LeadershipMessage.
             * @implements ILeadershipMessage
             * @constructor
             * @param {gossip.ILeadershipMessage=} [properties] Properties to set
             */
            function LeadershipMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LeadershipMessage pkiId.
             * @member {Uint8Array} pkiId
             * @memberof gossip.LeadershipMessage
             * @instance
             */
            LeadershipMessage.prototype.pkiId = $util.newBuffer([]);
    
            /**
             * LeadershipMessage timestamp.
             * @member {gossip.IPeerTime|null|undefined} timestamp
             * @memberof gossip.LeadershipMessage
             * @instance
             */
            LeadershipMessage.prototype.timestamp = null;
    
            /**
             * LeadershipMessage isDeclaration.
             * @member {boolean} isDeclaration
             * @memberof gossip.LeadershipMessage
             * @instance
             */
            LeadershipMessage.prototype.isDeclaration = false;
    
            /**
             * Creates a new LeadershipMessage instance using the specified properties.
             * @function create
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {gossip.ILeadershipMessage=} [properties] Properties to set
             * @returns {gossip.LeadershipMessage} LeadershipMessage instance
             */
            LeadershipMessage.create = function create(properties) {
                return new LeadershipMessage(properties);
            };
    
            /**
             * Encodes the specified LeadershipMessage message. Does not implicitly {@link gossip.LeadershipMessage.verify|verify} messages.
             * @function encode
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {gossip.ILeadershipMessage} message LeadershipMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeadershipMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.pkiId);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.gossip.PeerTime.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.isDeclaration != null && message.hasOwnProperty("isDeclaration"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isDeclaration);
                return writer;
            };
    
            /**
             * Encodes the specified LeadershipMessage message, length delimited. Does not implicitly {@link gossip.LeadershipMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {gossip.ILeadershipMessage} message LeadershipMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeadershipMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LeadershipMessage message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.LeadershipMessage} LeadershipMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeadershipMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.LeadershipMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pkiId = reader.bytes();
                        break;
                    case 2:
                        message.timestamp = $root.gossip.PeerTime.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.isDeclaration = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LeadershipMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.LeadershipMessage} LeadershipMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeadershipMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LeadershipMessage message.
             * @function verify
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LeadershipMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    if (!(message.pkiId && typeof message.pkiId.length === "number" || $util.isString(message.pkiId)))
                        return "pkiId: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.gossip.PeerTime.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.isDeclaration != null && message.hasOwnProperty("isDeclaration"))
                    if (typeof message.isDeclaration !== "boolean")
                        return "isDeclaration: boolean expected";
                return null;
            };
    
            /**
             * Creates a LeadershipMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.LeadershipMessage} LeadershipMessage
             */
            LeadershipMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.LeadershipMessage)
                    return object;
                var message = new $root.gossip.LeadershipMessage();
                if (object.pkiId != null)
                    if (typeof object.pkiId === "string")
                        $util.base64.decode(object.pkiId, message.pkiId = $util.newBuffer($util.base64.length(object.pkiId)), 0);
                    else if (object.pkiId.length)
                        message.pkiId = object.pkiId;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".gossip.LeadershipMessage.timestamp: object expected");
                    message.timestamp = $root.gossip.PeerTime.fromObject(object.timestamp);
                }
                if (object.isDeclaration != null)
                    message.isDeclaration = Boolean(object.isDeclaration);
                return message;
            };
    
            /**
             * Creates a plain object from a LeadershipMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.LeadershipMessage
             * @static
             * @param {gossip.LeadershipMessage} message LeadershipMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LeadershipMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.pkiId = "";
                    else {
                        object.pkiId = [];
                        if (options.bytes !== Array)
                            object.pkiId = $util.newBuffer(object.pkiId);
                    }
                    object.timestamp = null;
                    object.isDeclaration = false;
                }
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    object.pkiId = options.bytes === String ? $util.base64.encode(message.pkiId, 0, message.pkiId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pkiId) : message.pkiId;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.gossip.PeerTime.toObject(message.timestamp, options);
                if (message.isDeclaration != null && message.hasOwnProperty("isDeclaration"))
                    object.isDeclaration = message.isDeclaration;
                return object;
            };
    
            /**
             * Converts this LeadershipMessage to JSON.
             * @function toJSON
             * @memberof gossip.LeadershipMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LeadershipMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LeadershipMessage;
        })();
    
        gossip.PeerTime = (function() {
    
            /**
             * Properties of a PeerTime.
             * @memberof gossip
             * @interface IPeerTime
             * @property {number|Long|null} [incNum] PeerTime incNum
             * @property {number|Long|null} [seqNum] PeerTime seqNum
             */
    
            /**
             * Constructs a new PeerTime.
             * @memberof gossip
             * @classdesc Represents a PeerTime.
             * @implements IPeerTime
             * @constructor
             * @param {gossip.IPeerTime=} [properties] Properties to set
             */
            function PeerTime(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PeerTime incNum.
             * @member {number|Long} incNum
             * @memberof gossip.PeerTime
             * @instance
             */
            PeerTime.prototype.incNum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * PeerTime seqNum.
             * @member {number|Long} seqNum
             * @memberof gossip.PeerTime
             * @instance
             */
            PeerTime.prototype.seqNum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new PeerTime instance using the specified properties.
             * @function create
             * @memberof gossip.PeerTime
             * @static
             * @param {gossip.IPeerTime=} [properties] Properties to set
             * @returns {gossip.PeerTime} PeerTime instance
             */
            PeerTime.create = function create(properties) {
                return new PeerTime(properties);
            };
    
            /**
             * Encodes the specified PeerTime message. Does not implicitly {@link gossip.PeerTime.verify|verify} messages.
             * @function encode
             * @memberof gossip.PeerTime
             * @static
             * @param {gossip.IPeerTime} message PeerTime message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerTime.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.incNum != null && message.hasOwnProperty("incNum"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.incNum);
                if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.seqNum);
                return writer;
            };
    
            /**
             * Encodes the specified PeerTime message, length delimited. Does not implicitly {@link gossip.PeerTime.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PeerTime
             * @static
             * @param {gossip.IPeerTime} message PeerTime message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerTime.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PeerTime message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PeerTime
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PeerTime} PeerTime
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerTime.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PeerTime();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.incNum = reader.uint64();
                        break;
                    case 2:
                        message.seqNum = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PeerTime message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PeerTime
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PeerTime} PeerTime
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerTime.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PeerTime message.
             * @function verify
             * @memberof gossip.PeerTime
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerTime.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.incNum != null && message.hasOwnProperty("incNum"))
                    if (!$util.isInteger(message.incNum) && !(message.incNum && $util.isInteger(message.incNum.low) && $util.isInteger(message.incNum.high)))
                        return "incNum: integer|Long expected";
                if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                    if (!$util.isInteger(message.seqNum) && !(message.seqNum && $util.isInteger(message.seqNum.low) && $util.isInteger(message.seqNum.high)))
                        return "seqNum: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a PeerTime message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PeerTime
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PeerTime} PeerTime
             */
            PeerTime.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PeerTime)
                    return object;
                var message = new $root.gossip.PeerTime();
                if (object.incNum != null)
                    if ($util.Long)
                        (message.incNum = $util.Long.fromValue(object.incNum)).unsigned = true;
                    else if (typeof object.incNum === "string")
                        message.incNum = parseInt(object.incNum, 10);
                    else if (typeof object.incNum === "number")
                        message.incNum = object.incNum;
                    else if (typeof object.incNum === "object")
                        message.incNum = new $util.LongBits(object.incNum.low >>> 0, object.incNum.high >>> 0).toNumber(true);
                if (object.seqNum != null)
                    if ($util.Long)
                        (message.seqNum = $util.Long.fromValue(object.seqNum)).unsigned = true;
                    else if (typeof object.seqNum === "string")
                        message.seqNum = parseInt(object.seqNum, 10);
                    else if (typeof object.seqNum === "number")
                        message.seqNum = object.seqNum;
                    else if (typeof object.seqNum === "object")
                        message.seqNum = new $util.LongBits(object.seqNum.low >>> 0, object.seqNum.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a PeerTime message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PeerTime
             * @static
             * @param {gossip.PeerTime} message PeerTime
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerTime.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.incNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.incNum = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.seqNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seqNum = options.longs === String ? "0" : 0;
                }
                if (message.incNum != null && message.hasOwnProperty("incNum"))
                    if (typeof message.incNum === "number")
                        object.incNum = options.longs === String ? String(message.incNum) : message.incNum;
                    else
                        object.incNum = options.longs === String ? $util.Long.prototype.toString.call(message.incNum) : options.longs === Number ? new $util.LongBits(message.incNum.low >>> 0, message.incNum.high >>> 0).toNumber(true) : message.incNum;
                if (message.seqNum != null && message.hasOwnProperty("seqNum"))
                    if (typeof message.seqNum === "number")
                        object.seqNum = options.longs === String ? String(message.seqNum) : message.seqNum;
                    else
                        object.seqNum = options.longs === String ? $util.Long.prototype.toString.call(message.seqNum) : options.longs === Number ? new $util.LongBits(message.seqNum.low >>> 0, message.seqNum.high >>> 0).toNumber(true) : message.seqNum;
                return object;
            };
    
            /**
             * Converts this PeerTime to JSON.
             * @function toJSON
             * @memberof gossip.PeerTime
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerTime.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PeerTime;
        })();
    
        gossip.MembershipRequest = (function() {
    
            /**
             * Properties of a MembershipRequest.
             * @memberof gossip
             * @interface IMembershipRequest
             * @property {gossip.IEnvelope|null} [selfInformation] MembershipRequest selfInformation
             * @property {Array.<Uint8Array>|null} [known] MembershipRequest known
             */
    
            /**
             * Constructs a new MembershipRequest.
             * @memberof gossip
             * @classdesc Represents a MembershipRequest.
             * @implements IMembershipRequest
             * @constructor
             * @param {gossip.IMembershipRequest=} [properties] Properties to set
             */
            function MembershipRequest(properties) {
                this.known = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MembershipRequest selfInformation.
             * @member {gossip.IEnvelope|null|undefined} selfInformation
             * @memberof gossip.MembershipRequest
             * @instance
             */
            MembershipRequest.prototype.selfInformation = null;
    
            /**
             * MembershipRequest known.
             * @member {Array.<Uint8Array>} known
             * @memberof gossip.MembershipRequest
             * @instance
             */
            MembershipRequest.prototype.known = $util.emptyArray;
    
            /**
             * Creates a new MembershipRequest instance using the specified properties.
             * @function create
             * @memberof gossip.MembershipRequest
             * @static
             * @param {gossip.IMembershipRequest=} [properties] Properties to set
             * @returns {gossip.MembershipRequest} MembershipRequest instance
             */
            MembershipRequest.create = function create(properties) {
                return new MembershipRequest(properties);
            };
    
            /**
             * Encodes the specified MembershipRequest message. Does not implicitly {@link gossip.MembershipRequest.verify|verify} messages.
             * @function encode
             * @memberof gossip.MembershipRequest
             * @static
             * @param {gossip.IMembershipRequest} message MembershipRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MembershipRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selfInformation != null && message.hasOwnProperty("selfInformation"))
                    $root.gossip.Envelope.encode(message.selfInformation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.known != null && message.known.length)
                    for (var i = 0; i < message.known.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.known[i]);
                return writer;
            };
    
            /**
             * Encodes the specified MembershipRequest message, length delimited. Does not implicitly {@link gossip.MembershipRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.MembershipRequest
             * @static
             * @param {gossip.IMembershipRequest} message MembershipRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MembershipRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MembershipRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.MembershipRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.MembershipRequest} MembershipRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MembershipRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.MembershipRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.selfInformation = $root.gossip.Envelope.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.known && message.known.length))
                            message.known = [];
                        message.known.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MembershipRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.MembershipRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.MembershipRequest} MembershipRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MembershipRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MembershipRequest message.
             * @function verify
             * @memberof gossip.MembershipRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MembershipRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.selfInformation != null && message.hasOwnProperty("selfInformation")) {
                    var error = $root.gossip.Envelope.verify(message.selfInformation);
                    if (error)
                        return "selfInformation." + error;
                }
                if (message.known != null && message.hasOwnProperty("known")) {
                    if (!Array.isArray(message.known))
                        return "known: array expected";
                    for (var i = 0; i < message.known.length; ++i)
                        if (!(message.known[i] && typeof message.known[i].length === "number" || $util.isString(message.known[i])))
                            return "known: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a MembershipRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.MembershipRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.MembershipRequest} MembershipRequest
             */
            MembershipRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.MembershipRequest)
                    return object;
                var message = new $root.gossip.MembershipRequest();
                if (object.selfInformation != null) {
                    if (typeof object.selfInformation !== "object")
                        throw TypeError(".gossip.MembershipRequest.selfInformation: object expected");
                    message.selfInformation = $root.gossip.Envelope.fromObject(object.selfInformation);
                }
                if (object.known) {
                    if (!Array.isArray(object.known))
                        throw TypeError(".gossip.MembershipRequest.known: array expected");
                    message.known = [];
                    for (var i = 0; i < object.known.length; ++i)
                        if (typeof object.known[i] === "string")
                            $util.base64.decode(object.known[i], message.known[i] = $util.newBuffer($util.base64.length(object.known[i])), 0);
                        else if (object.known[i].length)
                            message.known[i] = object.known[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a MembershipRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.MembershipRequest
             * @static
             * @param {gossip.MembershipRequest} message MembershipRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MembershipRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.known = [];
                if (options.defaults)
                    object.selfInformation = null;
                if (message.selfInformation != null && message.hasOwnProperty("selfInformation"))
                    object.selfInformation = $root.gossip.Envelope.toObject(message.selfInformation, options);
                if (message.known && message.known.length) {
                    object.known = [];
                    for (var j = 0; j < message.known.length; ++j)
                        object.known[j] = options.bytes === String ? $util.base64.encode(message.known[j], 0, message.known[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.known[j]) : message.known[j];
                }
                return object;
            };
    
            /**
             * Converts this MembershipRequest to JSON.
             * @function toJSON
             * @memberof gossip.MembershipRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MembershipRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return MembershipRequest;
        })();
    
        gossip.MembershipResponse = (function() {
    
            /**
             * Properties of a MembershipResponse.
             * @memberof gossip
             * @interface IMembershipResponse
             * @property {Array.<gossip.IEnvelope>|null} [alive] MembershipResponse alive
             * @property {Array.<gossip.IEnvelope>|null} [dead] MembershipResponse dead
             */
    
            /**
             * Constructs a new MembershipResponse.
             * @memberof gossip
             * @classdesc Represents a MembershipResponse.
             * @implements IMembershipResponse
             * @constructor
             * @param {gossip.IMembershipResponse=} [properties] Properties to set
             */
            function MembershipResponse(properties) {
                this.alive = [];
                this.dead = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MembershipResponse alive.
             * @member {Array.<gossip.IEnvelope>} alive
             * @memberof gossip.MembershipResponse
             * @instance
             */
            MembershipResponse.prototype.alive = $util.emptyArray;
    
            /**
             * MembershipResponse dead.
             * @member {Array.<gossip.IEnvelope>} dead
             * @memberof gossip.MembershipResponse
             * @instance
             */
            MembershipResponse.prototype.dead = $util.emptyArray;
    
            /**
             * Creates a new MembershipResponse instance using the specified properties.
             * @function create
             * @memberof gossip.MembershipResponse
             * @static
             * @param {gossip.IMembershipResponse=} [properties] Properties to set
             * @returns {gossip.MembershipResponse} MembershipResponse instance
             */
            MembershipResponse.create = function create(properties) {
                return new MembershipResponse(properties);
            };
    
            /**
             * Encodes the specified MembershipResponse message. Does not implicitly {@link gossip.MembershipResponse.verify|verify} messages.
             * @function encode
             * @memberof gossip.MembershipResponse
             * @static
             * @param {gossip.IMembershipResponse} message MembershipResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MembershipResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.alive != null && message.alive.length)
                    for (var i = 0; i < message.alive.length; ++i)
                        $root.gossip.Envelope.encode(message.alive[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.dead != null && message.dead.length)
                    for (var i = 0; i < message.dead.length; ++i)
                        $root.gossip.Envelope.encode(message.dead[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified MembershipResponse message, length delimited. Does not implicitly {@link gossip.MembershipResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.MembershipResponse
             * @static
             * @param {gossip.IMembershipResponse} message MembershipResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MembershipResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a MembershipResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.MembershipResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.MembershipResponse} MembershipResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MembershipResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.MembershipResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.alive && message.alive.length))
                            message.alive = [];
                        message.alive.push($root.gossip.Envelope.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.dead && message.dead.length))
                            message.dead = [];
                        message.dead.push($root.gossip.Envelope.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a MembershipResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.MembershipResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.MembershipResponse} MembershipResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MembershipResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a MembershipResponse message.
             * @function verify
             * @memberof gossip.MembershipResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MembershipResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.alive != null && message.hasOwnProperty("alive")) {
                    if (!Array.isArray(message.alive))
                        return "alive: array expected";
                    for (var i = 0; i < message.alive.length; ++i) {
                        var error = $root.gossip.Envelope.verify(message.alive[i]);
                        if (error)
                            return "alive." + error;
                    }
                }
                if (message.dead != null && message.hasOwnProperty("dead")) {
                    if (!Array.isArray(message.dead))
                        return "dead: array expected";
                    for (var i = 0; i < message.dead.length; ++i) {
                        var error = $root.gossip.Envelope.verify(message.dead[i]);
                        if (error)
                            return "dead." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a MembershipResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.MembershipResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.MembershipResponse} MembershipResponse
             */
            MembershipResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.MembershipResponse)
                    return object;
                var message = new $root.gossip.MembershipResponse();
                if (object.alive) {
                    if (!Array.isArray(object.alive))
                        throw TypeError(".gossip.MembershipResponse.alive: array expected");
                    message.alive = [];
                    for (var i = 0; i < object.alive.length; ++i) {
                        if (typeof object.alive[i] !== "object")
                            throw TypeError(".gossip.MembershipResponse.alive: object expected");
                        message.alive[i] = $root.gossip.Envelope.fromObject(object.alive[i]);
                    }
                }
                if (object.dead) {
                    if (!Array.isArray(object.dead))
                        throw TypeError(".gossip.MembershipResponse.dead: array expected");
                    message.dead = [];
                    for (var i = 0; i < object.dead.length; ++i) {
                        if (typeof object.dead[i] !== "object")
                            throw TypeError(".gossip.MembershipResponse.dead: object expected");
                        message.dead[i] = $root.gossip.Envelope.fromObject(object.dead[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a MembershipResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.MembershipResponse
             * @static
             * @param {gossip.MembershipResponse} message MembershipResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MembershipResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.alive = [];
                    object.dead = [];
                }
                if (message.alive && message.alive.length) {
                    object.alive = [];
                    for (var j = 0; j < message.alive.length; ++j)
                        object.alive[j] = $root.gossip.Envelope.toObject(message.alive[j], options);
                }
                if (message.dead && message.dead.length) {
                    object.dead = [];
                    for (var j = 0; j < message.dead.length; ++j)
                        object.dead[j] = $root.gossip.Envelope.toObject(message.dead[j], options);
                }
                return object;
            };
    
            /**
             * Converts this MembershipResponse to JSON.
             * @function toJSON
             * @memberof gossip.MembershipResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MembershipResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return MembershipResponse;
        })();
    
        gossip.Member = (function() {
    
            /**
             * Properties of a Member.
             * @memberof gossip
             * @interface IMember
             * @property {string|null} [endpoint] Member endpoint
             * @property {Uint8Array|null} [metadata] Member metadata
             * @property {Uint8Array|null} [pkiId] Member pkiId
             */
    
            /**
             * Constructs a new Member.
             * @memberof gossip
             * @classdesc Represents a Member.
             * @implements IMember
             * @constructor
             * @param {gossip.IMember=} [properties] Properties to set
             */
            function Member(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Member endpoint.
             * @member {string} endpoint
             * @memberof gossip.Member
             * @instance
             */
            Member.prototype.endpoint = "";
    
            /**
             * Member metadata.
             * @member {Uint8Array} metadata
             * @memberof gossip.Member
             * @instance
             */
            Member.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Member pkiId.
             * @member {Uint8Array} pkiId
             * @memberof gossip.Member
             * @instance
             */
            Member.prototype.pkiId = $util.newBuffer([]);
    
            /**
             * Creates a new Member instance using the specified properties.
             * @function create
             * @memberof gossip.Member
             * @static
             * @param {gossip.IMember=} [properties] Properties to set
             * @returns {gossip.Member} Member instance
             */
            Member.create = function create(properties) {
                return new Member(properties);
            };
    
            /**
             * Encodes the specified Member message. Does not implicitly {@link gossip.Member.verify|verify} messages.
             * @function encode
             * @memberof gossip.Member
             * @static
             * @param {gossip.IMember} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Member.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endpoint != null && message.hasOwnProperty("endpoint"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.endpoint);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.metadata);
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pkiId);
                return writer;
            };
    
            /**
             * Encodes the specified Member message, length delimited. Does not implicitly {@link gossip.Member.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Member
             * @static
             * @param {gossip.IMember} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Member.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Member message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Member.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Member();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.endpoint = reader.string();
                        break;
                    case 2:
                        message.metadata = reader.bytes();
                        break;
                    case 3:
                        message.pkiId = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Member message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Member.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Member message.
             * @function verify
             * @memberof gossip.Member
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Member.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endpoint != null && message.hasOwnProperty("endpoint"))
                    if (!$util.isString(message.endpoint))
                        return "endpoint: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    if (!(message.pkiId && typeof message.pkiId.length === "number" || $util.isString(message.pkiId)))
                        return "pkiId: buffer expected";
                return null;
            };
    
            /**
             * Creates a Member message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Member
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Member} Member
             */
            Member.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Member)
                    return object;
                var message = new $root.gossip.Member();
                if (object.endpoint != null)
                    message.endpoint = String(object.endpoint);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                if (object.pkiId != null)
                    if (typeof object.pkiId === "string")
                        $util.base64.decode(object.pkiId, message.pkiId = $util.newBuffer($util.base64.length(object.pkiId)), 0);
                    else if (object.pkiId.length)
                        message.pkiId = object.pkiId;
                return message;
            };
    
            /**
             * Creates a plain object from a Member message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Member
             * @static
             * @param {gossip.Member} message Member
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Member.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.endpoint = "";
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                    if (options.bytes === String)
                        object.pkiId = "";
                    else {
                        object.pkiId = [];
                        if (options.bytes !== Array)
                            object.pkiId = $util.newBuffer(object.pkiId);
                    }
                }
                if (message.endpoint != null && message.hasOwnProperty("endpoint"))
                    object.endpoint = message.endpoint;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                if (message.pkiId != null && message.hasOwnProperty("pkiId"))
                    object.pkiId = options.bytes === String ? $util.base64.encode(message.pkiId, 0, message.pkiId.length) : options.bytes === Array ? Array.prototype.slice.call(message.pkiId) : message.pkiId;
                return object;
            };
    
            /**
             * Converts this Member to JSON.
             * @function toJSON
             * @memberof gossip.Member
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Member.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Member;
        })();
    
        gossip.Empty = (function() {
    
            /**
             * Properties of an Empty.
             * @memberof gossip
             * @interface IEmpty
             */
    
            /**
             * Constructs a new Empty.
             * @memberof gossip
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {gossip.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof gossip.Empty
             * @static
             * @param {gossip.IEmpty=} [properties] Properties to set
             * @returns {gossip.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };
    
            /**
             * Encodes the specified Empty message. Does not implicitly {@link gossip.Empty.verify|verify} messages.
             * @function encode
             * @memberof gossip.Empty
             * @static
             * @param {gossip.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link gossip.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Empty
             * @static
             * @param {gossip.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof gossip.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Empty)
                    return object;
                return new $root.gossip.Empty();
            };
    
            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Empty
             * @static
             * @param {gossip.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof gossip.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Empty;
        })();
    
        gossip.RemoteStateRequest = (function() {
    
            /**
             * Properties of a RemoteStateRequest.
             * @memberof gossip
             * @interface IRemoteStateRequest
             * @property {number|Long|null} [startSeqNum] RemoteStateRequest startSeqNum
             * @property {number|Long|null} [endSeqNum] RemoteStateRequest endSeqNum
             */
    
            /**
             * Constructs a new RemoteStateRequest.
             * @memberof gossip
             * @classdesc Represents a RemoteStateRequest.
             * @implements IRemoteStateRequest
             * @constructor
             * @param {gossip.IRemoteStateRequest=} [properties] Properties to set
             */
            function RemoteStateRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RemoteStateRequest startSeqNum.
             * @member {number|Long} startSeqNum
             * @memberof gossip.RemoteStateRequest
             * @instance
             */
            RemoteStateRequest.prototype.startSeqNum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * RemoteStateRequest endSeqNum.
             * @member {number|Long} endSeqNum
             * @memberof gossip.RemoteStateRequest
             * @instance
             */
            RemoteStateRequest.prototype.endSeqNum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new RemoteStateRequest instance using the specified properties.
             * @function create
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {gossip.IRemoteStateRequest=} [properties] Properties to set
             * @returns {gossip.RemoteStateRequest} RemoteStateRequest instance
             */
            RemoteStateRequest.create = function create(properties) {
                return new RemoteStateRequest(properties);
            };
    
            /**
             * Encodes the specified RemoteStateRequest message. Does not implicitly {@link gossip.RemoteStateRequest.verify|verify} messages.
             * @function encode
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {gossip.IRemoteStateRequest} message RemoteStateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoteStateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.startSeqNum != null && message.hasOwnProperty("startSeqNum"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.startSeqNum);
                if (message.endSeqNum != null && message.hasOwnProperty("endSeqNum"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.endSeqNum);
                return writer;
            };
    
            /**
             * Encodes the specified RemoteStateRequest message, length delimited. Does not implicitly {@link gossip.RemoteStateRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {gossip.IRemoteStateRequest} message RemoteStateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoteStateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RemoteStateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.RemoteStateRequest} RemoteStateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoteStateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.RemoteStateRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.startSeqNum = reader.uint64();
                        break;
                    case 2:
                        message.endSeqNum = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RemoteStateRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.RemoteStateRequest} RemoteStateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoteStateRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RemoteStateRequest message.
             * @function verify
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoteStateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.startSeqNum != null && message.hasOwnProperty("startSeqNum"))
                    if (!$util.isInteger(message.startSeqNum) && !(message.startSeqNum && $util.isInteger(message.startSeqNum.low) && $util.isInteger(message.startSeqNum.high)))
                        return "startSeqNum: integer|Long expected";
                if (message.endSeqNum != null && message.hasOwnProperty("endSeqNum"))
                    if (!$util.isInteger(message.endSeqNum) && !(message.endSeqNum && $util.isInteger(message.endSeqNum.low) && $util.isInteger(message.endSeqNum.high)))
                        return "endSeqNum: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a RemoteStateRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.RemoteStateRequest} RemoteStateRequest
             */
            RemoteStateRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.RemoteStateRequest)
                    return object;
                var message = new $root.gossip.RemoteStateRequest();
                if (object.startSeqNum != null)
                    if ($util.Long)
                        (message.startSeqNum = $util.Long.fromValue(object.startSeqNum)).unsigned = true;
                    else if (typeof object.startSeqNum === "string")
                        message.startSeqNum = parseInt(object.startSeqNum, 10);
                    else if (typeof object.startSeqNum === "number")
                        message.startSeqNum = object.startSeqNum;
                    else if (typeof object.startSeqNum === "object")
                        message.startSeqNum = new $util.LongBits(object.startSeqNum.low >>> 0, object.startSeqNum.high >>> 0).toNumber(true);
                if (object.endSeqNum != null)
                    if ($util.Long)
                        (message.endSeqNum = $util.Long.fromValue(object.endSeqNum)).unsigned = true;
                    else if (typeof object.endSeqNum === "string")
                        message.endSeqNum = parseInt(object.endSeqNum, 10);
                    else if (typeof object.endSeqNum === "number")
                        message.endSeqNum = object.endSeqNum;
                    else if (typeof object.endSeqNum === "object")
                        message.endSeqNum = new $util.LongBits(object.endSeqNum.low >>> 0, object.endSeqNum.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a RemoteStateRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.RemoteStateRequest
             * @static
             * @param {gossip.RemoteStateRequest} message RemoteStateRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoteStateRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.startSeqNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.startSeqNum = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.endSeqNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.endSeqNum = options.longs === String ? "0" : 0;
                }
                if (message.startSeqNum != null && message.hasOwnProperty("startSeqNum"))
                    if (typeof message.startSeqNum === "number")
                        object.startSeqNum = options.longs === String ? String(message.startSeqNum) : message.startSeqNum;
                    else
                        object.startSeqNum = options.longs === String ? $util.Long.prototype.toString.call(message.startSeqNum) : options.longs === Number ? new $util.LongBits(message.startSeqNum.low >>> 0, message.startSeqNum.high >>> 0).toNumber(true) : message.startSeqNum;
                if (message.endSeqNum != null && message.hasOwnProperty("endSeqNum"))
                    if (typeof message.endSeqNum === "number")
                        object.endSeqNum = options.longs === String ? String(message.endSeqNum) : message.endSeqNum;
                    else
                        object.endSeqNum = options.longs === String ? $util.Long.prototype.toString.call(message.endSeqNum) : options.longs === Number ? new $util.LongBits(message.endSeqNum.low >>> 0, message.endSeqNum.high >>> 0).toNumber(true) : message.endSeqNum;
                return object;
            };
    
            /**
             * Converts this RemoteStateRequest to JSON.
             * @function toJSON
             * @memberof gossip.RemoteStateRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoteStateRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RemoteStateRequest;
        })();
    
        gossip.RemoteStateResponse = (function() {
    
            /**
             * Properties of a RemoteStateResponse.
             * @memberof gossip
             * @interface IRemoteStateResponse
             * @property {Array.<gossip.IPayload>|null} [payloads] RemoteStateResponse payloads
             */
    
            /**
             * Constructs a new RemoteStateResponse.
             * @memberof gossip
             * @classdesc Represents a RemoteStateResponse.
             * @implements IRemoteStateResponse
             * @constructor
             * @param {gossip.IRemoteStateResponse=} [properties] Properties to set
             */
            function RemoteStateResponse(properties) {
                this.payloads = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RemoteStateResponse payloads.
             * @member {Array.<gossip.IPayload>} payloads
             * @memberof gossip.RemoteStateResponse
             * @instance
             */
            RemoteStateResponse.prototype.payloads = $util.emptyArray;
    
            /**
             * Creates a new RemoteStateResponse instance using the specified properties.
             * @function create
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {gossip.IRemoteStateResponse=} [properties] Properties to set
             * @returns {gossip.RemoteStateResponse} RemoteStateResponse instance
             */
            RemoteStateResponse.create = function create(properties) {
                return new RemoteStateResponse(properties);
            };
    
            /**
             * Encodes the specified RemoteStateResponse message. Does not implicitly {@link gossip.RemoteStateResponse.verify|verify} messages.
             * @function encode
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {gossip.IRemoteStateResponse} message RemoteStateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoteStateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payloads != null && message.payloads.length)
                    for (var i = 0; i < message.payloads.length; ++i)
                        $root.gossip.Payload.encode(message.payloads[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified RemoteStateResponse message, length delimited. Does not implicitly {@link gossip.RemoteStateResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {gossip.IRemoteStateResponse} message RemoteStateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoteStateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RemoteStateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.RemoteStateResponse} RemoteStateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoteStateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.RemoteStateResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.payloads && message.payloads.length))
                            message.payloads = [];
                        message.payloads.push($root.gossip.Payload.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RemoteStateResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.RemoteStateResponse} RemoteStateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoteStateResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RemoteStateResponse message.
             * @function verify
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoteStateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payloads != null && message.hasOwnProperty("payloads")) {
                    if (!Array.isArray(message.payloads))
                        return "payloads: array expected";
                    for (var i = 0; i < message.payloads.length; ++i) {
                        var error = $root.gossip.Payload.verify(message.payloads[i]);
                        if (error)
                            return "payloads." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a RemoteStateResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.RemoteStateResponse} RemoteStateResponse
             */
            RemoteStateResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.RemoteStateResponse)
                    return object;
                var message = new $root.gossip.RemoteStateResponse();
                if (object.payloads) {
                    if (!Array.isArray(object.payloads))
                        throw TypeError(".gossip.RemoteStateResponse.payloads: array expected");
                    message.payloads = [];
                    for (var i = 0; i < object.payloads.length; ++i) {
                        if (typeof object.payloads[i] !== "object")
                            throw TypeError(".gossip.RemoteStateResponse.payloads: object expected");
                        message.payloads[i] = $root.gossip.Payload.fromObject(object.payloads[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a RemoteStateResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.RemoteStateResponse
             * @static
             * @param {gossip.RemoteStateResponse} message RemoteStateResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoteStateResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.payloads = [];
                if (message.payloads && message.payloads.length) {
                    object.payloads = [];
                    for (var j = 0; j < message.payloads.length; ++j)
                        object.payloads[j] = $root.gossip.Payload.toObject(message.payloads[j], options);
                }
                return object;
            };
    
            /**
             * Converts this RemoteStateResponse to JSON.
             * @function toJSON
             * @memberof gossip.RemoteStateResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoteStateResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RemoteStateResponse;
        })();
    
        gossip.RemotePvtDataRequest = (function() {
    
            /**
             * Properties of a RemotePvtDataRequest.
             * @memberof gossip
             * @interface IRemotePvtDataRequest
             * @property {Array.<gossip.IPvtDataDigest>|null} [digests] RemotePvtDataRequest digests
             */
    
            /**
             * Constructs a new RemotePvtDataRequest.
             * @memberof gossip
             * @classdesc Represents a RemotePvtDataRequest.
             * @implements IRemotePvtDataRequest
             * @constructor
             * @param {gossip.IRemotePvtDataRequest=} [properties] Properties to set
             */
            function RemotePvtDataRequest(properties) {
                this.digests = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RemotePvtDataRequest digests.
             * @member {Array.<gossip.IPvtDataDigest>} digests
             * @memberof gossip.RemotePvtDataRequest
             * @instance
             */
            RemotePvtDataRequest.prototype.digests = $util.emptyArray;
    
            /**
             * Creates a new RemotePvtDataRequest instance using the specified properties.
             * @function create
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {gossip.IRemotePvtDataRequest=} [properties] Properties to set
             * @returns {gossip.RemotePvtDataRequest} RemotePvtDataRequest instance
             */
            RemotePvtDataRequest.create = function create(properties) {
                return new RemotePvtDataRequest(properties);
            };
    
            /**
             * Encodes the specified RemotePvtDataRequest message. Does not implicitly {@link gossip.RemotePvtDataRequest.verify|verify} messages.
             * @function encode
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {gossip.IRemotePvtDataRequest} message RemotePvtDataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemotePvtDataRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.digests != null && message.digests.length)
                    for (var i = 0; i < message.digests.length; ++i)
                        $root.gossip.PvtDataDigest.encode(message.digests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified RemotePvtDataRequest message, length delimited. Does not implicitly {@link gossip.RemotePvtDataRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {gossip.IRemotePvtDataRequest} message RemotePvtDataRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemotePvtDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RemotePvtDataRequest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.RemotePvtDataRequest} RemotePvtDataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemotePvtDataRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.RemotePvtDataRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.digests && message.digests.length))
                            message.digests = [];
                        message.digests.push($root.gossip.PvtDataDigest.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RemotePvtDataRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.RemotePvtDataRequest} RemotePvtDataRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemotePvtDataRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RemotePvtDataRequest message.
             * @function verify
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemotePvtDataRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.digests != null && message.hasOwnProperty("digests")) {
                    if (!Array.isArray(message.digests))
                        return "digests: array expected";
                    for (var i = 0; i < message.digests.length; ++i) {
                        var error = $root.gossip.PvtDataDigest.verify(message.digests[i]);
                        if (error)
                            return "digests." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a RemotePvtDataRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.RemotePvtDataRequest} RemotePvtDataRequest
             */
            RemotePvtDataRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.RemotePvtDataRequest)
                    return object;
                var message = new $root.gossip.RemotePvtDataRequest();
                if (object.digests) {
                    if (!Array.isArray(object.digests))
                        throw TypeError(".gossip.RemotePvtDataRequest.digests: array expected");
                    message.digests = [];
                    for (var i = 0; i < object.digests.length; ++i) {
                        if (typeof object.digests[i] !== "object")
                            throw TypeError(".gossip.RemotePvtDataRequest.digests: object expected");
                        message.digests[i] = $root.gossip.PvtDataDigest.fromObject(object.digests[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a RemotePvtDataRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.RemotePvtDataRequest
             * @static
             * @param {gossip.RemotePvtDataRequest} message RemotePvtDataRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemotePvtDataRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.digests = [];
                if (message.digests && message.digests.length) {
                    object.digests = [];
                    for (var j = 0; j < message.digests.length; ++j)
                        object.digests[j] = $root.gossip.PvtDataDigest.toObject(message.digests[j], options);
                }
                return object;
            };
    
            /**
             * Converts this RemotePvtDataRequest to JSON.
             * @function toJSON
             * @memberof gossip.RemotePvtDataRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemotePvtDataRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RemotePvtDataRequest;
        })();
    
        gossip.PvtDataDigest = (function() {
    
            /**
             * Properties of a PvtDataDigest.
             * @memberof gossip
             * @interface IPvtDataDigest
             * @property {string|null} [txId] PvtDataDigest txId
             * @property {string|null} [namespace] PvtDataDigest namespace
             * @property {string|null} [collection] PvtDataDigest collection
             * @property {number|Long|null} [blockSeq] PvtDataDigest blockSeq
             * @property {number|Long|null} [seqInBlock] PvtDataDigest seqInBlock
             */
    
            /**
             * Constructs a new PvtDataDigest.
             * @memberof gossip
             * @classdesc Represents a PvtDataDigest.
             * @implements IPvtDataDigest
             * @constructor
             * @param {gossip.IPvtDataDigest=} [properties] Properties to set
             */
            function PvtDataDigest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PvtDataDigest txId.
             * @member {string} txId
             * @memberof gossip.PvtDataDigest
             * @instance
             */
            PvtDataDigest.prototype.txId = "";
    
            /**
             * PvtDataDigest namespace.
             * @member {string} namespace
             * @memberof gossip.PvtDataDigest
             * @instance
             */
            PvtDataDigest.prototype.namespace = "";
    
            /**
             * PvtDataDigest collection.
             * @member {string} collection
             * @memberof gossip.PvtDataDigest
             * @instance
             */
            PvtDataDigest.prototype.collection = "";
    
            /**
             * PvtDataDigest blockSeq.
             * @member {number|Long} blockSeq
             * @memberof gossip.PvtDataDigest
             * @instance
             */
            PvtDataDigest.prototype.blockSeq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * PvtDataDigest seqInBlock.
             * @member {number|Long} seqInBlock
             * @memberof gossip.PvtDataDigest
             * @instance
             */
            PvtDataDigest.prototype.seqInBlock = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new PvtDataDigest instance using the specified properties.
             * @function create
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {gossip.IPvtDataDigest=} [properties] Properties to set
             * @returns {gossip.PvtDataDigest} PvtDataDigest instance
             */
            PvtDataDigest.create = function create(properties) {
                return new PvtDataDigest(properties);
            };
    
            /**
             * Encodes the specified PvtDataDigest message. Does not implicitly {@link gossip.PvtDataDigest.verify|verify} messages.
             * @function encode
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {gossip.IPvtDataDigest} message PvtDataDigest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PvtDataDigest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txId != null && message.hasOwnProperty("txId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.txId);
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.namespace);
                if (message.collection != null && message.hasOwnProperty("collection"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.collection);
                if (message.blockSeq != null && message.hasOwnProperty("blockSeq"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.blockSeq);
                if (message.seqInBlock != null && message.hasOwnProperty("seqInBlock"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.seqInBlock);
                return writer;
            };
    
            /**
             * Encodes the specified PvtDataDigest message, length delimited. Does not implicitly {@link gossip.PvtDataDigest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {gossip.IPvtDataDigest} message PvtDataDigest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PvtDataDigest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PvtDataDigest message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PvtDataDigest} PvtDataDigest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PvtDataDigest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PvtDataDigest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txId = reader.string();
                        break;
                    case 2:
                        message.namespace = reader.string();
                        break;
                    case 3:
                        message.collection = reader.string();
                        break;
                    case 4:
                        message.blockSeq = reader.uint64();
                        break;
                    case 5:
                        message.seqInBlock = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PvtDataDigest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PvtDataDigest} PvtDataDigest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PvtDataDigest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PvtDataDigest message.
             * @function verify
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PvtDataDigest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isString(message.txId))
                        return "txId: string expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.blockSeq != null && message.hasOwnProperty("blockSeq"))
                    if (!$util.isInteger(message.blockSeq) && !(message.blockSeq && $util.isInteger(message.blockSeq.low) && $util.isInteger(message.blockSeq.high)))
                        return "blockSeq: integer|Long expected";
                if (message.seqInBlock != null && message.hasOwnProperty("seqInBlock"))
                    if (!$util.isInteger(message.seqInBlock) && !(message.seqInBlock && $util.isInteger(message.seqInBlock.low) && $util.isInteger(message.seqInBlock.high)))
                        return "seqInBlock: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a PvtDataDigest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PvtDataDigest} PvtDataDigest
             */
            PvtDataDigest.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PvtDataDigest)
                    return object;
                var message = new $root.gossip.PvtDataDigest();
                if (object.txId != null)
                    message.txId = String(object.txId);
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.blockSeq != null)
                    if ($util.Long)
                        (message.blockSeq = $util.Long.fromValue(object.blockSeq)).unsigned = true;
                    else if (typeof object.blockSeq === "string")
                        message.blockSeq = parseInt(object.blockSeq, 10);
                    else if (typeof object.blockSeq === "number")
                        message.blockSeq = object.blockSeq;
                    else if (typeof object.blockSeq === "object")
                        message.blockSeq = new $util.LongBits(object.blockSeq.low >>> 0, object.blockSeq.high >>> 0).toNumber(true);
                if (object.seqInBlock != null)
                    if ($util.Long)
                        (message.seqInBlock = $util.Long.fromValue(object.seqInBlock)).unsigned = true;
                    else if (typeof object.seqInBlock === "string")
                        message.seqInBlock = parseInt(object.seqInBlock, 10);
                    else if (typeof object.seqInBlock === "number")
                        message.seqInBlock = object.seqInBlock;
                    else if (typeof object.seqInBlock === "object")
                        message.seqInBlock = new $util.LongBits(object.seqInBlock.low >>> 0, object.seqInBlock.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a PvtDataDigest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PvtDataDigest
             * @static
             * @param {gossip.PvtDataDigest} message PvtDataDigest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PvtDataDigest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.txId = "";
                    object.namespace = "";
                    object.collection = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.blockSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.blockSeq = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.seqInBlock = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seqInBlock = options.longs === String ? "0" : 0;
                }
                if (message.txId != null && message.hasOwnProperty("txId"))
                    object.txId = message.txId;
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.blockSeq != null && message.hasOwnProperty("blockSeq"))
                    if (typeof message.blockSeq === "number")
                        object.blockSeq = options.longs === String ? String(message.blockSeq) : message.blockSeq;
                    else
                        object.blockSeq = options.longs === String ? $util.Long.prototype.toString.call(message.blockSeq) : options.longs === Number ? new $util.LongBits(message.blockSeq.low >>> 0, message.blockSeq.high >>> 0).toNumber(true) : message.blockSeq;
                if (message.seqInBlock != null && message.hasOwnProperty("seqInBlock"))
                    if (typeof message.seqInBlock === "number")
                        object.seqInBlock = options.longs === String ? String(message.seqInBlock) : message.seqInBlock;
                    else
                        object.seqInBlock = options.longs === String ? $util.Long.prototype.toString.call(message.seqInBlock) : options.longs === Number ? new $util.LongBits(message.seqInBlock.low >>> 0, message.seqInBlock.high >>> 0).toNumber(true) : message.seqInBlock;
                return object;
            };
    
            /**
             * Converts this PvtDataDigest to JSON.
             * @function toJSON
             * @memberof gossip.PvtDataDigest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PvtDataDigest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PvtDataDigest;
        })();
    
        gossip.RemotePvtDataResponse = (function() {
    
            /**
             * Properties of a RemotePvtDataResponse.
             * @memberof gossip
             * @interface IRemotePvtDataResponse
             * @property {Array.<gossip.IPvtDataElement>|null} [elements] RemotePvtDataResponse elements
             */
    
            /**
             * Constructs a new RemotePvtDataResponse.
             * @memberof gossip
             * @classdesc Represents a RemotePvtDataResponse.
             * @implements IRemotePvtDataResponse
             * @constructor
             * @param {gossip.IRemotePvtDataResponse=} [properties] Properties to set
             */
            function RemotePvtDataResponse(properties) {
                this.elements = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RemotePvtDataResponse elements.
             * @member {Array.<gossip.IPvtDataElement>} elements
             * @memberof gossip.RemotePvtDataResponse
             * @instance
             */
            RemotePvtDataResponse.prototype.elements = $util.emptyArray;
    
            /**
             * Creates a new RemotePvtDataResponse instance using the specified properties.
             * @function create
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {gossip.IRemotePvtDataResponse=} [properties] Properties to set
             * @returns {gossip.RemotePvtDataResponse} RemotePvtDataResponse instance
             */
            RemotePvtDataResponse.create = function create(properties) {
                return new RemotePvtDataResponse(properties);
            };
    
            /**
             * Encodes the specified RemotePvtDataResponse message. Does not implicitly {@link gossip.RemotePvtDataResponse.verify|verify} messages.
             * @function encode
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {gossip.IRemotePvtDataResponse} message RemotePvtDataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemotePvtDataResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.elements != null && message.elements.length)
                    for (var i = 0; i < message.elements.length; ++i)
                        $root.gossip.PvtDataElement.encode(message.elements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified RemotePvtDataResponse message, length delimited. Does not implicitly {@link gossip.RemotePvtDataResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {gossip.IRemotePvtDataResponse} message RemotePvtDataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemotePvtDataResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RemotePvtDataResponse message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.RemotePvtDataResponse} RemotePvtDataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemotePvtDataResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.RemotePvtDataResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.elements && message.elements.length))
                            message.elements = [];
                        message.elements.push($root.gossip.PvtDataElement.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RemotePvtDataResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.RemotePvtDataResponse} RemotePvtDataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemotePvtDataResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RemotePvtDataResponse message.
             * @function verify
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemotePvtDataResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (var i = 0; i < message.elements.length; ++i) {
                        var error = $root.gossip.PvtDataElement.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a RemotePvtDataResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.RemotePvtDataResponse} RemotePvtDataResponse
             */
            RemotePvtDataResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.RemotePvtDataResponse)
                    return object;
                var message = new $root.gossip.RemotePvtDataResponse();
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".gossip.RemotePvtDataResponse.elements: array expected");
                    message.elements = [];
                    for (var i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".gossip.RemotePvtDataResponse.elements: object expected");
                        message.elements[i] = $root.gossip.PvtDataElement.fromObject(object.elements[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a RemotePvtDataResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.RemotePvtDataResponse
             * @static
             * @param {gossip.RemotePvtDataResponse} message RemotePvtDataResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemotePvtDataResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (var j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.gossip.PvtDataElement.toObject(message.elements[j], options);
                }
                return object;
            };
    
            /**
             * Converts this RemotePvtDataResponse to JSON.
             * @function toJSON
             * @memberof gossip.RemotePvtDataResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemotePvtDataResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RemotePvtDataResponse;
        })();
    
        gossip.PvtDataElement = (function() {
    
            /**
             * Properties of a PvtDataElement.
             * @memberof gossip
             * @interface IPvtDataElement
             * @property {gossip.IPvtDataDigest|null} [digest] PvtDataElement digest
             * @property {Array.<Uint8Array>|null} [payload] PvtDataElement payload
             */
    
            /**
             * Constructs a new PvtDataElement.
             * @memberof gossip
             * @classdesc Represents a PvtDataElement.
             * @implements IPvtDataElement
             * @constructor
             * @param {gossip.IPvtDataElement=} [properties] Properties to set
             */
            function PvtDataElement(properties) {
                this.payload = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PvtDataElement digest.
             * @member {gossip.IPvtDataDigest|null|undefined} digest
             * @memberof gossip.PvtDataElement
             * @instance
             */
            PvtDataElement.prototype.digest = null;
    
            /**
             * PvtDataElement payload.
             * @member {Array.<Uint8Array>} payload
             * @memberof gossip.PvtDataElement
             * @instance
             */
            PvtDataElement.prototype.payload = $util.emptyArray;
    
            /**
             * Creates a new PvtDataElement instance using the specified properties.
             * @function create
             * @memberof gossip.PvtDataElement
             * @static
             * @param {gossip.IPvtDataElement=} [properties] Properties to set
             * @returns {gossip.PvtDataElement} PvtDataElement instance
             */
            PvtDataElement.create = function create(properties) {
                return new PvtDataElement(properties);
            };
    
            /**
             * Encodes the specified PvtDataElement message. Does not implicitly {@link gossip.PvtDataElement.verify|verify} messages.
             * @function encode
             * @memberof gossip.PvtDataElement
             * @static
             * @param {gossip.IPvtDataElement} message PvtDataElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PvtDataElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.digest != null && message.hasOwnProperty("digest"))
                    $root.gossip.PvtDataDigest.encode(message.digest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.payload != null && message.payload.length)
                    for (var i = 0; i < message.payload.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload[i]);
                return writer;
            };
    
            /**
             * Encodes the specified PvtDataElement message, length delimited. Does not implicitly {@link gossip.PvtDataElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PvtDataElement
             * @static
             * @param {gossip.IPvtDataElement} message PvtDataElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PvtDataElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PvtDataElement message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PvtDataElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PvtDataElement} PvtDataElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PvtDataElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PvtDataElement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.digest = $root.gossip.PvtDataDigest.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.payload && message.payload.length))
                            message.payload = [];
                        message.payload.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PvtDataElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PvtDataElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PvtDataElement} PvtDataElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PvtDataElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PvtDataElement message.
             * @function verify
             * @memberof gossip.PvtDataElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PvtDataElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.digest != null && message.hasOwnProperty("digest")) {
                    var error = $root.gossip.PvtDataDigest.verify(message.digest);
                    if (error)
                        return "digest." + error;
                }
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    if (!Array.isArray(message.payload))
                        return "payload: array expected";
                    for (var i = 0; i < message.payload.length; ++i)
                        if (!(message.payload[i] && typeof message.payload[i].length === "number" || $util.isString(message.payload[i])))
                            return "payload: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a PvtDataElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PvtDataElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PvtDataElement} PvtDataElement
             */
            PvtDataElement.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PvtDataElement)
                    return object;
                var message = new $root.gossip.PvtDataElement();
                if (object.digest != null) {
                    if (typeof object.digest !== "object")
                        throw TypeError(".gossip.PvtDataElement.digest: object expected");
                    message.digest = $root.gossip.PvtDataDigest.fromObject(object.digest);
                }
                if (object.payload) {
                    if (!Array.isArray(object.payload))
                        throw TypeError(".gossip.PvtDataElement.payload: array expected");
                    message.payload = [];
                    for (var i = 0; i < object.payload.length; ++i)
                        if (typeof object.payload[i] === "string")
                            $util.base64.decode(object.payload[i], message.payload[i] = $util.newBuffer($util.base64.length(object.payload[i])), 0);
                        else if (object.payload[i].length)
                            message.payload[i] = object.payload[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PvtDataElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PvtDataElement
             * @static
             * @param {gossip.PvtDataElement} message PvtDataElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PvtDataElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.payload = [];
                if (options.defaults)
                    object.digest = null;
                if (message.digest != null && message.hasOwnProperty("digest"))
                    object.digest = $root.gossip.PvtDataDigest.toObject(message.digest, options);
                if (message.payload && message.payload.length) {
                    object.payload = [];
                    for (var j = 0; j < message.payload.length; ++j)
                        object.payload[j] = options.bytes === String ? $util.base64.encode(message.payload[j], 0, message.payload[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.payload[j]) : message.payload[j];
                }
                return object;
            };
    
            /**
             * Converts this PvtDataElement to JSON.
             * @function toJSON
             * @memberof gossip.PvtDataElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PvtDataElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PvtDataElement;
        })();
    
        gossip.PvtDataPayload = (function() {
    
            /**
             * Properties of a PvtDataPayload.
             * @memberof gossip
             * @interface IPvtDataPayload
             * @property {number|Long|null} [txSeqInBlock] PvtDataPayload txSeqInBlock
             * @property {Uint8Array|null} [payload] PvtDataPayload payload
             */
    
            /**
             * Constructs a new PvtDataPayload.
             * @memberof gossip
             * @classdesc Represents a PvtDataPayload.
             * @implements IPvtDataPayload
             * @constructor
             * @param {gossip.IPvtDataPayload=} [properties] Properties to set
             */
            function PvtDataPayload(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PvtDataPayload txSeqInBlock.
             * @member {number|Long} txSeqInBlock
             * @memberof gossip.PvtDataPayload
             * @instance
             */
            PvtDataPayload.prototype.txSeqInBlock = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * PvtDataPayload payload.
             * @member {Uint8Array} payload
             * @memberof gossip.PvtDataPayload
             * @instance
             */
            PvtDataPayload.prototype.payload = $util.newBuffer([]);
    
            /**
             * Creates a new PvtDataPayload instance using the specified properties.
             * @function create
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {gossip.IPvtDataPayload=} [properties] Properties to set
             * @returns {gossip.PvtDataPayload} PvtDataPayload instance
             */
            PvtDataPayload.create = function create(properties) {
                return new PvtDataPayload(properties);
            };
    
            /**
             * Encodes the specified PvtDataPayload message. Does not implicitly {@link gossip.PvtDataPayload.verify|verify} messages.
             * @function encode
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {gossip.IPvtDataPayload} message PvtDataPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PvtDataPayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txSeqInBlock != null && message.hasOwnProperty("txSeqInBlock"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.txSeqInBlock);
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                return writer;
            };
    
            /**
             * Encodes the specified PvtDataPayload message, length delimited. Does not implicitly {@link gossip.PvtDataPayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {gossip.IPvtDataPayload} message PvtDataPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PvtDataPayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PvtDataPayload message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.PvtDataPayload} PvtDataPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PvtDataPayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.PvtDataPayload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txSeqInBlock = reader.uint64();
                        break;
                    case 2:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PvtDataPayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.PvtDataPayload} PvtDataPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PvtDataPayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PvtDataPayload message.
             * @function verify
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PvtDataPayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.txSeqInBlock != null && message.hasOwnProperty("txSeqInBlock"))
                    if (!$util.isInteger(message.txSeqInBlock) && !(message.txSeqInBlock && $util.isInteger(message.txSeqInBlock.low) && $util.isInteger(message.txSeqInBlock.high)))
                        return "txSeqInBlock: integer|Long expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };
    
            /**
             * Creates a PvtDataPayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.PvtDataPayload} PvtDataPayload
             */
            PvtDataPayload.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.PvtDataPayload)
                    return object;
                var message = new $root.gossip.PvtDataPayload();
                if (object.txSeqInBlock != null)
                    if ($util.Long)
                        (message.txSeqInBlock = $util.Long.fromValue(object.txSeqInBlock)).unsigned = true;
                    else if (typeof object.txSeqInBlock === "string")
                        message.txSeqInBlock = parseInt(object.txSeqInBlock, 10);
                    else if (typeof object.txSeqInBlock === "number")
                        message.txSeqInBlock = object.txSeqInBlock;
                    else if (typeof object.txSeqInBlock === "object")
                        message.txSeqInBlock = new $util.LongBits(object.txSeqInBlock.low >>> 0, object.txSeqInBlock.high >>> 0).toNumber(true);
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };
    
            /**
             * Creates a plain object from a PvtDataPayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.PvtDataPayload
             * @static
             * @param {gossip.PvtDataPayload} message PvtDataPayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PvtDataPayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.txSeqInBlock = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.txSeqInBlock = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                }
                if (message.txSeqInBlock != null && message.hasOwnProperty("txSeqInBlock"))
                    if (typeof message.txSeqInBlock === "number")
                        object.txSeqInBlock = options.longs === String ? String(message.txSeqInBlock) : message.txSeqInBlock;
                    else
                        object.txSeqInBlock = options.longs === String ? $util.Long.prototype.toString.call(message.txSeqInBlock) : options.longs === Number ? new $util.LongBits(message.txSeqInBlock.low >>> 0, message.txSeqInBlock.high >>> 0).toNumber(true) : message.txSeqInBlock;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };
    
            /**
             * Converts this PvtDataPayload to JSON.
             * @function toJSON
             * @memberof gossip.PvtDataPayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PvtDataPayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PvtDataPayload;
        })();
    
        gossip.Acknowledgement = (function() {
    
            /**
             * Properties of an Acknowledgement.
             * @memberof gossip
             * @interface IAcknowledgement
             * @property {string|null} [error] Acknowledgement error
             */
    
            /**
             * Constructs a new Acknowledgement.
             * @memberof gossip
             * @classdesc Represents an Acknowledgement.
             * @implements IAcknowledgement
             * @constructor
             * @param {gossip.IAcknowledgement=} [properties] Properties to set
             */
            function Acknowledgement(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Acknowledgement error.
             * @member {string} error
             * @memberof gossip.Acknowledgement
             * @instance
             */
            Acknowledgement.prototype.error = "";
    
            /**
             * Creates a new Acknowledgement instance using the specified properties.
             * @function create
             * @memberof gossip.Acknowledgement
             * @static
             * @param {gossip.IAcknowledgement=} [properties] Properties to set
             * @returns {gossip.Acknowledgement} Acknowledgement instance
             */
            Acknowledgement.create = function create(properties) {
                return new Acknowledgement(properties);
            };
    
            /**
             * Encodes the specified Acknowledgement message. Does not implicitly {@link gossip.Acknowledgement.verify|verify} messages.
             * @function encode
             * @memberof gossip.Acknowledgement
             * @static
             * @param {gossip.IAcknowledgement} message Acknowledgement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Acknowledgement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.error != null && message.hasOwnProperty("error"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.error);
                return writer;
            };
    
            /**
             * Encodes the specified Acknowledgement message, length delimited. Does not implicitly {@link gossip.Acknowledgement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Acknowledgement
             * @static
             * @param {gossip.IAcknowledgement} message Acknowledgement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Acknowledgement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Acknowledgement message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Acknowledgement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Acknowledgement} Acknowledgement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Acknowledgement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Acknowledgement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.error = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Acknowledgement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Acknowledgement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Acknowledgement} Acknowledgement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Acknowledgement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Acknowledgement message.
             * @function verify
             * @memberof gossip.Acknowledgement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Acknowledgement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.error != null && message.hasOwnProperty("error"))
                    if (!$util.isString(message.error))
                        return "error: string expected";
                return null;
            };
    
            /**
             * Creates an Acknowledgement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Acknowledgement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Acknowledgement} Acknowledgement
             */
            Acknowledgement.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Acknowledgement)
                    return object;
                var message = new $root.gossip.Acknowledgement();
                if (object.error != null)
                    message.error = String(object.error);
                return message;
            };
    
            /**
             * Creates a plain object from an Acknowledgement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Acknowledgement
             * @static
             * @param {gossip.Acknowledgement} message Acknowledgement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Acknowledgement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.error = "";
                if (message.error != null && message.hasOwnProperty("error"))
                    object.error = message.error;
                return object;
            };
    
            /**
             * Converts this Acknowledgement to JSON.
             * @function toJSON
             * @memberof gossip.Acknowledgement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Acknowledgement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Acknowledgement;
        })();
    
        gossip.Chaincode = (function() {
    
            /**
             * Properties of a Chaincode.
             * @memberof gossip
             * @interface IChaincode
             * @property {string|null} [name] Chaincode name
             * @property {string|null} [version] Chaincode version
             * @property {Uint8Array|null} [metadata] Chaincode metadata
             */
    
            /**
             * Constructs a new Chaincode.
             * @memberof gossip
             * @classdesc Represents a Chaincode.
             * @implements IChaincode
             * @constructor
             * @param {gossip.IChaincode=} [properties] Properties to set
             */
            function Chaincode(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Chaincode name.
             * @member {string} name
             * @memberof gossip.Chaincode
             * @instance
             */
            Chaincode.prototype.name = "";
    
            /**
             * Chaincode version.
             * @member {string} version
             * @memberof gossip.Chaincode
             * @instance
             */
            Chaincode.prototype.version = "";
    
            /**
             * Chaincode metadata.
             * @member {Uint8Array} metadata
             * @memberof gossip.Chaincode
             * @instance
             */
            Chaincode.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Creates a new Chaincode instance using the specified properties.
             * @function create
             * @memberof gossip.Chaincode
             * @static
             * @param {gossip.IChaincode=} [properties] Properties to set
             * @returns {gossip.Chaincode} Chaincode instance
             */
            Chaincode.create = function create(properties) {
                return new Chaincode(properties);
            };
    
            /**
             * Encodes the specified Chaincode message. Does not implicitly {@link gossip.Chaincode.verify|verify} messages.
             * @function encode
             * @memberof gossip.Chaincode
             * @static
             * @param {gossip.IChaincode} message Chaincode message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Chaincode.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.metadata);
                return writer;
            };
    
            /**
             * Encodes the specified Chaincode message, length delimited. Does not implicitly {@link gossip.Chaincode.verify|verify} messages.
             * @function encodeDelimited
             * @memberof gossip.Chaincode
             * @static
             * @param {gossip.IChaincode} message Chaincode message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Chaincode.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Chaincode message from the specified reader or buffer.
             * @function decode
             * @memberof gossip.Chaincode
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {gossip.Chaincode} Chaincode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Chaincode.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gossip.Chaincode();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    case 3:
                        message.metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Chaincode message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof gossip.Chaincode
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {gossip.Chaincode} Chaincode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Chaincode.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Chaincode message.
             * @function verify
             * @memberof gossip.Chaincode
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Chaincode.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates a Chaincode message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof gossip.Chaincode
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {gossip.Chaincode} Chaincode
             */
            Chaincode.fromObject = function fromObject(object) {
                if (object instanceof $root.gossip.Chaincode)
                    return object;
                var message = new $root.gossip.Chaincode();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                return message;
            };
    
            /**
             * Creates a plain object from a Chaincode message. Also converts values to other types if specified.
             * @function toObject
             * @memberof gossip.Chaincode
             * @static
             * @param {gossip.Chaincode} message Chaincode
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Chaincode.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.version = "";
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                return object;
            };
    
            /**
             * Converts this Chaincode to JSON.
             * @function toJSON
             * @memberof gossip.Chaincode
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Chaincode.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Chaincode;
        })();
    
        return gossip;
    })();
    
    $root.protos = (function() {
    
        /**
         * Namespace protos.
         * @exports protos
         * @namespace
         */
        var protos = {};
    
        protos.SignedChaincodeDeploymentSpec = (function() {
    
            /**
             * Properties of a SignedChaincodeDeploymentSpec.
             * @memberof protos
             * @interface ISignedChaincodeDeploymentSpec
             * @property {Uint8Array|null} [chaincodeDeploymentSpec] SignedChaincodeDeploymentSpec chaincodeDeploymentSpec
             * @property {Uint8Array|null} [instantiationPolicy] SignedChaincodeDeploymentSpec instantiationPolicy
             * @property {Array.<protos.IEndorsement>|null} [ownerEndorsements] SignedChaincodeDeploymentSpec ownerEndorsements
             */
    
            /**
             * Constructs a new SignedChaincodeDeploymentSpec.
             * @memberof protos
             * @classdesc Represents a SignedChaincodeDeploymentSpec.
             * @implements ISignedChaincodeDeploymentSpec
             * @constructor
             * @param {protos.ISignedChaincodeDeploymentSpec=} [properties] Properties to set
             */
            function SignedChaincodeDeploymentSpec(properties) {
                this.ownerEndorsements = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignedChaincodeDeploymentSpec chaincodeDeploymentSpec.
             * @member {Uint8Array} chaincodeDeploymentSpec
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @instance
             */
            SignedChaincodeDeploymentSpec.prototype.chaincodeDeploymentSpec = $util.newBuffer([]);
    
            /**
             * SignedChaincodeDeploymentSpec instantiationPolicy.
             * @member {Uint8Array} instantiationPolicy
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @instance
             */
            SignedChaincodeDeploymentSpec.prototype.instantiationPolicy = $util.newBuffer([]);
    
            /**
             * SignedChaincodeDeploymentSpec ownerEndorsements.
             * @member {Array.<protos.IEndorsement>} ownerEndorsements
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @instance
             */
            SignedChaincodeDeploymentSpec.prototype.ownerEndorsements = $util.emptyArray;
    
            /**
             * Creates a new SignedChaincodeDeploymentSpec instance using the specified properties.
             * @function create
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {protos.ISignedChaincodeDeploymentSpec=} [properties] Properties to set
             * @returns {protos.SignedChaincodeDeploymentSpec} SignedChaincodeDeploymentSpec instance
             */
            SignedChaincodeDeploymentSpec.create = function create(properties) {
                return new SignedChaincodeDeploymentSpec(properties);
            };
    
            /**
             * Encodes the specified SignedChaincodeDeploymentSpec message. Does not implicitly {@link protos.SignedChaincodeDeploymentSpec.verify|verify} messages.
             * @function encode
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {protos.ISignedChaincodeDeploymentSpec} message SignedChaincodeDeploymentSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedChaincodeDeploymentSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodeDeploymentSpec != null && message.hasOwnProperty("chaincodeDeploymentSpec"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chaincodeDeploymentSpec);
                if (message.instantiationPolicy != null && message.hasOwnProperty("instantiationPolicy"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.instantiationPolicy);
                if (message.ownerEndorsements != null && message.ownerEndorsements.length)
                    for (var i = 0; i < message.ownerEndorsements.length; ++i)
                        $root.protos.Endorsement.encode(message.ownerEndorsements[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SignedChaincodeDeploymentSpec message, length delimited. Does not implicitly {@link protos.SignedChaincodeDeploymentSpec.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {protos.ISignedChaincodeDeploymentSpec} message SignedChaincodeDeploymentSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedChaincodeDeploymentSpec.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignedChaincodeDeploymentSpec message from the specified reader or buffer.
             * @function decode
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.SignedChaincodeDeploymentSpec} SignedChaincodeDeploymentSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedChaincodeDeploymentSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.SignedChaincodeDeploymentSpec();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincodeDeploymentSpec = reader.bytes();
                        break;
                    case 2:
                        message.instantiationPolicy = reader.bytes();
                        break;
                    case 3:
                        if (!(message.ownerEndorsements && message.ownerEndorsements.length))
                            message.ownerEndorsements = [];
                        message.ownerEndorsements.push($root.protos.Endorsement.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignedChaincodeDeploymentSpec message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.SignedChaincodeDeploymentSpec} SignedChaincodeDeploymentSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedChaincodeDeploymentSpec.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignedChaincodeDeploymentSpec message.
             * @function verify
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignedChaincodeDeploymentSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodeDeploymentSpec != null && message.hasOwnProperty("chaincodeDeploymentSpec"))
                    if (!(message.chaincodeDeploymentSpec && typeof message.chaincodeDeploymentSpec.length === "number" || $util.isString(message.chaincodeDeploymentSpec)))
                        return "chaincodeDeploymentSpec: buffer expected";
                if (message.instantiationPolicy != null && message.hasOwnProperty("instantiationPolicy"))
                    if (!(message.instantiationPolicy && typeof message.instantiationPolicy.length === "number" || $util.isString(message.instantiationPolicy)))
                        return "instantiationPolicy: buffer expected";
                if (message.ownerEndorsements != null && message.hasOwnProperty("ownerEndorsements")) {
                    if (!Array.isArray(message.ownerEndorsements))
                        return "ownerEndorsements: array expected";
                    for (var i = 0; i < message.ownerEndorsements.length; ++i) {
                        var error = $root.protos.Endorsement.verify(message.ownerEndorsements[i]);
                        if (error)
                            return "ownerEndorsements." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SignedChaincodeDeploymentSpec message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.SignedChaincodeDeploymentSpec} SignedChaincodeDeploymentSpec
             */
            SignedChaincodeDeploymentSpec.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.SignedChaincodeDeploymentSpec)
                    return object;
                var message = new $root.protos.SignedChaincodeDeploymentSpec();
                if (object.chaincodeDeploymentSpec != null)
                    if (typeof object.chaincodeDeploymentSpec === "string")
                        $util.base64.decode(object.chaincodeDeploymentSpec, message.chaincodeDeploymentSpec = $util.newBuffer($util.base64.length(object.chaincodeDeploymentSpec)), 0);
                    else if (object.chaincodeDeploymentSpec.length)
                        message.chaincodeDeploymentSpec = object.chaincodeDeploymentSpec;
                if (object.instantiationPolicy != null)
                    if (typeof object.instantiationPolicy === "string")
                        $util.base64.decode(object.instantiationPolicy, message.instantiationPolicy = $util.newBuffer($util.base64.length(object.instantiationPolicy)), 0);
                    else if (object.instantiationPolicy.length)
                        message.instantiationPolicy = object.instantiationPolicy;
                if (object.ownerEndorsements) {
                    if (!Array.isArray(object.ownerEndorsements))
                        throw TypeError(".protos.SignedChaincodeDeploymentSpec.ownerEndorsements: array expected");
                    message.ownerEndorsements = [];
                    for (var i = 0; i < object.ownerEndorsements.length; ++i) {
                        if (typeof object.ownerEndorsements[i] !== "object")
                            throw TypeError(".protos.SignedChaincodeDeploymentSpec.ownerEndorsements: object expected");
                        message.ownerEndorsements[i] = $root.protos.Endorsement.fromObject(object.ownerEndorsements[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SignedChaincodeDeploymentSpec message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @static
             * @param {protos.SignedChaincodeDeploymentSpec} message SignedChaincodeDeploymentSpec
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignedChaincodeDeploymentSpec.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ownerEndorsements = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.chaincodeDeploymentSpec = "";
                    else {
                        object.chaincodeDeploymentSpec = [];
                        if (options.bytes !== Array)
                            object.chaincodeDeploymentSpec = $util.newBuffer(object.chaincodeDeploymentSpec);
                    }
                    if (options.bytes === String)
                        object.instantiationPolicy = "";
                    else {
                        object.instantiationPolicy = [];
                        if (options.bytes !== Array)
                            object.instantiationPolicy = $util.newBuffer(object.instantiationPolicy);
                    }
                }
                if (message.chaincodeDeploymentSpec != null && message.hasOwnProperty("chaincodeDeploymentSpec"))
                    object.chaincodeDeploymentSpec = options.bytes === String ? $util.base64.encode(message.chaincodeDeploymentSpec, 0, message.chaincodeDeploymentSpec.length) : options.bytes === Array ? Array.prototype.slice.call(message.chaincodeDeploymentSpec) : message.chaincodeDeploymentSpec;
                if (message.instantiationPolicy != null && message.hasOwnProperty("instantiationPolicy"))
                    object.instantiationPolicy = options.bytes === String ? $util.base64.encode(message.instantiationPolicy, 0, message.instantiationPolicy.length) : options.bytes === Array ? Array.prototype.slice.call(message.instantiationPolicy) : message.instantiationPolicy;
                if (message.ownerEndorsements && message.ownerEndorsements.length) {
                    object.ownerEndorsements = [];
                    for (var j = 0; j < message.ownerEndorsements.length; ++j)
                        object.ownerEndorsements[j] = $root.protos.Endorsement.toObject(message.ownerEndorsements[j], options);
                }
                return object;
            };
    
            /**
             * Converts this SignedChaincodeDeploymentSpec to JSON.
             * @function toJSON
             * @memberof protos.SignedChaincodeDeploymentSpec
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignedChaincodeDeploymentSpec.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignedChaincodeDeploymentSpec;
        })();
    
        protos.ProposalResponse = (function() {
    
            /**
             * Properties of a ProposalResponse.
             * @memberof protos
             * @interface IProposalResponse
             * @property {number|null} [version] ProposalResponse version
             * @property {google.protobuf.ITimestamp|null} [timestamp] ProposalResponse timestamp
             * @property {protos.IResponse|null} [response] ProposalResponse response
             * @property {Uint8Array|null} [payload] ProposalResponse payload
             * @property {protos.IEndorsement|null} [endorsement] ProposalResponse endorsement
             */
    
            /**
             * Constructs a new ProposalResponse.
             * @memberof protos
             * @classdesc Represents a ProposalResponse.
             * @implements IProposalResponse
             * @constructor
             * @param {protos.IProposalResponse=} [properties] Properties to set
             */
            function ProposalResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ProposalResponse version.
             * @member {number} version
             * @memberof protos.ProposalResponse
             * @instance
             */
            ProposalResponse.prototype.version = 0;
    
            /**
             * ProposalResponse timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof protos.ProposalResponse
             * @instance
             */
            ProposalResponse.prototype.timestamp = null;
    
            /**
             * ProposalResponse response.
             * @member {protos.IResponse|null|undefined} response
             * @memberof protos.ProposalResponse
             * @instance
             */
            ProposalResponse.prototype.response = null;
    
            /**
             * ProposalResponse payload.
             * @member {Uint8Array} payload
             * @memberof protos.ProposalResponse
             * @instance
             */
            ProposalResponse.prototype.payload = $util.newBuffer([]);
    
            /**
             * ProposalResponse endorsement.
             * @member {protos.IEndorsement|null|undefined} endorsement
             * @memberof protos.ProposalResponse
             * @instance
             */
            ProposalResponse.prototype.endorsement = null;
    
            /**
             * Creates a new ProposalResponse instance using the specified properties.
             * @function create
             * @memberof protos.ProposalResponse
             * @static
             * @param {protos.IProposalResponse=} [properties] Properties to set
             * @returns {protos.ProposalResponse} ProposalResponse instance
             */
            ProposalResponse.create = function create(properties) {
                return new ProposalResponse(properties);
            };
    
            /**
             * Encodes the specified ProposalResponse message. Does not implicitly {@link protos.ProposalResponse.verify|verify} messages.
             * @function encode
             * @memberof protos.ProposalResponse
             * @static
             * @param {protos.IProposalResponse} message ProposalResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProposalResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.response != null && message.hasOwnProperty("response"))
                    $root.protos.Response.encode(message.response, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.payload);
                if (message.endorsement != null && message.hasOwnProperty("endorsement"))
                    $root.protos.Endorsement.encode(message.endorsement, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ProposalResponse message, length delimited. Does not implicitly {@link protos.ProposalResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ProposalResponse
             * @static
             * @param {protos.IProposalResponse} message ProposalResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProposalResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ProposalResponse message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ProposalResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ProposalResponse} ProposalResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProposalResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ProposalResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.int32();
                        break;
                    case 2:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.response = $root.protos.Response.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.payload = reader.bytes();
                        break;
                    case 6:
                        message.endorsement = $root.protos.Endorsement.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ProposalResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ProposalResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ProposalResponse} ProposalResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProposalResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ProposalResponse message.
             * @function verify
             * @memberof protos.ProposalResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProposalResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.response != null && message.hasOwnProperty("response")) {
                    var error = $root.protos.Response.verify(message.response);
                    if (error)
                        return "response." + error;
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.endorsement != null && message.hasOwnProperty("endorsement")) {
                    var error = $root.protos.Endorsement.verify(message.endorsement);
                    if (error)
                        return "endorsement." + error;
                }
                return null;
            };
    
            /**
             * Creates a ProposalResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ProposalResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ProposalResponse} ProposalResponse
             */
            ProposalResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ProposalResponse)
                    return object;
                var message = new $root.protos.ProposalResponse();
                if (object.version != null)
                    message.version = object.version | 0;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".protos.ProposalResponse.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                if (object.response != null) {
                    if (typeof object.response !== "object")
                        throw TypeError(".protos.ProposalResponse.response: object expected");
                    message.response = $root.protos.Response.fromObject(object.response);
                }
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.endorsement != null) {
                    if (typeof object.endorsement !== "object")
                        throw TypeError(".protos.ProposalResponse.endorsement: object expected");
                    message.endorsement = $root.protos.Endorsement.fromObject(object.endorsement);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ProposalResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ProposalResponse
             * @static
             * @param {protos.ProposalResponse} message ProposalResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProposalResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.version = 0;
                    object.timestamp = null;
                    object.response = null;
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    object.endorsement = null;
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                if (message.response != null && message.hasOwnProperty("response"))
                    object.response = $root.protos.Response.toObject(message.response, options);
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.endorsement != null && message.hasOwnProperty("endorsement"))
                    object.endorsement = $root.protos.Endorsement.toObject(message.endorsement, options);
                return object;
            };
    
            /**
             * Converts this ProposalResponse to JSON.
             * @function toJSON
             * @memberof protos.ProposalResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProposalResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ProposalResponse;
        })();
    
        protos.Response = (function() {
    
            /**
             * Properties of a Response.
             * @memberof protos
             * @interface IResponse
             * @property {number|null} [status] Response status
             * @property {string|null} [message] Response message
             * @property {Uint8Array|null} [payload] Response payload
             */
    
            /**
             * Constructs a new Response.
             * @memberof protos
             * @classdesc Represents a Response.
             * @implements IResponse
             * @constructor
             * @param {protos.IResponse=} [properties] Properties to set
             */
            function Response(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Response status.
             * @member {number} status
             * @memberof protos.Response
             * @instance
             */
            Response.prototype.status = 0;
    
            /**
             * Response message.
             * @member {string} message
             * @memberof protos.Response
             * @instance
             */
            Response.prototype.message = "";
    
            /**
             * Response payload.
             * @member {Uint8Array} payload
             * @memberof protos.Response
             * @instance
             */
            Response.prototype.payload = $util.newBuffer([]);
    
            /**
             * Creates a new Response instance using the specified properties.
             * @function create
             * @memberof protos.Response
             * @static
             * @param {protos.IResponse=} [properties] Properties to set
             * @returns {protos.Response} Response instance
             */
            Response.create = function create(properties) {
                return new Response(properties);
            };
    
            /**
             * Encodes the specified Response message. Does not implicitly {@link protos.Response.verify|verify} messages.
             * @function encode
             * @memberof protos.Response
             * @static
             * @param {protos.IResponse} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
                return writer;
            };
    
            /**
             * Encodes the specified Response message, length delimited. Does not implicitly {@link protos.Response.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.Response
             * @static
             * @param {protos.IResponse} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Response message from the specified reader or buffer.
             * @function decode
             * @memberof protos.Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.Response();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Response message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Response message.
             * @function verify
             * @memberof protos.Response
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Response.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };
    
            /**
             * Creates a Response message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.Response
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.Response} Response
             */
            Response.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.Response)
                    return object;
                var message = new $root.protos.Response();
                if (object.status != null)
                    message.status = object.status | 0;
                if (object.message != null)
                    message.message = String(object.message);
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };
    
            /**
             * Creates a plain object from a Response message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.Response
             * @static
             * @param {protos.Response} message Response
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Response.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.status = 0;
                    object.message = "";
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };
    
            /**
             * Converts this Response to JSON.
             * @function toJSON
             * @memberof protos.Response
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Response.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Response;
        })();
    
        protos.ProposalResponsePayload = (function() {
    
            /**
             * Properties of a ProposalResponsePayload.
             * @memberof protos
             * @interface IProposalResponsePayload
             * @property {Uint8Array|null} [proposalHash] ProposalResponsePayload proposalHash
             * @property {Uint8Array|null} [extension] ProposalResponsePayload extension
             */
    
            /**
             * Constructs a new ProposalResponsePayload.
             * @memberof protos
             * @classdesc Represents a ProposalResponsePayload.
             * @implements IProposalResponsePayload
             * @constructor
             * @param {protos.IProposalResponsePayload=} [properties] Properties to set
             */
            function ProposalResponsePayload(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ProposalResponsePayload proposalHash.
             * @member {Uint8Array} proposalHash
             * @memberof protos.ProposalResponsePayload
             * @instance
             */
            ProposalResponsePayload.prototype.proposalHash = $util.newBuffer([]);
    
            /**
             * ProposalResponsePayload extension.
             * @member {Uint8Array} extension
             * @memberof protos.ProposalResponsePayload
             * @instance
             */
            ProposalResponsePayload.prototype.extension = $util.newBuffer([]);
    
            /**
             * Creates a new ProposalResponsePayload instance using the specified properties.
             * @function create
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {protos.IProposalResponsePayload=} [properties] Properties to set
             * @returns {protos.ProposalResponsePayload} ProposalResponsePayload instance
             */
            ProposalResponsePayload.create = function create(properties) {
                return new ProposalResponsePayload(properties);
            };
    
            /**
             * Encodes the specified ProposalResponsePayload message. Does not implicitly {@link protos.ProposalResponsePayload.verify|verify} messages.
             * @function encode
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {protos.IProposalResponsePayload} message ProposalResponsePayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProposalResponsePayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.proposalHash != null && message.hasOwnProperty("proposalHash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.proposalHash);
                if (message.extension != null && message.hasOwnProperty("extension"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.extension);
                return writer;
            };
    
            /**
             * Encodes the specified ProposalResponsePayload message, length delimited. Does not implicitly {@link protos.ProposalResponsePayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {protos.IProposalResponsePayload} message ProposalResponsePayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProposalResponsePayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ProposalResponsePayload message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ProposalResponsePayload} ProposalResponsePayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProposalResponsePayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ProposalResponsePayload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.proposalHash = reader.bytes();
                        break;
                    case 2:
                        message.extension = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ProposalResponsePayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ProposalResponsePayload} ProposalResponsePayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProposalResponsePayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ProposalResponsePayload message.
             * @function verify
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProposalResponsePayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.proposalHash != null && message.hasOwnProperty("proposalHash"))
                    if (!(message.proposalHash && typeof message.proposalHash.length === "number" || $util.isString(message.proposalHash)))
                        return "proposalHash: buffer expected";
                if (message.extension != null && message.hasOwnProperty("extension"))
                    if (!(message.extension && typeof message.extension.length === "number" || $util.isString(message.extension)))
                        return "extension: buffer expected";
                return null;
            };
    
            /**
             * Creates a ProposalResponsePayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ProposalResponsePayload} ProposalResponsePayload
             */
            ProposalResponsePayload.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ProposalResponsePayload)
                    return object;
                var message = new $root.protos.ProposalResponsePayload();
                if (object.proposalHash != null)
                    if (typeof object.proposalHash === "string")
                        $util.base64.decode(object.proposalHash, message.proposalHash = $util.newBuffer($util.base64.length(object.proposalHash)), 0);
                    else if (object.proposalHash.length)
                        message.proposalHash = object.proposalHash;
                if (object.extension != null)
                    if (typeof object.extension === "string")
                        $util.base64.decode(object.extension, message.extension = $util.newBuffer($util.base64.length(object.extension)), 0);
                    else if (object.extension.length)
                        message.extension = object.extension;
                return message;
            };
    
            /**
             * Creates a plain object from a ProposalResponsePayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ProposalResponsePayload
             * @static
             * @param {protos.ProposalResponsePayload} message ProposalResponsePayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProposalResponsePayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.proposalHash = "";
                    else {
                        object.proposalHash = [];
                        if (options.bytes !== Array)
                            object.proposalHash = $util.newBuffer(object.proposalHash);
                    }
                    if (options.bytes === String)
                        object.extension = "";
                    else {
                        object.extension = [];
                        if (options.bytes !== Array)
                            object.extension = $util.newBuffer(object.extension);
                    }
                }
                if (message.proposalHash != null && message.hasOwnProperty("proposalHash"))
                    object.proposalHash = options.bytes === String ? $util.base64.encode(message.proposalHash, 0, message.proposalHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposalHash) : message.proposalHash;
                if (message.extension != null && message.hasOwnProperty("extension"))
                    object.extension = options.bytes === String ? $util.base64.encode(message.extension, 0, message.extension.length) : options.bytes === Array ? Array.prototype.slice.call(message.extension) : message.extension;
                return object;
            };
    
            /**
             * Converts this ProposalResponsePayload to JSON.
             * @function toJSON
             * @memberof protos.ProposalResponsePayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProposalResponsePayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ProposalResponsePayload;
        })();
    
        protos.Endorsement = (function() {
    
            /**
             * Properties of an Endorsement.
             * @memberof protos
             * @interface IEndorsement
             * @property {Uint8Array|null} [endorser] Endorsement endorser
             * @property {Uint8Array|null} [signature] Endorsement signature
             */
    
            /**
             * Constructs a new Endorsement.
             * @memberof protos
             * @classdesc Represents an Endorsement.
             * @implements IEndorsement
             * @constructor
             * @param {protos.IEndorsement=} [properties] Properties to set
             */
            function Endorsement(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Endorsement endorser.
             * @member {Uint8Array} endorser
             * @memberof protos.Endorsement
             * @instance
             */
            Endorsement.prototype.endorser = $util.newBuffer([]);
    
            /**
             * Endorsement signature.
             * @member {Uint8Array} signature
             * @memberof protos.Endorsement
             * @instance
             */
            Endorsement.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new Endorsement instance using the specified properties.
             * @function create
             * @memberof protos.Endorsement
             * @static
             * @param {protos.IEndorsement=} [properties] Properties to set
             * @returns {protos.Endorsement} Endorsement instance
             */
            Endorsement.create = function create(properties) {
                return new Endorsement(properties);
            };
    
            /**
             * Encodes the specified Endorsement message. Does not implicitly {@link protos.Endorsement.verify|verify} messages.
             * @function encode
             * @memberof protos.Endorsement
             * @static
             * @param {protos.IEndorsement} message Endorsement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Endorsement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endorser != null && message.hasOwnProperty("endorser"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.endorser);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified Endorsement message, length delimited. Does not implicitly {@link protos.Endorsement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.Endorsement
             * @static
             * @param {protos.IEndorsement} message Endorsement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Endorsement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Endorsement message from the specified reader or buffer.
             * @function decode
             * @memberof protos.Endorsement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.Endorsement} Endorsement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Endorsement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.Endorsement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.endorser = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Endorsement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.Endorsement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.Endorsement} Endorsement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Endorsement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Endorsement message.
             * @function verify
             * @memberof protos.Endorsement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Endorsement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endorser != null && message.hasOwnProperty("endorser"))
                    if (!(message.endorser && typeof message.endorser.length === "number" || $util.isString(message.endorser)))
                        return "endorser: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates an Endorsement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.Endorsement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.Endorsement} Endorsement
             */
            Endorsement.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.Endorsement)
                    return object;
                var message = new $root.protos.Endorsement();
                if (object.endorser != null)
                    if (typeof object.endorser === "string")
                        $util.base64.decode(object.endorser, message.endorser = $util.newBuffer($util.base64.length(object.endorser)), 0);
                    else if (object.endorser.length)
                        message.endorser = object.endorser;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from an Endorsement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.Endorsement
             * @static
             * @param {protos.Endorsement} message Endorsement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Endorsement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.endorser = "";
                    else {
                        object.endorser = [];
                        if (options.bytes !== Array)
                            object.endorser = $util.newBuffer(object.endorser);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.endorser != null && message.hasOwnProperty("endorser"))
                    object.endorser = options.bytes === String ? $util.base64.encode(message.endorser, 0, message.endorser.length) : options.bytes === Array ? Array.prototype.slice.call(message.endorser) : message.endorser;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this Endorsement to JSON.
             * @function toJSON
             * @memberof protos.Endorsement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Endorsement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Endorsement;
        })();
    
        protos.SignedProposal = (function() {
    
            /**
             * Properties of a SignedProposal.
             * @memberof protos
             * @interface ISignedProposal
             * @property {Uint8Array|null} [proposalBytes] SignedProposal proposalBytes
             * @property {Uint8Array|null} [signature] SignedProposal signature
             */
    
            /**
             * Constructs a new SignedProposal.
             * @memberof protos
             * @classdesc Represents a SignedProposal.
             * @implements ISignedProposal
             * @constructor
             * @param {protos.ISignedProposal=} [properties] Properties to set
             */
            function SignedProposal(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignedProposal proposalBytes.
             * @member {Uint8Array} proposalBytes
             * @memberof protos.SignedProposal
             * @instance
             */
            SignedProposal.prototype.proposalBytes = $util.newBuffer([]);
    
            /**
             * SignedProposal signature.
             * @member {Uint8Array} signature
             * @memberof protos.SignedProposal
             * @instance
             */
            SignedProposal.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new SignedProposal instance using the specified properties.
             * @function create
             * @memberof protos.SignedProposal
             * @static
             * @param {protos.ISignedProposal=} [properties] Properties to set
             * @returns {protos.SignedProposal} SignedProposal instance
             */
            SignedProposal.create = function create(properties) {
                return new SignedProposal(properties);
            };
    
            /**
             * Encodes the specified SignedProposal message. Does not implicitly {@link protos.SignedProposal.verify|verify} messages.
             * @function encode
             * @memberof protos.SignedProposal
             * @static
             * @param {protos.ISignedProposal} message SignedProposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedProposal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.proposalBytes != null && message.hasOwnProperty("proposalBytes"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.proposalBytes);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified SignedProposal message, length delimited. Does not implicitly {@link protos.SignedProposal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.SignedProposal
             * @static
             * @param {protos.ISignedProposal} message SignedProposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedProposal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignedProposal message from the specified reader or buffer.
             * @function decode
             * @memberof protos.SignedProposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.SignedProposal} SignedProposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedProposal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.SignedProposal();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.proposalBytes = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignedProposal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.SignedProposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.SignedProposal} SignedProposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedProposal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignedProposal message.
             * @function verify
             * @memberof protos.SignedProposal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignedProposal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.proposalBytes != null && message.hasOwnProperty("proposalBytes"))
                    if (!(message.proposalBytes && typeof message.proposalBytes.length === "number" || $util.isString(message.proposalBytes)))
                        return "proposalBytes: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates a SignedProposal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.SignedProposal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.SignedProposal} SignedProposal
             */
            SignedProposal.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.SignedProposal)
                    return object;
                var message = new $root.protos.SignedProposal();
                if (object.proposalBytes != null)
                    if (typeof object.proposalBytes === "string")
                        $util.base64.decode(object.proposalBytes, message.proposalBytes = $util.newBuffer($util.base64.length(object.proposalBytes)), 0);
                    else if (object.proposalBytes.length)
                        message.proposalBytes = object.proposalBytes;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from a SignedProposal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.SignedProposal
             * @static
             * @param {protos.SignedProposal} message SignedProposal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignedProposal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.proposalBytes = "";
                    else {
                        object.proposalBytes = [];
                        if (options.bytes !== Array)
                            object.proposalBytes = $util.newBuffer(object.proposalBytes);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.proposalBytes != null && message.hasOwnProperty("proposalBytes"))
                    object.proposalBytes = options.bytes === String ? $util.base64.encode(message.proposalBytes, 0, message.proposalBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposalBytes) : message.proposalBytes;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this SignedProposal to JSON.
             * @function toJSON
             * @memberof protos.SignedProposal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignedProposal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignedProposal;
        })();
    
        protos.Proposal = (function() {
    
            /**
             * Properties of a Proposal.
             * @memberof protos
             * @interface IProposal
             * @property {Uint8Array|null} [header] Proposal header
             * @property {Uint8Array|null} [payload] Proposal payload
             * @property {Uint8Array|null} [extension] Proposal extension
             */
    
            /**
             * Constructs a new Proposal.
             * @memberof protos
             * @classdesc Represents a Proposal.
             * @implements IProposal
             * @constructor
             * @param {protos.IProposal=} [properties] Properties to set
             */
            function Proposal(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Proposal header.
             * @member {Uint8Array} header
             * @memberof protos.Proposal
             * @instance
             */
            Proposal.prototype.header = $util.newBuffer([]);
    
            /**
             * Proposal payload.
             * @member {Uint8Array} payload
             * @memberof protos.Proposal
             * @instance
             */
            Proposal.prototype.payload = $util.newBuffer([]);
    
            /**
             * Proposal extension.
             * @member {Uint8Array} extension
             * @memberof protos.Proposal
             * @instance
             */
            Proposal.prototype.extension = $util.newBuffer([]);
    
            /**
             * Creates a new Proposal instance using the specified properties.
             * @function create
             * @memberof protos.Proposal
             * @static
             * @param {protos.IProposal=} [properties] Properties to set
             * @returns {protos.Proposal} Proposal instance
             */
            Proposal.create = function create(properties) {
                return new Proposal(properties);
            };
    
            /**
             * Encodes the specified Proposal message. Does not implicitly {@link protos.Proposal.verify|verify} messages.
             * @function encode
             * @memberof protos.Proposal
             * @static
             * @param {protos.IProposal} message Proposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Proposal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.header != null && message.hasOwnProperty("header"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.header);
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                if (message.extension != null && message.hasOwnProperty("extension"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.extension);
                return writer;
            };
    
            /**
             * Encodes the specified Proposal message, length delimited. Does not implicitly {@link protos.Proposal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.Proposal
             * @static
             * @param {protos.IProposal} message Proposal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Proposal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Proposal message from the specified reader or buffer.
             * @function decode
             * @memberof protos.Proposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.Proposal} Proposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Proposal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.Proposal();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.header = reader.bytes();
                        break;
                    case 2:
                        message.payload = reader.bytes();
                        break;
                    case 3:
                        message.extension = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Proposal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.Proposal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.Proposal} Proposal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Proposal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Proposal message.
             * @function verify
             * @memberof protos.Proposal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Proposal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.header != null && message.hasOwnProperty("header"))
                    if (!(message.header && typeof message.header.length === "number" || $util.isString(message.header)))
                        return "header: buffer expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.extension != null && message.hasOwnProperty("extension"))
                    if (!(message.extension && typeof message.extension.length === "number" || $util.isString(message.extension)))
                        return "extension: buffer expected";
                return null;
            };
    
            /**
             * Creates a Proposal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.Proposal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.Proposal} Proposal
             */
            Proposal.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.Proposal)
                    return object;
                var message = new $root.protos.Proposal();
                if (object.header != null)
                    if (typeof object.header === "string")
                        $util.base64.decode(object.header, message.header = $util.newBuffer($util.base64.length(object.header)), 0);
                    else if (object.header.length)
                        message.header = object.header;
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.extension != null)
                    if (typeof object.extension === "string")
                        $util.base64.decode(object.extension, message.extension = $util.newBuffer($util.base64.length(object.extension)), 0);
                    else if (object.extension.length)
                        message.extension = object.extension;
                return message;
            };
    
            /**
             * Creates a plain object from a Proposal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.Proposal
             * @static
             * @param {protos.Proposal} message Proposal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Proposal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.header = "";
                    else {
                        object.header = [];
                        if (options.bytes !== Array)
                            object.header = $util.newBuffer(object.header);
                    }
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object.extension = "";
                    else {
                        object.extension = [];
                        if (options.bytes !== Array)
                            object.extension = $util.newBuffer(object.extension);
                    }
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = options.bytes === String ? $util.base64.encode(message.header, 0, message.header.length) : options.bytes === Array ? Array.prototype.slice.call(message.header) : message.header;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.extension != null && message.hasOwnProperty("extension"))
                    object.extension = options.bytes === String ? $util.base64.encode(message.extension, 0, message.extension.length) : options.bytes === Array ? Array.prototype.slice.call(message.extension) : message.extension;
                return object;
            };
    
            /**
             * Converts this Proposal to JSON.
             * @function toJSON
             * @memberof protos.Proposal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Proposal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Proposal;
        })();
    
        protos.ChaincodeHeaderExtension = (function() {
    
            /**
             * Properties of a ChaincodeHeaderExtension.
             * @memberof protos
             * @interface IChaincodeHeaderExtension
             * @property {protos.IChaincodeID|null} [chaincodeId] ChaincodeHeaderExtension chaincodeId
             */
    
            /**
             * Constructs a new ChaincodeHeaderExtension.
             * @memberof protos
             * @classdesc Represents a ChaincodeHeaderExtension.
             * @implements IChaincodeHeaderExtension
             * @constructor
             * @param {protos.IChaincodeHeaderExtension=} [properties] Properties to set
             */
            function ChaincodeHeaderExtension(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeHeaderExtension chaincodeId.
             * @member {protos.IChaincodeID|null|undefined} chaincodeId
             * @memberof protos.ChaincodeHeaderExtension
             * @instance
             */
            ChaincodeHeaderExtension.prototype.chaincodeId = null;
    
            /**
             * Creates a new ChaincodeHeaderExtension instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {protos.IChaincodeHeaderExtension=} [properties] Properties to set
             * @returns {protos.ChaincodeHeaderExtension} ChaincodeHeaderExtension instance
             */
            ChaincodeHeaderExtension.create = function create(properties) {
                return new ChaincodeHeaderExtension(properties);
            };
    
            /**
             * Encodes the specified ChaincodeHeaderExtension message. Does not implicitly {@link protos.ChaincodeHeaderExtension.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {protos.IChaincodeHeaderExtension} message ChaincodeHeaderExtension message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeHeaderExtension.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodeId != null && message.hasOwnProperty("chaincodeId"))
                    $root.protos.ChaincodeID.encode(message.chaincodeId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeHeaderExtension message, length delimited. Does not implicitly {@link protos.ChaincodeHeaderExtension.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {protos.IChaincodeHeaderExtension} message ChaincodeHeaderExtension message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeHeaderExtension.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeHeaderExtension message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeHeaderExtension} ChaincodeHeaderExtension
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeHeaderExtension.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeHeaderExtension();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.chaincodeId = $root.protos.ChaincodeID.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeHeaderExtension message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeHeaderExtension} ChaincodeHeaderExtension
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeHeaderExtension.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeHeaderExtension message.
             * @function verify
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeHeaderExtension.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodeId != null && message.hasOwnProperty("chaincodeId")) {
                    var error = $root.protos.ChaincodeID.verify(message.chaincodeId);
                    if (error)
                        return "chaincodeId." + error;
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeHeaderExtension message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeHeaderExtension} ChaincodeHeaderExtension
             */
            ChaincodeHeaderExtension.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeHeaderExtension)
                    return object;
                var message = new $root.protos.ChaincodeHeaderExtension();
                if (object.chaincodeId != null) {
                    if (typeof object.chaincodeId !== "object")
                        throw TypeError(".protos.ChaincodeHeaderExtension.chaincodeId: object expected");
                    message.chaincodeId = $root.protos.ChaincodeID.fromObject(object.chaincodeId);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeHeaderExtension message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeHeaderExtension
             * @static
             * @param {protos.ChaincodeHeaderExtension} message ChaincodeHeaderExtension
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeHeaderExtension.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.chaincodeId = null;
                if (message.chaincodeId != null && message.hasOwnProperty("chaincodeId"))
                    object.chaincodeId = $root.protos.ChaincodeID.toObject(message.chaincodeId, options);
                return object;
            };
    
            /**
             * Converts this ChaincodeHeaderExtension to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeHeaderExtension
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeHeaderExtension.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeHeaderExtension;
        })();
    
        protos.ChaincodeProposalPayload = (function() {
    
            /**
             * Properties of a ChaincodeProposalPayload.
             * @memberof protos
             * @interface IChaincodeProposalPayload
             * @property {Uint8Array|null} [input] ChaincodeProposalPayload input
             * @property {Object.<string,Uint8Array>|null} [TransientMap] ChaincodeProposalPayload TransientMap
             */
    
            /**
             * Constructs a new ChaincodeProposalPayload.
             * @memberof protos
             * @classdesc Represents a ChaincodeProposalPayload.
             * @implements IChaincodeProposalPayload
             * @constructor
             * @param {protos.IChaincodeProposalPayload=} [properties] Properties to set
             */
            function ChaincodeProposalPayload(properties) {
                this.TransientMap = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeProposalPayload input.
             * @member {Uint8Array} input
             * @memberof protos.ChaincodeProposalPayload
             * @instance
             */
            ChaincodeProposalPayload.prototype.input = $util.newBuffer([]);
    
            /**
             * ChaincodeProposalPayload TransientMap.
             * @member {Object.<string,Uint8Array>} TransientMap
             * @memberof protos.ChaincodeProposalPayload
             * @instance
             */
            ChaincodeProposalPayload.prototype.TransientMap = $util.emptyObject;
    
            /**
             * Creates a new ChaincodeProposalPayload instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {protos.IChaincodeProposalPayload=} [properties] Properties to set
             * @returns {protos.ChaincodeProposalPayload} ChaincodeProposalPayload instance
             */
            ChaincodeProposalPayload.create = function create(properties) {
                return new ChaincodeProposalPayload(properties);
            };
    
            /**
             * Encodes the specified ChaincodeProposalPayload message. Does not implicitly {@link protos.ChaincodeProposalPayload.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {protos.IChaincodeProposalPayload} message ChaincodeProposalPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeProposalPayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.input != null && message.hasOwnProperty("input"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.input);
                if (message.TransientMap != null && message.hasOwnProperty("TransientMap"))
                    for (var keys = Object.keys(message.TransientMap), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.TransientMap[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeProposalPayload message, length delimited. Does not implicitly {@link protos.ChaincodeProposalPayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {protos.IChaincodeProposalPayload} message ChaincodeProposalPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeProposalPayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeProposalPayload message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeProposalPayload} ChaincodeProposalPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeProposalPayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeProposalPayload(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.input = reader.bytes();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.TransientMap === $util.emptyObject)
                            message.TransientMap = {};
                        key = reader.string();
                        reader.pos++;
                        message.TransientMap[key] = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeProposalPayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeProposalPayload} ChaincodeProposalPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeProposalPayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeProposalPayload message.
             * @function verify
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeProposalPayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.input != null && message.hasOwnProperty("input"))
                    if (!(message.input && typeof message.input.length === "number" || $util.isString(message.input)))
                        return "input: buffer expected";
                if (message.TransientMap != null && message.hasOwnProperty("TransientMap")) {
                    if (!$util.isObject(message.TransientMap))
                        return "TransientMap: object expected";
                    var key = Object.keys(message.TransientMap);
                    for (var i = 0; i < key.length; ++i)
                        if (!(message.TransientMap[key[i]] && typeof message.TransientMap[key[i]].length === "number" || $util.isString(message.TransientMap[key[i]])))
                            return "TransientMap: buffer{k:string} expected";
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeProposalPayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeProposalPayload} ChaincodeProposalPayload
             */
            ChaincodeProposalPayload.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeProposalPayload)
                    return object;
                var message = new $root.protos.ChaincodeProposalPayload();
                if (object.input != null)
                    if (typeof object.input === "string")
                        $util.base64.decode(object.input, message.input = $util.newBuffer($util.base64.length(object.input)), 0);
                    else if (object.input.length)
                        message.input = object.input;
                if (object.TransientMap) {
                    if (typeof object.TransientMap !== "object")
                        throw TypeError(".protos.ChaincodeProposalPayload.TransientMap: object expected");
                    message.TransientMap = {};
                    for (var keys = Object.keys(object.TransientMap), i = 0; i < keys.length; ++i)
                        if (typeof object.TransientMap[keys[i]] === "string")
                            $util.base64.decode(object.TransientMap[keys[i]], message.TransientMap[keys[i]] = $util.newBuffer($util.base64.length(object.TransientMap[keys[i]])), 0);
                        else if (object.TransientMap[keys[i]].length)
                            message.TransientMap[keys[i]] = object.TransientMap[keys[i]];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeProposalPayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeProposalPayload
             * @static
             * @param {protos.ChaincodeProposalPayload} message ChaincodeProposalPayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeProposalPayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.TransientMap = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.input = "";
                    else {
                        object.input = [];
                        if (options.bytes !== Array)
                            object.input = $util.newBuffer(object.input);
                    }
                if (message.input != null && message.hasOwnProperty("input"))
                    object.input = options.bytes === String ? $util.base64.encode(message.input, 0, message.input.length) : options.bytes === Array ? Array.prototype.slice.call(message.input) : message.input;
                var keys2;
                if (message.TransientMap && (keys2 = Object.keys(message.TransientMap)).length) {
                    object.TransientMap = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.TransientMap[keys2[j]] = options.bytes === String ? $util.base64.encode(message.TransientMap[keys2[j]], 0, message.TransientMap[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.TransientMap[keys2[j]]) : message.TransientMap[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeProposalPayload to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeProposalPayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeProposalPayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeProposalPayload;
        })();
    
        protos.ChaincodeAction = (function() {
    
            /**
             * Properties of a ChaincodeAction.
             * @memberof protos
             * @interface IChaincodeAction
             * @property {Uint8Array|null} [results] ChaincodeAction results
             * @property {Uint8Array|null} [events] ChaincodeAction events
             * @property {protos.IResponse|null} [response] ChaincodeAction response
             * @property {protos.IChaincodeID|null} [chaincodeId] ChaincodeAction chaincodeId
             */
    
            /**
             * Constructs a new ChaincodeAction.
             * @memberof protos
             * @classdesc Represents a ChaincodeAction.
             * @implements IChaincodeAction
             * @constructor
             * @param {protos.IChaincodeAction=} [properties] Properties to set
             */
            function ChaincodeAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeAction results.
             * @member {Uint8Array} results
             * @memberof protos.ChaincodeAction
             * @instance
             */
            ChaincodeAction.prototype.results = $util.newBuffer([]);
    
            /**
             * ChaincodeAction events.
             * @member {Uint8Array} events
             * @memberof protos.ChaincodeAction
             * @instance
             */
            ChaincodeAction.prototype.events = $util.newBuffer([]);
    
            /**
             * ChaincodeAction response.
             * @member {protos.IResponse|null|undefined} response
             * @memberof protos.ChaincodeAction
             * @instance
             */
            ChaincodeAction.prototype.response = null;
    
            /**
             * ChaincodeAction chaincodeId.
             * @member {protos.IChaincodeID|null|undefined} chaincodeId
             * @memberof protos.ChaincodeAction
             * @instance
             */
            ChaincodeAction.prototype.chaincodeId = null;
    
            /**
             * Creates a new ChaincodeAction instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeAction
             * @static
             * @param {protos.IChaincodeAction=} [properties] Properties to set
             * @returns {protos.ChaincodeAction} ChaincodeAction instance
             */
            ChaincodeAction.create = function create(properties) {
                return new ChaincodeAction(properties);
            };
    
            /**
             * Encodes the specified ChaincodeAction message. Does not implicitly {@link protos.ChaincodeAction.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeAction
             * @static
             * @param {protos.IChaincodeAction} message ChaincodeAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.results != null && message.hasOwnProperty("results"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.results);
                if (message.events != null && message.hasOwnProperty("events"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.events);
                if (message.response != null && message.hasOwnProperty("response"))
                    $root.protos.Response.encode(message.response, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.chaincodeId != null && message.hasOwnProperty("chaincodeId"))
                    $root.protos.ChaincodeID.encode(message.chaincodeId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeAction message, length delimited. Does not implicitly {@link protos.ChaincodeAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeAction
             * @static
             * @param {protos.IChaincodeAction} message ChaincodeAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeAction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeAction} ChaincodeAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.results = reader.bytes();
                        break;
                    case 2:
                        message.events = reader.bytes();
                        break;
                    case 3:
                        message.response = $root.protos.Response.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.chaincodeId = $root.protos.ChaincodeID.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeAction} ChaincodeAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeAction message.
             * @function verify
             * @memberof protos.ChaincodeAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.results != null && message.hasOwnProperty("results"))
                    if (!(message.results && typeof message.results.length === "number" || $util.isString(message.results)))
                        return "results: buffer expected";
                if (message.events != null && message.hasOwnProperty("events"))
                    if (!(message.events && typeof message.events.length === "number" || $util.isString(message.events)))
                        return "events: buffer expected";
                if (message.response != null && message.hasOwnProperty("response")) {
                    var error = $root.protos.Response.verify(message.response);
                    if (error)
                        return "response." + error;
                }
                if (message.chaincodeId != null && message.hasOwnProperty("chaincodeId")) {
                    var error = $root.protos.ChaincodeID.verify(message.chaincodeId);
                    if (error)
                        return "chaincodeId." + error;
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeAction} ChaincodeAction
             */
            ChaincodeAction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeAction)
                    return object;
                var message = new $root.protos.ChaincodeAction();
                if (object.results != null)
                    if (typeof object.results === "string")
                        $util.base64.decode(object.results, message.results = $util.newBuffer($util.base64.length(object.results)), 0);
                    else if (object.results.length)
                        message.results = object.results;
                if (object.events != null)
                    if (typeof object.events === "string")
                        $util.base64.decode(object.events, message.events = $util.newBuffer($util.base64.length(object.events)), 0);
                    else if (object.events.length)
                        message.events = object.events;
                if (object.response != null) {
                    if (typeof object.response !== "object")
                        throw TypeError(".protos.ChaincodeAction.response: object expected");
                    message.response = $root.protos.Response.fromObject(object.response);
                }
                if (object.chaincodeId != null) {
                    if (typeof object.chaincodeId !== "object")
                        throw TypeError(".protos.ChaincodeAction.chaincodeId: object expected");
                    message.chaincodeId = $root.protos.ChaincodeID.fromObject(object.chaincodeId);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeAction
             * @static
             * @param {protos.ChaincodeAction} message ChaincodeAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.results = "";
                    else {
                        object.results = [];
                        if (options.bytes !== Array)
                            object.results = $util.newBuffer(object.results);
                    }
                    if (options.bytes === String)
                        object.events = "";
                    else {
                        object.events = [];
                        if (options.bytes !== Array)
                            object.events = $util.newBuffer(object.events);
                    }
                    object.response = null;
                    object.chaincodeId = null;
                }
                if (message.results != null && message.hasOwnProperty("results"))
                    object.results = options.bytes === String ? $util.base64.encode(message.results, 0, message.results.length) : options.bytes === Array ? Array.prototype.slice.call(message.results) : message.results;
                if (message.events != null && message.hasOwnProperty("events"))
                    object.events = options.bytes === String ? $util.base64.encode(message.events, 0, message.events.length) : options.bytes === Array ? Array.prototype.slice.call(message.events) : message.events;
                if (message.response != null && message.hasOwnProperty("response"))
                    object.response = $root.protos.Response.toObject(message.response, options);
                if (message.chaincodeId != null && message.hasOwnProperty("chaincodeId"))
                    object.chaincodeId = $root.protos.ChaincodeID.toObject(message.chaincodeId, options);
                return object;
            };
    
            /**
             * Converts this ChaincodeAction to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeAction;
        })();
    
        protos.ChaincodeID = (function() {
    
            /**
             * Properties of a ChaincodeID.
             * @memberof protos
             * @interface IChaincodeID
             * @property {string|null} [path] ChaincodeID path
             * @property {string|null} [name] ChaincodeID name
             * @property {string|null} [version] ChaincodeID version
             */
    
            /**
             * Constructs a new ChaincodeID.
             * @memberof protos
             * @classdesc Represents a ChaincodeID.
             * @implements IChaincodeID
             * @constructor
             * @param {protos.IChaincodeID=} [properties] Properties to set
             */
            function ChaincodeID(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeID path.
             * @member {string} path
             * @memberof protos.ChaincodeID
             * @instance
             */
            ChaincodeID.prototype.path = "";
    
            /**
             * ChaincodeID name.
             * @member {string} name
             * @memberof protos.ChaincodeID
             * @instance
             */
            ChaincodeID.prototype.name = "";
    
            /**
             * ChaincodeID version.
             * @member {string} version
             * @memberof protos.ChaincodeID
             * @instance
             */
            ChaincodeID.prototype.version = "";
    
            /**
             * Creates a new ChaincodeID instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeID
             * @static
             * @param {protos.IChaincodeID=} [properties] Properties to set
             * @returns {protos.ChaincodeID} ChaincodeID instance
             */
            ChaincodeID.create = function create(properties) {
                return new ChaincodeID(properties);
            };
    
            /**
             * Encodes the specified ChaincodeID message. Does not implicitly {@link protos.ChaincodeID.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeID
             * @static
             * @param {protos.IChaincodeID} message ChaincodeID message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeID.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeID message, length delimited. Does not implicitly {@link protos.ChaincodeID.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeID
             * @static
             * @param {protos.IChaincodeID} message ChaincodeID message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeID.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeID message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeID
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeID} ChaincodeID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeID.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeID();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.version = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeID message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeID
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeID} ChaincodeID
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeID.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeID message.
             * @function verify
             * @memberof protos.ChaincodeID
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeID.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeID message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeID
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeID} ChaincodeID
             */
            ChaincodeID.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeID)
                    return object;
                var message = new $root.protos.ChaincodeID();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeID message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeID
             * @static
             * @param {protos.ChaincodeID} message ChaincodeID
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeID.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.name = "";
                    object.version = "";
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                return object;
            };
    
            /**
             * Converts this ChaincodeID to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeID
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeID.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeID;
        })();
    
        protos.ChaincodeInput = (function() {
    
            /**
             * Properties of a ChaincodeInput.
             * @memberof protos
             * @interface IChaincodeInput
             * @property {Array.<Uint8Array>|null} [args] ChaincodeInput args
             * @property {Object.<string,Uint8Array>|null} [decorations] ChaincodeInput decorations
             * @property {boolean|null} [isInit] ChaincodeInput isInit
             */
    
            /**
             * Constructs a new ChaincodeInput.
             * @memberof protos
             * @classdesc Represents a ChaincodeInput.
             * @implements IChaincodeInput
             * @constructor
             * @param {protos.IChaincodeInput=} [properties] Properties to set
             */
            function ChaincodeInput(properties) {
                this.args = [];
                this.decorations = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeInput args.
             * @member {Array.<Uint8Array>} args
             * @memberof protos.ChaincodeInput
             * @instance
             */
            ChaincodeInput.prototype.args = $util.emptyArray;
    
            /**
             * ChaincodeInput decorations.
             * @member {Object.<string,Uint8Array>} decorations
             * @memberof protos.ChaincodeInput
             * @instance
             */
            ChaincodeInput.prototype.decorations = $util.emptyObject;
    
            /**
             * ChaincodeInput isInit.
             * @member {boolean} isInit
             * @memberof protos.ChaincodeInput
             * @instance
             */
            ChaincodeInput.prototype.isInit = false;
    
            /**
             * Creates a new ChaincodeInput instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeInput
             * @static
             * @param {protos.IChaincodeInput=} [properties] Properties to set
             * @returns {protos.ChaincodeInput} ChaincodeInput instance
             */
            ChaincodeInput.create = function create(properties) {
                return new ChaincodeInput(properties);
            };
    
            /**
             * Encodes the specified ChaincodeInput message. Does not implicitly {@link protos.ChaincodeInput.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeInput
             * @static
             * @param {protos.IChaincodeInput} message ChaincodeInput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInput.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.args != null && message.args.length)
                    for (var i = 0; i < message.args.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.args[i]);
                if (message.decorations != null && message.hasOwnProperty("decorations"))
                    for (var keys = Object.keys(message.decorations), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.decorations[keys[i]]).ldelim();
                if (message.isInit != null && message.hasOwnProperty("isInit"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isInit);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeInput message, length delimited. Does not implicitly {@link protos.ChaincodeInput.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeInput
             * @static
             * @param {protos.IChaincodeInput} message ChaincodeInput message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInput.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeInput message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeInput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeInput} ChaincodeInput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInput.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeInput(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.args && message.args.length))
                            message.args = [];
                        message.args.push(reader.bytes());
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.decorations === $util.emptyObject)
                            message.decorations = {};
                        key = reader.string();
                        reader.pos++;
                        message.decorations[key] = reader.bytes();
                        break;
                    case 3:
                        message.isInit = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeInput message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeInput
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeInput} ChaincodeInput
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInput.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeInput message.
             * @function verify
             * @memberof protos.ChaincodeInput
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeInput.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.args != null && message.hasOwnProperty("args")) {
                    if (!Array.isArray(message.args))
                        return "args: array expected";
                    for (var i = 0; i < message.args.length; ++i)
                        if (!(message.args[i] && typeof message.args[i].length === "number" || $util.isString(message.args[i])))
                            return "args: buffer[] expected";
                }
                if (message.decorations != null && message.hasOwnProperty("decorations")) {
                    if (!$util.isObject(message.decorations))
                        return "decorations: object expected";
                    var key = Object.keys(message.decorations);
                    for (var i = 0; i < key.length; ++i)
                        if (!(message.decorations[key[i]] && typeof message.decorations[key[i]].length === "number" || $util.isString(message.decorations[key[i]])))
                            return "decorations: buffer{k:string} expected";
                }
                if (message.isInit != null && message.hasOwnProperty("isInit"))
                    if (typeof message.isInit !== "boolean")
                        return "isInit: boolean expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeInput message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeInput
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeInput} ChaincodeInput
             */
            ChaincodeInput.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeInput)
                    return object;
                var message = new $root.protos.ChaincodeInput();
                if (object.args) {
                    if (!Array.isArray(object.args))
                        throw TypeError(".protos.ChaincodeInput.args: array expected");
                    message.args = [];
                    for (var i = 0; i < object.args.length; ++i)
                        if (typeof object.args[i] === "string")
                            $util.base64.decode(object.args[i], message.args[i] = $util.newBuffer($util.base64.length(object.args[i])), 0);
                        else if (object.args[i].length)
                            message.args[i] = object.args[i];
                }
                if (object.decorations) {
                    if (typeof object.decorations !== "object")
                        throw TypeError(".protos.ChaincodeInput.decorations: object expected");
                    message.decorations = {};
                    for (var keys = Object.keys(object.decorations), i = 0; i < keys.length; ++i)
                        if (typeof object.decorations[keys[i]] === "string")
                            $util.base64.decode(object.decorations[keys[i]], message.decorations[keys[i]] = $util.newBuffer($util.base64.length(object.decorations[keys[i]])), 0);
                        else if (object.decorations[keys[i]].length)
                            message.decorations[keys[i]] = object.decorations[keys[i]];
                }
                if (object.isInit != null)
                    message.isInit = Boolean(object.isInit);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeInput message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeInput
             * @static
             * @param {protos.ChaincodeInput} message ChaincodeInput
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeInput.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.args = [];
                if (options.objects || options.defaults)
                    object.decorations = {};
                if (options.defaults)
                    object.isInit = false;
                if (message.args && message.args.length) {
                    object.args = [];
                    for (var j = 0; j < message.args.length; ++j)
                        object.args[j] = options.bytes === String ? $util.base64.encode(message.args[j], 0, message.args[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.args[j]) : message.args[j];
                }
                var keys2;
                if (message.decorations && (keys2 = Object.keys(message.decorations)).length) {
                    object.decorations = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.decorations[keys2[j]] = options.bytes === String ? $util.base64.encode(message.decorations[keys2[j]], 0, message.decorations[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.decorations[keys2[j]]) : message.decorations[keys2[j]];
                }
                if (message.isInit != null && message.hasOwnProperty("isInit"))
                    object.isInit = message.isInit;
                return object;
            };
    
            /**
             * Converts this ChaincodeInput to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeInput
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeInput.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeInput;
        })();
    
        protos.ChaincodeSpec = (function() {
    
            /**
             * Properties of a ChaincodeSpec.
             * @memberof protos
             * @interface IChaincodeSpec
             * @property {protos.ChaincodeSpec.Type|null} [type] ChaincodeSpec type
             * @property {protos.IChaincodeID|null} [chaincodeId] ChaincodeSpec chaincodeId
             * @property {protos.IChaincodeInput|null} [input] ChaincodeSpec input
             * @property {number|null} [timeout] ChaincodeSpec timeout
             */
    
            /**
             * Constructs a new ChaincodeSpec.
             * @memberof protos
             * @classdesc Represents a ChaincodeSpec.
             * @implements IChaincodeSpec
             * @constructor
             * @param {protos.IChaincodeSpec=} [properties] Properties to set
             */
            function ChaincodeSpec(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeSpec type.
             * @member {protos.ChaincodeSpec.Type} type
             * @memberof protos.ChaincodeSpec
             * @instance
             */
            ChaincodeSpec.prototype.type = 0;
    
            /**
             * ChaincodeSpec chaincodeId.
             * @member {protos.IChaincodeID|null|undefined} chaincodeId
             * @memberof protos.ChaincodeSpec
             * @instance
             */
            ChaincodeSpec.prototype.chaincodeId = null;
    
            /**
             * ChaincodeSpec input.
             * @member {protos.IChaincodeInput|null|undefined} input
             * @memberof protos.ChaincodeSpec
             * @instance
             */
            ChaincodeSpec.prototype.input = null;
    
            /**
             * ChaincodeSpec timeout.
             * @member {number} timeout
             * @memberof protos.ChaincodeSpec
             * @instance
             */
            ChaincodeSpec.prototype.timeout = 0;
    
            /**
             * Creates a new ChaincodeSpec instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {protos.IChaincodeSpec=} [properties] Properties to set
             * @returns {protos.ChaincodeSpec} ChaincodeSpec instance
             */
            ChaincodeSpec.create = function create(properties) {
                return new ChaincodeSpec(properties);
            };
    
            /**
             * Encodes the specified ChaincodeSpec message. Does not implicitly {@link protos.ChaincodeSpec.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {protos.IChaincodeSpec} message ChaincodeSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.chaincodeId != null && message.hasOwnProperty("chaincodeId"))
                    $root.protos.ChaincodeID.encode(message.chaincodeId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.input != null && message.hasOwnProperty("input"))
                    $root.protos.ChaincodeInput.encode(message.input, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.timeout);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeSpec message, length delimited. Does not implicitly {@link protos.ChaincodeSpec.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {protos.IChaincodeSpec} message ChaincodeSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeSpec.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeSpec message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeSpec} ChaincodeSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeSpec();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.chaincodeId = $root.protos.ChaincodeID.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.input = $root.protos.ChaincodeInput.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.timeout = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeSpec message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeSpec} ChaincodeSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeSpec.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeSpec message.
             * @function verify
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.chaincodeId != null && message.hasOwnProperty("chaincodeId")) {
                    var error = $root.protos.ChaincodeID.verify(message.chaincodeId);
                    if (error)
                        return "chaincodeId." + error;
                }
                if (message.input != null && message.hasOwnProperty("input")) {
                    var error = $root.protos.ChaincodeInput.verify(message.input);
                    if (error)
                        return "input." + error;
                }
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    if (!$util.isInteger(message.timeout))
                        return "timeout: integer expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeSpec message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeSpec} ChaincodeSpec
             */
            ChaincodeSpec.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeSpec)
                    return object;
                var message = new $root.protos.ChaincodeSpec();
                switch (object.type) {
                case "UNDEFINED":
                case 0:
                    message.type = 0;
                    break;
                case "GOLANG":
                case 1:
                    message.type = 1;
                    break;
                case "NODE":
                case 2:
                    message.type = 2;
                    break;
                case "CAR":
                case 3:
                    message.type = 3;
                    break;
                case "JAVA":
                case 4:
                    message.type = 4;
                    break;
                }
                if (object.chaincodeId != null) {
                    if (typeof object.chaincodeId !== "object")
                        throw TypeError(".protos.ChaincodeSpec.chaincodeId: object expected");
                    message.chaincodeId = $root.protos.ChaincodeID.fromObject(object.chaincodeId);
                }
                if (object.input != null) {
                    if (typeof object.input !== "object")
                        throw TypeError(".protos.ChaincodeSpec.input: object expected");
                    message.input = $root.protos.ChaincodeInput.fromObject(object.input);
                }
                if (object.timeout != null)
                    message.timeout = object.timeout | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeSpec message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeSpec
             * @static
             * @param {protos.ChaincodeSpec} message ChaincodeSpec
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeSpec.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNDEFINED" : 0;
                    object.chaincodeId = null;
                    object.input = null;
                    object.timeout = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protos.ChaincodeSpec.Type[message.type] : message.type;
                if (message.chaincodeId != null && message.hasOwnProperty("chaincodeId"))
                    object.chaincodeId = $root.protos.ChaincodeID.toObject(message.chaincodeId, options);
                if (message.input != null && message.hasOwnProperty("input"))
                    object.input = $root.protos.ChaincodeInput.toObject(message.input, options);
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    object.timeout = message.timeout;
                return object;
            };
    
            /**
             * Converts this ChaincodeSpec to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeSpec
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeSpec.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Type enum.
             * @name protos.ChaincodeSpec.Type
             * @enum {string}
             * @property {number} UNDEFINED=0 UNDEFINED value
             * @property {number} GOLANG=1 GOLANG value
             * @property {number} NODE=2 NODE value
             * @property {number} CAR=3 CAR value
             * @property {number} JAVA=4 JAVA value
             */
            ChaincodeSpec.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNDEFINED"] = 0;
                values[valuesById[1] = "GOLANG"] = 1;
                values[valuesById[2] = "NODE"] = 2;
                values[valuesById[3] = "CAR"] = 3;
                values[valuesById[4] = "JAVA"] = 4;
                return values;
            })();
    
            return ChaincodeSpec;
        })();
    
        protos.ChaincodeDeploymentSpec = (function() {
    
            /**
             * Properties of a ChaincodeDeploymentSpec.
             * @memberof protos
             * @interface IChaincodeDeploymentSpec
             * @property {protos.IChaincodeSpec|null} [chaincodeSpec] ChaincodeDeploymentSpec chaincodeSpec
             * @property {Uint8Array|null} [codePackage] ChaincodeDeploymentSpec codePackage
             */
    
            /**
             * Constructs a new ChaincodeDeploymentSpec.
             * @memberof protos
             * @classdesc Represents a ChaincodeDeploymentSpec.
             * @implements IChaincodeDeploymentSpec
             * @constructor
             * @param {protos.IChaincodeDeploymentSpec=} [properties] Properties to set
             */
            function ChaincodeDeploymentSpec(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeDeploymentSpec chaincodeSpec.
             * @member {protos.IChaincodeSpec|null|undefined} chaincodeSpec
             * @memberof protos.ChaincodeDeploymentSpec
             * @instance
             */
            ChaincodeDeploymentSpec.prototype.chaincodeSpec = null;
    
            /**
             * ChaincodeDeploymentSpec codePackage.
             * @member {Uint8Array} codePackage
             * @memberof protos.ChaincodeDeploymentSpec
             * @instance
             */
            ChaincodeDeploymentSpec.prototype.codePackage = $util.newBuffer([]);
    
            /**
             * Creates a new ChaincodeDeploymentSpec instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {protos.IChaincodeDeploymentSpec=} [properties] Properties to set
             * @returns {protos.ChaincodeDeploymentSpec} ChaincodeDeploymentSpec instance
             */
            ChaincodeDeploymentSpec.create = function create(properties) {
                return new ChaincodeDeploymentSpec(properties);
            };
    
            /**
             * Encodes the specified ChaincodeDeploymentSpec message. Does not implicitly {@link protos.ChaincodeDeploymentSpec.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {protos.IChaincodeDeploymentSpec} message ChaincodeDeploymentSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeDeploymentSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodeSpec != null && message.hasOwnProperty("chaincodeSpec"))
                    $root.protos.ChaincodeSpec.encode(message.chaincodeSpec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.codePackage != null && message.hasOwnProperty("codePackage"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.codePackage);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeDeploymentSpec message, length delimited. Does not implicitly {@link protos.ChaincodeDeploymentSpec.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {protos.IChaincodeDeploymentSpec} message ChaincodeDeploymentSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeDeploymentSpec.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeDeploymentSpec message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeDeploymentSpec} ChaincodeDeploymentSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeDeploymentSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeDeploymentSpec();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincodeSpec = $root.protos.ChaincodeSpec.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.codePackage = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeDeploymentSpec message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeDeploymentSpec} ChaincodeDeploymentSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeDeploymentSpec.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeDeploymentSpec message.
             * @function verify
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeDeploymentSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodeSpec != null && message.hasOwnProperty("chaincodeSpec")) {
                    var error = $root.protos.ChaincodeSpec.verify(message.chaincodeSpec);
                    if (error)
                        return "chaincodeSpec." + error;
                }
                if (message.codePackage != null && message.hasOwnProperty("codePackage"))
                    if (!(message.codePackage && typeof message.codePackage.length === "number" || $util.isString(message.codePackage)))
                        return "codePackage: buffer expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeDeploymentSpec message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeDeploymentSpec} ChaincodeDeploymentSpec
             */
            ChaincodeDeploymentSpec.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeDeploymentSpec)
                    return object;
                var message = new $root.protos.ChaincodeDeploymentSpec();
                if (object.chaincodeSpec != null) {
                    if (typeof object.chaincodeSpec !== "object")
                        throw TypeError(".protos.ChaincodeDeploymentSpec.chaincodeSpec: object expected");
                    message.chaincodeSpec = $root.protos.ChaincodeSpec.fromObject(object.chaincodeSpec);
                }
                if (object.codePackage != null)
                    if (typeof object.codePackage === "string")
                        $util.base64.decode(object.codePackage, message.codePackage = $util.newBuffer($util.base64.length(object.codePackage)), 0);
                    else if (object.codePackage.length)
                        message.codePackage = object.codePackage;
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeDeploymentSpec message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeDeploymentSpec
             * @static
             * @param {protos.ChaincodeDeploymentSpec} message ChaincodeDeploymentSpec
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeDeploymentSpec.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.chaincodeSpec = null;
                    if (options.bytes === String)
                        object.codePackage = "";
                    else {
                        object.codePackage = [];
                        if (options.bytes !== Array)
                            object.codePackage = $util.newBuffer(object.codePackage);
                    }
                }
                if (message.chaincodeSpec != null && message.hasOwnProperty("chaincodeSpec"))
                    object.chaincodeSpec = $root.protos.ChaincodeSpec.toObject(message.chaincodeSpec, options);
                if (message.codePackage != null && message.hasOwnProperty("codePackage"))
                    object.codePackage = options.bytes === String ? $util.base64.encode(message.codePackage, 0, message.codePackage.length) : options.bytes === Array ? Array.prototype.slice.call(message.codePackage) : message.codePackage;
                return object;
            };
    
            /**
             * Converts this ChaincodeDeploymentSpec to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeDeploymentSpec
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeDeploymentSpec.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeDeploymentSpec;
        })();
    
        protos.ChaincodeInvocationSpec = (function() {
    
            /**
             * Properties of a ChaincodeInvocationSpec.
             * @memberof protos
             * @interface IChaincodeInvocationSpec
             * @property {protos.IChaincodeSpec|null} [chaincodeSpec] ChaincodeInvocationSpec chaincodeSpec
             */
    
            /**
             * Constructs a new ChaincodeInvocationSpec.
             * @memberof protos
             * @classdesc Represents a ChaincodeInvocationSpec.
             * @implements IChaincodeInvocationSpec
             * @constructor
             * @param {protos.IChaincodeInvocationSpec=} [properties] Properties to set
             */
            function ChaincodeInvocationSpec(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeInvocationSpec chaincodeSpec.
             * @member {protos.IChaincodeSpec|null|undefined} chaincodeSpec
             * @memberof protos.ChaincodeInvocationSpec
             * @instance
             */
            ChaincodeInvocationSpec.prototype.chaincodeSpec = null;
    
            /**
             * Creates a new ChaincodeInvocationSpec instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {protos.IChaincodeInvocationSpec=} [properties] Properties to set
             * @returns {protos.ChaincodeInvocationSpec} ChaincodeInvocationSpec instance
             */
            ChaincodeInvocationSpec.create = function create(properties) {
                return new ChaincodeInvocationSpec(properties);
            };
    
            /**
             * Encodes the specified ChaincodeInvocationSpec message. Does not implicitly {@link protos.ChaincodeInvocationSpec.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {protos.IChaincodeInvocationSpec} message ChaincodeInvocationSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInvocationSpec.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodeSpec != null && message.hasOwnProperty("chaincodeSpec"))
                    $root.protos.ChaincodeSpec.encode(message.chaincodeSpec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeInvocationSpec message, length delimited. Does not implicitly {@link protos.ChaincodeInvocationSpec.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {protos.IChaincodeInvocationSpec} message ChaincodeInvocationSpec message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInvocationSpec.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeInvocationSpec message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeInvocationSpec} ChaincodeInvocationSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInvocationSpec.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeInvocationSpec();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincodeSpec = $root.protos.ChaincodeSpec.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeInvocationSpec message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeInvocationSpec} ChaincodeInvocationSpec
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInvocationSpec.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeInvocationSpec message.
             * @function verify
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeInvocationSpec.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodeSpec != null && message.hasOwnProperty("chaincodeSpec")) {
                    var error = $root.protos.ChaincodeSpec.verify(message.chaincodeSpec);
                    if (error)
                        return "chaincodeSpec." + error;
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeInvocationSpec message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeInvocationSpec} ChaincodeInvocationSpec
             */
            ChaincodeInvocationSpec.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeInvocationSpec)
                    return object;
                var message = new $root.protos.ChaincodeInvocationSpec();
                if (object.chaincodeSpec != null) {
                    if (typeof object.chaincodeSpec !== "object")
                        throw TypeError(".protos.ChaincodeInvocationSpec.chaincodeSpec: object expected");
                    message.chaincodeSpec = $root.protos.ChaincodeSpec.fromObject(object.chaincodeSpec);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeInvocationSpec message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeInvocationSpec
             * @static
             * @param {protos.ChaincodeInvocationSpec} message ChaincodeInvocationSpec
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeInvocationSpec.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.chaincodeSpec = null;
                if (message.chaincodeSpec != null && message.hasOwnProperty("chaincodeSpec"))
                    object.chaincodeSpec = $root.protos.ChaincodeSpec.toObject(message.chaincodeSpec, options);
                return object;
            };
    
            /**
             * Converts this ChaincodeInvocationSpec to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeInvocationSpec
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeInvocationSpec.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeInvocationSpec;
        })();
    
        protos.LifecycleEvent = (function() {
    
            /**
             * Properties of a LifecycleEvent.
             * @memberof protos
             * @interface ILifecycleEvent
             * @property {string|null} [chaincodeName] LifecycleEvent chaincodeName
             */
    
            /**
             * Constructs a new LifecycleEvent.
             * @memberof protos
             * @classdesc Represents a LifecycleEvent.
             * @implements ILifecycleEvent
             * @constructor
             * @param {protos.ILifecycleEvent=} [properties] Properties to set
             */
            function LifecycleEvent(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LifecycleEvent chaincodeName.
             * @member {string} chaincodeName
             * @memberof protos.LifecycleEvent
             * @instance
             */
            LifecycleEvent.prototype.chaincodeName = "";
    
            /**
             * Creates a new LifecycleEvent instance using the specified properties.
             * @function create
             * @memberof protos.LifecycleEvent
             * @static
             * @param {protos.ILifecycleEvent=} [properties] Properties to set
             * @returns {protos.LifecycleEvent} LifecycleEvent instance
             */
            LifecycleEvent.create = function create(properties) {
                return new LifecycleEvent(properties);
            };
    
            /**
             * Encodes the specified LifecycleEvent message. Does not implicitly {@link protos.LifecycleEvent.verify|verify} messages.
             * @function encode
             * @memberof protos.LifecycleEvent
             * @static
             * @param {protos.ILifecycleEvent} message LifecycleEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LifecycleEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodeName != null && message.hasOwnProperty("chaincodeName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.chaincodeName);
                return writer;
            };
    
            /**
             * Encodes the specified LifecycleEvent message, length delimited. Does not implicitly {@link protos.LifecycleEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.LifecycleEvent
             * @static
             * @param {protos.ILifecycleEvent} message LifecycleEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LifecycleEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a LifecycleEvent message from the specified reader or buffer.
             * @function decode
             * @memberof protos.LifecycleEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.LifecycleEvent} LifecycleEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LifecycleEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.LifecycleEvent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincodeName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a LifecycleEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.LifecycleEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.LifecycleEvent} LifecycleEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LifecycleEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a LifecycleEvent message.
             * @function verify
             * @memberof protos.LifecycleEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LifecycleEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodeName != null && message.hasOwnProperty("chaincodeName"))
                    if (!$util.isString(message.chaincodeName))
                        return "chaincodeName: string expected";
                return null;
            };
    
            /**
             * Creates a LifecycleEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.LifecycleEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.LifecycleEvent} LifecycleEvent
             */
            LifecycleEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.LifecycleEvent)
                    return object;
                var message = new $root.protos.LifecycleEvent();
                if (object.chaincodeName != null)
                    message.chaincodeName = String(object.chaincodeName);
                return message;
            };
    
            /**
             * Creates a plain object from a LifecycleEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.LifecycleEvent
             * @static
             * @param {protos.LifecycleEvent} message LifecycleEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LifecycleEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.chaincodeName = "";
                if (message.chaincodeName != null && message.hasOwnProperty("chaincodeName"))
                    object.chaincodeName = message.chaincodeName;
                return object;
            };
    
            /**
             * Converts this LifecycleEvent to JSON.
             * @function toJSON
             * @memberof protos.LifecycleEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LifecycleEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return LifecycleEvent;
        })();
    
        protos.CDSData = (function() {
    
            /**
             * Properties of a CDSData.
             * @memberof protos
             * @interface ICDSData
             * @property {Uint8Array|null} [hash] CDSData hash
             * @property {Uint8Array|null} [metadatahash] CDSData metadatahash
             */
    
            /**
             * Constructs a new CDSData.
             * @memberof protos
             * @classdesc Represents a CDSData.
             * @implements ICDSData
             * @constructor
             * @param {protos.ICDSData=} [properties] Properties to set
             */
            function CDSData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CDSData hash.
             * @member {Uint8Array} hash
             * @memberof protos.CDSData
             * @instance
             */
            CDSData.prototype.hash = $util.newBuffer([]);
    
            /**
             * CDSData metadatahash.
             * @member {Uint8Array} metadatahash
             * @memberof protos.CDSData
             * @instance
             */
            CDSData.prototype.metadatahash = $util.newBuffer([]);
    
            /**
             * Creates a new CDSData instance using the specified properties.
             * @function create
             * @memberof protos.CDSData
             * @static
             * @param {protos.ICDSData=} [properties] Properties to set
             * @returns {protos.CDSData} CDSData instance
             */
            CDSData.create = function create(properties) {
                return new CDSData(properties);
            };
    
            /**
             * Encodes the specified CDSData message. Does not implicitly {@link protos.CDSData.verify|verify} messages.
             * @function encode
             * @memberof protos.CDSData
             * @static
             * @param {protos.ICDSData} message CDSData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CDSData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && message.hasOwnProperty("hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                if (message.metadatahash != null && message.hasOwnProperty("metadatahash"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.metadatahash);
                return writer;
            };
    
            /**
             * Encodes the specified CDSData message, length delimited. Does not implicitly {@link protos.CDSData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.CDSData
             * @static
             * @param {protos.ICDSData} message CDSData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CDSData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CDSData message from the specified reader or buffer.
             * @function decode
             * @memberof protos.CDSData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.CDSData} CDSData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CDSData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.CDSData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hash = reader.bytes();
                        break;
                    case 2:
                        message.metadatahash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CDSData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.CDSData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.CDSData} CDSData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CDSData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CDSData message.
             * @function verify
             * @memberof protos.CDSData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CDSData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.metadatahash != null && message.hasOwnProperty("metadatahash"))
                    if (!(message.metadatahash && typeof message.metadatahash.length === "number" || $util.isString(message.metadatahash)))
                        return "metadatahash: buffer expected";
                return null;
            };
    
            /**
             * Creates a CDSData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.CDSData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.CDSData} CDSData
             */
            CDSData.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.CDSData)
                    return object;
                var message = new $root.protos.CDSData();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.metadatahash != null)
                    if (typeof object.metadatahash === "string")
                        $util.base64.decode(object.metadatahash, message.metadatahash = $util.newBuffer($util.base64.length(object.metadatahash)), 0);
                    else if (object.metadatahash.length)
                        message.metadatahash = object.metadatahash;
                return message;
            };
    
            /**
             * Creates a plain object from a CDSData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.CDSData
             * @static
             * @param {protos.CDSData} message CDSData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CDSData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    if (options.bytes === String)
                        object.metadatahash = "";
                    else {
                        object.metadatahash = [];
                        if (options.bytes !== Array)
                            object.metadatahash = $util.newBuffer(object.metadatahash);
                    }
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.metadatahash != null && message.hasOwnProperty("metadatahash"))
                    object.metadatahash = options.bytes === String ? $util.base64.encode(message.metadatahash, 0, message.metadatahash.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadatahash) : message.metadatahash;
                return object;
            };
    
            /**
             * Converts this CDSData to JSON.
             * @function toJSON
             * @memberof protos.CDSData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CDSData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CDSData;
        })();
    
        protos.ChaincodeData = (function() {
    
            /**
             * Properties of a ChaincodeData.
             * @memberof protos
             * @interface IChaincodeData
             * @property {string|null} [name] ChaincodeData name
             * @property {string|null} [version] ChaincodeData version
             * @property {string|null} [escc] ChaincodeData escc
             * @property {string|null} [vscc] ChaincodeData vscc
             * @property {common.ISignaturePolicyEnvelope|null} [policy] ChaincodeData policy
             * @property {Uint8Array|null} [data] ChaincodeData data
             * @property {Uint8Array|null} [id] ChaincodeData id
             * @property {common.ISignaturePolicyEnvelope|null} [instantiationPolicy] ChaincodeData instantiationPolicy
             */
    
            /**
             * Constructs a new ChaincodeData.
             * @memberof protos
             * @classdesc Represents a ChaincodeData.
             * @implements IChaincodeData
             * @constructor
             * @param {protos.IChaincodeData=} [properties] Properties to set
             */
            function ChaincodeData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeData name.
             * @member {string} name
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.name = "";
    
            /**
             * ChaincodeData version.
             * @member {string} version
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.version = "";
    
            /**
             * ChaincodeData escc.
             * @member {string} escc
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.escc = "";
    
            /**
             * ChaincodeData vscc.
             * @member {string} vscc
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.vscc = "";
    
            /**
             * ChaincodeData policy.
             * @member {common.ISignaturePolicyEnvelope|null|undefined} policy
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.policy = null;
    
            /**
             * ChaincodeData data.
             * @member {Uint8Array} data
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.data = $util.newBuffer([]);
    
            /**
             * ChaincodeData id.
             * @member {Uint8Array} id
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.id = $util.newBuffer([]);
    
            /**
             * ChaincodeData instantiationPolicy.
             * @member {common.ISignaturePolicyEnvelope|null|undefined} instantiationPolicy
             * @memberof protos.ChaincodeData
             * @instance
             */
            ChaincodeData.prototype.instantiationPolicy = null;
    
            /**
             * Creates a new ChaincodeData instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeData
             * @static
             * @param {protos.IChaincodeData=} [properties] Properties to set
             * @returns {protos.ChaincodeData} ChaincodeData instance
             */
            ChaincodeData.create = function create(properties) {
                return new ChaincodeData(properties);
            };
    
            /**
             * Encodes the specified ChaincodeData message. Does not implicitly {@link protos.ChaincodeData.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeData
             * @static
             * @param {protos.IChaincodeData} message ChaincodeData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                if (message.escc != null && message.hasOwnProperty("escc"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.escc);
                if (message.vscc != null && message.hasOwnProperty("vscc"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.vscc);
                if (message.policy != null && message.hasOwnProperty("policy"))
                    $root.common.SignaturePolicyEnvelope.encode(message.policy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.data != null && message.hasOwnProperty("data"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.data);
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.id);
                if (message.instantiationPolicy != null && message.hasOwnProperty("instantiationPolicy"))
                    $root.common.SignaturePolicyEnvelope.encode(message.instantiationPolicy, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeData message, length delimited. Does not implicitly {@link protos.ChaincodeData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeData
             * @static
             * @param {protos.IChaincodeData} message ChaincodeData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeData message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeData} ChaincodeData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    case 3:
                        message.escc = reader.string();
                        break;
                    case 4:
                        message.vscc = reader.string();
                        break;
                    case 5:
                        message.policy = $root.common.SignaturePolicyEnvelope.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.data = reader.bytes();
                        break;
                    case 7:
                        message.id = reader.bytes();
                        break;
                    case 8:
                        message.instantiationPolicy = $root.common.SignaturePolicyEnvelope.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeData} ChaincodeData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeData message.
             * @function verify
             * @memberof protos.ChaincodeData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.escc != null && message.hasOwnProperty("escc"))
                    if (!$util.isString(message.escc))
                        return "escc: string expected";
                if (message.vscc != null && message.hasOwnProperty("vscc"))
                    if (!$util.isString(message.vscc))
                        return "vscc: string expected";
                if (message.policy != null && message.hasOwnProperty("policy")) {
                    var error = $root.common.SignaturePolicyEnvelope.verify(message.policy);
                    if (error)
                        return "policy." + error;
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                        return "id: buffer expected";
                if (message.instantiationPolicy != null && message.hasOwnProperty("instantiationPolicy")) {
                    var error = $root.common.SignaturePolicyEnvelope.verify(message.instantiationPolicy);
                    if (error)
                        return "instantiationPolicy." + error;
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeData} ChaincodeData
             */
            ChaincodeData.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeData)
                    return object;
                var message = new $root.protos.ChaincodeData();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.escc != null)
                    message.escc = String(object.escc);
                if (object.vscc != null)
                    message.vscc = String(object.vscc);
                if (object.policy != null) {
                    if (typeof object.policy !== "object")
                        throw TypeError(".protos.ChaincodeData.policy: object expected");
                    message.policy = $root.common.SignaturePolicyEnvelope.fromObject(object.policy);
                }
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                if (object.id != null)
                    if (typeof object.id === "string")
                        $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                    else if (object.id.length)
                        message.id = object.id;
                if (object.instantiationPolicy != null) {
                    if (typeof object.instantiationPolicy !== "object")
                        throw TypeError(".protos.ChaincodeData.instantiationPolicy: object expected");
                    message.instantiationPolicy = $root.common.SignaturePolicyEnvelope.fromObject(object.instantiationPolicy);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeData
             * @static
             * @param {protos.ChaincodeData} message ChaincodeData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.version = "";
                    object.escc = "";
                    object.vscc = "";
                    object.policy = null;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                    if (options.bytes === String)
                        object.id = "";
                    else {
                        object.id = [];
                        if (options.bytes !== Array)
                            object.id = $util.newBuffer(object.id);
                    }
                    object.instantiationPolicy = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.escc != null && message.hasOwnProperty("escc"))
                    object.escc = message.escc;
                if (message.vscc != null && message.hasOwnProperty("vscc"))
                    object.vscc = message.vscc;
                if (message.policy != null && message.hasOwnProperty("policy"))
                    object.policy = $root.common.SignaturePolicyEnvelope.toObject(message.policy, options);
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                if (message.instantiationPolicy != null && message.hasOwnProperty("instantiationPolicy"))
                    object.instantiationPolicy = $root.common.SignaturePolicyEnvelope.toObject(message.instantiationPolicy, options);
                return object;
            };
    
            /**
             * Converts this ChaincodeData to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeData;
        })();
    
        protos.ChaincodeEvent = (function() {
    
            /**
             * Properties of a ChaincodeEvent.
             * @memberof protos
             * @interface IChaincodeEvent
             * @property {string|null} [chaincodeId] ChaincodeEvent chaincodeId
             * @property {string|null} [txId] ChaincodeEvent txId
             * @property {string|null} [eventName] ChaincodeEvent eventName
             * @property {Uint8Array|null} [payload] ChaincodeEvent payload
             */
    
            /**
             * Constructs a new ChaincodeEvent.
             * @memberof protos
             * @classdesc Represents a ChaincodeEvent.
             * @implements IChaincodeEvent
             * @constructor
             * @param {protos.IChaincodeEvent=} [properties] Properties to set
             */
            function ChaincodeEvent(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeEvent chaincodeId.
             * @member {string} chaincodeId
             * @memberof protos.ChaincodeEvent
             * @instance
             */
            ChaincodeEvent.prototype.chaincodeId = "";
    
            /**
             * ChaincodeEvent txId.
             * @member {string} txId
             * @memberof protos.ChaincodeEvent
             * @instance
             */
            ChaincodeEvent.prototype.txId = "";
    
            /**
             * ChaincodeEvent eventName.
             * @member {string} eventName
             * @memberof protos.ChaincodeEvent
             * @instance
             */
            ChaincodeEvent.prototype.eventName = "";
    
            /**
             * ChaincodeEvent payload.
             * @member {Uint8Array} payload
             * @memberof protos.ChaincodeEvent
             * @instance
             */
            ChaincodeEvent.prototype.payload = $util.newBuffer([]);
    
            /**
             * Creates a new ChaincodeEvent instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {protos.IChaincodeEvent=} [properties] Properties to set
             * @returns {protos.ChaincodeEvent} ChaincodeEvent instance
             */
            ChaincodeEvent.create = function create(properties) {
                return new ChaincodeEvent(properties);
            };
    
            /**
             * Encodes the specified ChaincodeEvent message. Does not implicitly {@link protos.ChaincodeEvent.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {protos.IChaincodeEvent} message ChaincodeEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodeId != null && message.hasOwnProperty("chaincodeId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.chaincodeId);
                if (message.txId != null && message.hasOwnProperty("txId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.txId);
                if (message.eventName != null && message.hasOwnProperty("eventName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.eventName);
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payload);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeEvent message, length delimited. Does not implicitly {@link protos.ChaincodeEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {protos.IChaincodeEvent} message ChaincodeEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeEvent message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeEvent} ChaincodeEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeEvent();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincodeId = reader.string();
                        break;
                    case 2:
                        message.txId = reader.string();
                        break;
                    case 3:
                        message.eventName = reader.string();
                        break;
                    case 4:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeEvent} ChaincodeEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeEvent message.
             * @function verify
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodeId != null && message.hasOwnProperty("chaincodeId"))
                    if (!$util.isString(message.chaincodeId))
                        return "chaincodeId: string expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isString(message.txId))
                        return "txId: string expected";
                if (message.eventName != null && message.hasOwnProperty("eventName"))
                    if (!$util.isString(message.eventName))
                        return "eventName: string expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeEvent} ChaincodeEvent
             */
            ChaincodeEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeEvent)
                    return object;
                var message = new $root.protos.ChaincodeEvent();
                if (object.chaincodeId != null)
                    message.chaincodeId = String(object.chaincodeId);
                if (object.txId != null)
                    message.txId = String(object.txId);
                if (object.eventName != null)
                    message.eventName = String(object.eventName);
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeEvent
             * @static
             * @param {protos.ChaincodeEvent} message ChaincodeEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.chaincodeId = "";
                    object.txId = "";
                    object.eventName = "";
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                }
                if (message.chaincodeId != null && message.hasOwnProperty("chaincodeId"))
                    object.chaincodeId = message.chaincodeId;
                if (message.txId != null && message.hasOwnProperty("txId"))
                    object.txId = message.txId;
                if (message.eventName != null && message.hasOwnProperty("eventName"))
                    object.eventName = message.eventName;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };
    
            /**
             * Converts this ChaincodeEvent to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeEvent;
        })();
    
        protos.ChaincodeQueryResponse = (function() {
    
            /**
             * Properties of a ChaincodeQueryResponse.
             * @memberof protos
             * @interface IChaincodeQueryResponse
             * @property {Array.<protos.IChaincodeInfo>|null} [chaincodes] ChaincodeQueryResponse chaincodes
             */
    
            /**
             * Constructs a new ChaincodeQueryResponse.
             * @memberof protos
             * @classdesc Represents a ChaincodeQueryResponse.
             * @implements IChaincodeQueryResponse
             * @constructor
             * @param {protos.IChaincodeQueryResponse=} [properties] Properties to set
             */
            function ChaincodeQueryResponse(properties) {
                this.chaincodes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeQueryResponse chaincodes.
             * @member {Array.<protos.IChaincodeInfo>} chaincodes
             * @memberof protos.ChaincodeQueryResponse
             * @instance
             */
            ChaincodeQueryResponse.prototype.chaincodes = $util.emptyArray;
    
            /**
             * Creates a new ChaincodeQueryResponse instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {protos.IChaincodeQueryResponse=} [properties] Properties to set
             * @returns {protos.ChaincodeQueryResponse} ChaincodeQueryResponse instance
             */
            ChaincodeQueryResponse.create = function create(properties) {
                return new ChaincodeQueryResponse(properties);
            };
    
            /**
             * Encodes the specified ChaincodeQueryResponse message. Does not implicitly {@link protos.ChaincodeQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {protos.IChaincodeQueryResponse} message ChaincodeQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodes != null && message.chaincodes.length)
                    for (var i = 0; i < message.chaincodes.length; ++i)
                        $root.protos.ChaincodeInfo.encode(message.chaincodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeQueryResponse message, length delimited. Does not implicitly {@link protos.ChaincodeQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {protos.IChaincodeQueryResponse} message ChaincodeQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeQueryResponse} ChaincodeQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.chaincodes && message.chaincodes.length))
                            message.chaincodes = [];
                        message.chaincodes.push($root.protos.ChaincodeInfo.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeQueryResponse} ChaincodeQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeQueryResponse message.
             * @function verify
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodes != null && message.hasOwnProperty("chaincodes")) {
                    if (!Array.isArray(message.chaincodes))
                        return "chaincodes: array expected";
                    for (var i = 0; i < message.chaincodes.length; ++i) {
                        var error = $root.protos.ChaincodeInfo.verify(message.chaincodes[i]);
                        if (error)
                            return "chaincodes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeQueryResponse} ChaincodeQueryResponse
             */
            ChaincodeQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeQueryResponse)
                    return object;
                var message = new $root.protos.ChaincodeQueryResponse();
                if (object.chaincodes) {
                    if (!Array.isArray(object.chaincodes))
                        throw TypeError(".protos.ChaincodeQueryResponse.chaincodes: array expected");
                    message.chaincodes = [];
                    for (var i = 0; i < object.chaincodes.length; ++i) {
                        if (typeof object.chaincodes[i] !== "object")
                            throw TypeError(".protos.ChaincodeQueryResponse.chaincodes: object expected");
                        message.chaincodes[i] = $root.protos.ChaincodeInfo.fromObject(object.chaincodes[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeQueryResponse
             * @static
             * @param {protos.ChaincodeQueryResponse} message ChaincodeQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.chaincodes = [];
                if (message.chaincodes && message.chaincodes.length) {
                    object.chaincodes = [];
                    for (var j = 0; j < message.chaincodes.length; ++j)
                        object.chaincodes[j] = $root.protos.ChaincodeInfo.toObject(message.chaincodes[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeQueryResponse to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeQueryResponse;
        })();
    
        protos.ChaincodeInfo = (function() {
    
            /**
             * Properties of a ChaincodeInfo.
             * @memberof protos
             * @interface IChaincodeInfo
             * @property {string|null} [name] ChaincodeInfo name
             * @property {string|null} [version] ChaincodeInfo version
             * @property {string|null} [path] ChaincodeInfo path
             * @property {string|null} [input] ChaincodeInfo input
             * @property {string|null} [escc] ChaincodeInfo escc
             * @property {string|null} [vscc] ChaincodeInfo vscc
             * @property {Uint8Array|null} [id] ChaincodeInfo id
             */
    
            /**
             * Constructs a new ChaincodeInfo.
             * @memberof protos
             * @classdesc Represents a ChaincodeInfo.
             * @implements IChaincodeInfo
             * @constructor
             * @param {protos.IChaincodeInfo=} [properties] Properties to set
             */
            function ChaincodeInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeInfo name.
             * @member {string} name
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.name = "";
    
            /**
             * ChaincodeInfo version.
             * @member {string} version
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.version = "";
    
            /**
             * ChaincodeInfo path.
             * @member {string} path
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.path = "";
    
            /**
             * ChaincodeInfo input.
             * @member {string} input
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.input = "";
    
            /**
             * ChaincodeInfo escc.
             * @member {string} escc
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.escc = "";
    
            /**
             * ChaincodeInfo vscc.
             * @member {string} vscc
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.vscc = "";
    
            /**
             * ChaincodeInfo id.
             * @member {Uint8Array} id
             * @memberof protos.ChaincodeInfo
             * @instance
             */
            ChaincodeInfo.prototype.id = $util.newBuffer([]);
    
            /**
             * Creates a new ChaincodeInfo instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {protos.IChaincodeInfo=} [properties] Properties to set
             * @returns {protos.ChaincodeInfo} ChaincodeInfo instance
             */
            ChaincodeInfo.create = function create(properties) {
                return new ChaincodeInfo(properties);
            };
    
            /**
             * Encodes the specified ChaincodeInfo message. Does not implicitly {@link protos.ChaincodeInfo.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {protos.IChaincodeInfo} message ChaincodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.path);
                if (message.input != null && message.hasOwnProperty("input"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.input);
                if (message.escc != null && message.hasOwnProperty("escc"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.escc);
                if (message.vscc != null && message.hasOwnProperty("vscc"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.vscc);
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.id);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeInfo message, length delimited. Does not implicitly {@link protos.ChaincodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {protos.IChaincodeInfo} message ChaincodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeInfo} ChaincodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    case 3:
                        message.path = reader.string();
                        break;
                    case 4:
                        message.input = reader.string();
                        break;
                    case 5:
                        message.escc = reader.string();
                        break;
                    case 6:
                        message.vscc = reader.string();
                        break;
                    case 7:
                        message.id = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeInfo} ChaincodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeInfo message.
             * @function verify
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.input != null && message.hasOwnProperty("input"))
                    if (!$util.isString(message.input))
                        return "input: string expected";
                if (message.escc != null && message.hasOwnProperty("escc"))
                    if (!$util.isString(message.escc))
                        return "escc: string expected";
                if (message.vscc != null && message.hasOwnProperty("vscc"))
                    if (!$util.isString(message.vscc))
                        return "vscc: string expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                        return "id: buffer expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeInfo} ChaincodeInfo
             */
            ChaincodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeInfo)
                    return object;
                var message = new $root.protos.ChaincodeInfo();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.path != null)
                    message.path = String(object.path);
                if (object.input != null)
                    message.input = String(object.input);
                if (object.escc != null)
                    message.escc = String(object.escc);
                if (object.vscc != null)
                    message.vscc = String(object.vscc);
                if (object.id != null)
                    if (typeof object.id === "string")
                        $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                    else if (object.id.length)
                        message.id = object.id;
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeInfo
             * @static
             * @param {protos.ChaincodeInfo} message ChaincodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.version = "";
                    object.path = "";
                    object.input = "";
                    object.escc = "";
                    object.vscc = "";
                    if (options.bytes === String)
                        object.id = "";
                    else {
                        object.id = [];
                        if (options.bytes !== Array)
                            object.id = $util.newBuffer(object.id);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.input != null && message.hasOwnProperty("input"))
                    object.input = message.input;
                if (message.escc != null && message.hasOwnProperty("escc"))
                    object.escc = message.escc;
                if (message.vscc != null && message.hasOwnProperty("vscc"))
                    object.vscc = message.vscc;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                return object;
            };
    
            /**
             * Converts this ChaincodeInfo to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeInfo;
        })();
    
        protos.ChannelQueryResponse = (function() {
    
            /**
             * Properties of a ChannelQueryResponse.
             * @memberof protos
             * @interface IChannelQueryResponse
             * @property {Array.<protos.IChannelInfo>|null} [channels] ChannelQueryResponse channels
             */
    
            /**
             * Constructs a new ChannelQueryResponse.
             * @memberof protos
             * @classdesc Represents a ChannelQueryResponse.
             * @implements IChannelQueryResponse
             * @constructor
             * @param {protos.IChannelQueryResponse=} [properties] Properties to set
             */
            function ChannelQueryResponse(properties) {
                this.channels = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChannelQueryResponse channels.
             * @member {Array.<protos.IChannelInfo>} channels
             * @memberof protos.ChannelQueryResponse
             * @instance
             */
            ChannelQueryResponse.prototype.channels = $util.emptyArray;
    
            /**
             * Creates a new ChannelQueryResponse instance using the specified properties.
             * @function create
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {protos.IChannelQueryResponse=} [properties] Properties to set
             * @returns {protos.ChannelQueryResponse} ChannelQueryResponse instance
             */
            ChannelQueryResponse.create = function create(properties) {
                return new ChannelQueryResponse(properties);
            };
    
            /**
             * Encodes the specified ChannelQueryResponse message. Does not implicitly {@link protos.ChannelQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {protos.IChannelQueryResponse} message ChannelQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channels != null && message.channels.length)
                    for (var i = 0; i < message.channels.length; ++i)
                        $root.protos.ChannelInfo.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChannelQueryResponse message, length delimited. Does not implicitly {@link protos.ChannelQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {protos.IChannelQueryResponse} message ChannelQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChannelQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChannelQueryResponse} ChannelQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChannelQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.channels && message.channels.length))
                            message.channels = [];
                        message.channels.push($root.protos.ChannelInfo.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChannelQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChannelQueryResponse} ChannelQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChannelQueryResponse message.
             * @function verify
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChannelQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channels != null && message.hasOwnProperty("channels")) {
                    if (!Array.isArray(message.channels))
                        return "channels: array expected";
                    for (var i = 0; i < message.channels.length; ++i) {
                        var error = $root.protos.ChannelInfo.verify(message.channels[i]);
                        if (error)
                            return "channels." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChannelQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChannelQueryResponse} ChannelQueryResponse
             */
            ChannelQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChannelQueryResponse)
                    return object;
                var message = new $root.protos.ChannelQueryResponse();
                if (object.channels) {
                    if (!Array.isArray(object.channels))
                        throw TypeError(".protos.ChannelQueryResponse.channels: array expected");
                    message.channels = [];
                    for (var i = 0; i < object.channels.length; ++i) {
                        if (typeof object.channels[i] !== "object")
                            throw TypeError(".protos.ChannelQueryResponse.channels: object expected");
                        message.channels[i] = $root.protos.ChannelInfo.fromObject(object.channels[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChannelQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChannelQueryResponse
             * @static
             * @param {protos.ChannelQueryResponse} message ChannelQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChannelQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.channels = [];
                if (message.channels && message.channels.length) {
                    object.channels = [];
                    for (var j = 0; j < message.channels.length; ++j)
                        object.channels[j] = $root.protos.ChannelInfo.toObject(message.channels[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChannelQueryResponse to JSON.
             * @function toJSON
             * @memberof protos.ChannelQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChannelQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChannelQueryResponse;
        })();
    
        protos.ChannelInfo = (function() {
    
            /**
             * Properties of a ChannelInfo.
             * @memberof protos
             * @interface IChannelInfo
             * @property {string|null} [channelId] ChannelInfo channelId
             */
    
            /**
             * Constructs a new ChannelInfo.
             * @memberof protos
             * @classdesc Represents a ChannelInfo.
             * @implements IChannelInfo
             * @constructor
             * @param {protos.IChannelInfo=} [properties] Properties to set
             */
            function ChannelInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChannelInfo channelId.
             * @member {string} channelId
             * @memberof protos.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.channelId = "";
    
            /**
             * Creates a new ChannelInfo instance using the specified properties.
             * @function create
             * @memberof protos.ChannelInfo
             * @static
             * @param {protos.IChannelInfo=} [properties] Properties to set
             * @returns {protos.ChannelInfo} ChannelInfo instance
             */
            ChannelInfo.create = function create(properties) {
                return new ChannelInfo(properties);
            };
    
            /**
             * Encodes the specified ChannelInfo message. Does not implicitly {@link protos.ChannelInfo.verify|verify} messages.
             * @function encode
             * @memberof protos.ChannelInfo
             * @static
             * @param {protos.IChannelInfo} message ChannelInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelId);
                return writer;
            };
    
            /**
             * Encodes the specified ChannelInfo message, length delimited. Does not implicitly {@link protos.ChannelInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChannelInfo
             * @static
             * @param {protos.IChannelInfo} message ChannelInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChannelInfo message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChannelInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChannelInfo} ChannelInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChannelInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channelId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChannelInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChannelInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChannelInfo} ChannelInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChannelInfo message.
             * @function verify
             * @memberof protos.ChannelInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChannelInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (!$util.isString(message.channelId))
                        return "channelId: string expected";
                return null;
            };
    
            /**
             * Creates a ChannelInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChannelInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChannelInfo} ChannelInfo
             */
            ChannelInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChannelInfo)
                    return object;
                var message = new $root.protos.ChannelInfo();
                if (object.channelId != null)
                    message.channelId = String(object.channelId);
                return message;
            };
    
            /**
             * Creates a plain object from a ChannelInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChannelInfo
             * @static
             * @param {protos.ChannelInfo} message ChannelInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChannelInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.channelId = "";
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    object.channelId = message.channelId;
                return object;
            };
    
            /**
             * Converts this ChannelInfo to JSON.
             * @function toJSON
             * @memberof protos.ChannelInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChannelInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChannelInfo;
        })();
    
        protos.Endorser = (function() {
    
            /**
             * Constructs a new Endorser service.
             * @memberof protos
             * @classdesc Represents an Endorser
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Endorser(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (Endorser.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Endorser;
    
            /**
             * Creates new Endorser service using the specified rpc implementation.
             * @function create
             * @memberof protos.Endorser
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Endorser} RPC service. Useful where requests and/or responses are streamed.
             */
            Endorser.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link protos.Endorser#processProposal}.
             * @memberof protos.Endorser
             * @typedef ProcessProposalCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {protos.ProposalResponse} [response] ProposalResponse
             */
    
            /**
             * Calls ProcessProposal.
             * @function processProposal
             * @memberof protos.Endorser
             * @instance
             * @param {protos.ISignedProposal} request SignedProposal message or plain object
             * @param {protos.Endorser.ProcessProposalCallback} callback Node-style callback called with the error, if any, and ProposalResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Endorser.prototype.processProposal = function processProposal(request, callback) {
                return this.rpcCall(processProposal, $root.protos.SignedProposal, $root.protos.ProposalResponse, request, callback);
            }, "name", { value: "ProcessProposal" });
    
            /**
             * Calls ProcessProposal.
             * @function processProposal
             * @memberof protos.Endorser
             * @instance
             * @param {protos.ISignedProposal} request SignedProposal message or plain object
             * @returns {Promise<protos.ProposalResponse>} Promise
             * @variation 2
             */
    
            return Endorser;
        })();
    
        protos.FilteredBlock = (function() {
    
            /**
             * Properties of a FilteredBlock.
             * @memberof protos
             * @interface IFilteredBlock
             * @property {string|null} [channelId] FilteredBlock channelId
             * @property {number|Long|null} [number] FilteredBlock number
             * @property {Array.<protos.IFilteredTransaction>|null} [filteredTransactions] FilteredBlock filteredTransactions
             */
    
            /**
             * Constructs a new FilteredBlock.
             * @memberof protos
             * @classdesc Represents a FilteredBlock.
             * @implements IFilteredBlock
             * @constructor
             * @param {protos.IFilteredBlock=} [properties] Properties to set
             */
            function FilteredBlock(properties) {
                this.filteredTransactions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FilteredBlock channelId.
             * @member {string} channelId
             * @memberof protos.FilteredBlock
             * @instance
             */
            FilteredBlock.prototype.channelId = "";
    
            /**
             * FilteredBlock number.
             * @member {number|Long} number
             * @memberof protos.FilteredBlock
             * @instance
             */
            FilteredBlock.prototype.number = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * FilteredBlock filteredTransactions.
             * @member {Array.<protos.IFilteredTransaction>} filteredTransactions
             * @memberof protos.FilteredBlock
             * @instance
             */
            FilteredBlock.prototype.filteredTransactions = $util.emptyArray;
    
            /**
             * Creates a new FilteredBlock instance using the specified properties.
             * @function create
             * @memberof protos.FilteredBlock
             * @static
             * @param {protos.IFilteredBlock=} [properties] Properties to set
             * @returns {protos.FilteredBlock} FilteredBlock instance
             */
            FilteredBlock.create = function create(properties) {
                return new FilteredBlock(properties);
            };
    
            /**
             * Encodes the specified FilteredBlock message. Does not implicitly {@link protos.FilteredBlock.verify|verify} messages.
             * @function encode
             * @memberof protos.FilteredBlock
             * @static
             * @param {protos.IFilteredBlock} message FilteredBlock message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredBlock.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelId);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.number);
                if (message.filteredTransactions != null && message.filteredTransactions.length)
                    for (var i = 0; i < message.filteredTransactions.length; ++i)
                        $root.protos.FilteredTransaction.encode(message.filteredTransactions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FilteredBlock message, length delimited. Does not implicitly {@link protos.FilteredBlock.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.FilteredBlock
             * @static
             * @param {protos.IFilteredBlock} message FilteredBlock message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredBlock.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FilteredBlock message from the specified reader or buffer.
             * @function decode
             * @memberof protos.FilteredBlock
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.FilteredBlock} FilteredBlock
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredBlock.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.FilteredBlock();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channelId = reader.string();
                        break;
                    case 2:
                        message.number = reader.uint64();
                        break;
                    case 4:
                        if (!(message.filteredTransactions && message.filteredTransactions.length))
                            message.filteredTransactions = [];
                        message.filteredTransactions.push($root.protos.FilteredTransaction.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FilteredBlock message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.FilteredBlock
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.FilteredBlock} FilteredBlock
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredBlock.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FilteredBlock message.
             * @function verify
             * @memberof protos.FilteredBlock
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FilteredBlock.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (!$util.isString(message.channelId))
                        return "channelId: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                if (message.filteredTransactions != null && message.hasOwnProperty("filteredTransactions")) {
                    if (!Array.isArray(message.filteredTransactions))
                        return "filteredTransactions: array expected";
                    for (var i = 0; i < message.filteredTransactions.length; ++i) {
                        var error = $root.protos.FilteredTransaction.verify(message.filteredTransactions[i]);
                        if (error)
                            return "filteredTransactions." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a FilteredBlock message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.FilteredBlock
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.FilteredBlock} FilteredBlock
             */
            FilteredBlock.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.FilteredBlock)
                    return object;
                var message = new $root.protos.FilteredBlock();
                if (object.channelId != null)
                    message.channelId = String(object.channelId);
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = true;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber(true);
                if (object.filteredTransactions) {
                    if (!Array.isArray(object.filteredTransactions))
                        throw TypeError(".protos.FilteredBlock.filteredTransactions: array expected");
                    message.filteredTransactions = [];
                    for (var i = 0; i < object.filteredTransactions.length; ++i) {
                        if (typeof object.filteredTransactions[i] !== "object")
                            throw TypeError(".protos.FilteredBlock.filteredTransactions: object expected");
                        message.filteredTransactions[i] = $root.protos.FilteredTransaction.fromObject(object.filteredTransactions[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FilteredBlock message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.FilteredBlock
             * @static
             * @param {protos.FilteredBlock} message FilteredBlock
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FilteredBlock.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.filteredTransactions = [];
                if (options.defaults) {
                    object.channelId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                }
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    object.channelId = message.channelId;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber(true) : message.number;
                if (message.filteredTransactions && message.filteredTransactions.length) {
                    object.filteredTransactions = [];
                    for (var j = 0; j < message.filteredTransactions.length; ++j)
                        object.filteredTransactions[j] = $root.protos.FilteredTransaction.toObject(message.filteredTransactions[j], options);
                }
                return object;
            };
    
            /**
             * Converts this FilteredBlock to JSON.
             * @function toJSON
             * @memberof protos.FilteredBlock
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FilteredBlock.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FilteredBlock;
        })();
    
        protos.FilteredTransaction = (function() {
    
            /**
             * Properties of a FilteredTransaction.
             * @memberof protos
             * @interface IFilteredTransaction
             * @property {string|null} [txid] FilteredTransaction txid
             * @property {common.HeaderType|null} [type] FilteredTransaction type
             * @property {protos.TxValidationCode|null} [txValidationCode] FilteredTransaction txValidationCode
             * @property {protos.IFilteredTransactionActions|null} [transactionActions] FilteredTransaction transactionActions
             */
    
            /**
             * Constructs a new FilteredTransaction.
             * @memberof protos
             * @classdesc Represents a FilteredTransaction.
             * @implements IFilteredTransaction
             * @constructor
             * @param {protos.IFilteredTransaction=} [properties] Properties to set
             */
            function FilteredTransaction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FilteredTransaction txid.
             * @member {string} txid
             * @memberof protos.FilteredTransaction
             * @instance
             */
            FilteredTransaction.prototype.txid = "";
    
            /**
             * FilteredTransaction type.
             * @member {common.HeaderType} type
             * @memberof protos.FilteredTransaction
             * @instance
             */
            FilteredTransaction.prototype.type = 0;
    
            /**
             * FilteredTransaction txValidationCode.
             * @member {protos.TxValidationCode} txValidationCode
             * @memberof protos.FilteredTransaction
             * @instance
             */
            FilteredTransaction.prototype.txValidationCode = 0;
    
            /**
             * FilteredTransaction transactionActions.
             * @member {protos.IFilteredTransactionActions|null|undefined} transactionActions
             * @memberof protos.FilteredTransaction
             * @instance
             */
            FilteredTransaction.prototype.transactionActions = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * FilteredTransaction Data.
             * @member {"transactionActions"|undefined} Data
             * @memberof protos.FilteredTransaction
             * @instance
             */
            Object.defineProperty(FilteredTransaction.prototype, "Data", {
                get: $util.oneOfGetter($oneOfFields = ["transactionActions"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new FilteredTransaction instance using the specified properties.
             * @function create
             * @memberof protos.FilteredTransaction
             * @static
             * @param {protos.IFilteredTransaction=} [properties] Properties to set
             * @returns {protos.FilteredTransaction} FilteredTransaction instance
             */
            FilteredTransaction.create = function create(properties) {
                return new FilteredTransaction(properties);
            };
    
            /**
             * Encodes the specified FilteredTransaction message. Does not implicitly {@link protos.FilteredTransaction.verify|verify} messages.
             * @function encode
             * @memberof protos.FilteredTransaction
             * @static
             * @param {protos.IFilteredTransaction} message FilteredTransaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredTransaction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txid != null && message.hasOwnProperty("txid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.txid);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.txValidationCode != null && message.hasOwnProperty("txValidationCode"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.txValidationCode);
                if (message.transactionActions != null && message.hasOwnProperty("transactionActions"))
                    $root.protos.FilteredTransactionActions.encode(message.transactionActions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FilteredTransaction message, length delimited. Does not implicitly {@link protos.FilteredTransaction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.FilteredTransaction
             * @static
             * @param {protos.IFilteredTransaction} message FilteredTransaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredTransaction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FilteredTransaction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.FilteredTransaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.FilteredTransaction} FilteredTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredTransaction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.FilteredTransaction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txid = reader.string();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.txValidationCode = reader.int32();
                        break;
                    case 4:
                        message.transactionActions = $root.protos.FilteredTransactionActions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FilteredTransaction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.FilteredTransaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.FilteredTransaction} FilteredTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredTransaction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FilteredTransaction message.
             * @function verify
             * @memberof protos.FilteredTransaction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FilteredTransaction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.txid != null && message.hasOwnProperty("txid"))
                    if (!$util.isString(message.txid))
                        return "txid: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 8:
                        break;
                    }
                if (message.txValidationCode != null && message.hasOwnProperty("txValidationCode"))
                    switch (message.txValidationCode) {
                    default:
                        return "txValidationCode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 254:
                    case 255:
                        break;
                    }
                if (message.transactionActions != null && message.hasOwnProperty("transactionActions")) {
                    properties.Data = 1;
                    {
                        var error = $root.protos.FilteredTransactionActions.verify(message.transactionActions);
                        if (error)
                            return "transactionActions." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a FilteredTransaction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.FilteredTransaction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.FilteredTransaction} FilteredTransaction
             */
            FilteredTransaction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.FilteredTransaction)
                    return object;
                var message = new $root.protos.FilteredTransaction();
                if (object.txid != null)
                    message.txid = String(object.txid);
                switch (object.type) {
                case "MESSAGE":
                case 0:
                    message.type = 0;
                    break;
                case "CONFIG":
                case 1:
                    message.type = 1;
                    break;
                case "CONFIG_UPDATE":
                case 2:
                    message.type = 2;
                    break;
                case "ENDORSER_TRANSACTION":
                case 3:
                    message.type = 3;
                    break;
                case "ORDERER_TRANSACTION":
                case 4:
                    message.type = 4;
                    break;
                case "DELIVER_SEEK_INFO":
                case 5:
                    message.type = 5;
                    break;
                case "CHAINCODE_PACKAGE":
                case 6:
                    message.type = 6;
                    break;
                case "PEER_ADMIN_OPERATION":
                case 8:
                    message.type = 8;
                    break;
                }
                switch (object.txValidationCode) {
                case "VALID":
                case 0:
                    message.txValidationCode = 0;
                    break;
                case "NIL_ENVELOPE":
                case 1:
                    message.txValidationCode = 1;
                    break;
                case "BAD_PAYLOAD":
                case 2:
                    message.txValidationCode = 2;
                    break;
                case "BAD_COMMON_HEADER":
                case 3:
                    message.txValidationCode = 3;
                    break;
                case "BAD_CREATOR_SIGNATURE":
                case 4:
                    message.txValidationCode = 4;
                    break;
                case "INVALID_ENDORSER_TRANSACTION":
                case 5:
                    message.txValidationCode = 5;
                    break;
                case "INVALID_CONFIG_TRANSACTION":
                case 6:
                    message.txValidationCode = 6;
                    break;
                case "UNSUPPORTED_TX_PAYLOAD":
                case 7:
                    message.txValidationCode = 7;
                    break;
                case "BAD_PROPOSAL_TXID":
                case 8:
                    message.txValidationCode = 8;
                    break;
                case "DUPLICATE_TXID":
                case 9:
                    message.txValidationCode = 9;
                    break;
                case "ENDORSEMENT_POLICY_FAILURE":
                case 10:
                    message.txValidationCode = 10;
                    break;
                case "MVCC_READ_CONFLICT":
                case 11:
                    message.txValidationCode = 11;
                    break;
                case "PHANTOM_READ_CONFLICT":
                case 12:
                    message.txValidationCode = 12;
                    break;
                case "UNKNOWN_TX_TYPE":
                case 13:
                    message.txValidationCode = 13;
                    break;
                case "TARGET_CHAIN_NOT_FOUND":
                case 14:
                    message.txValidationCode = 14;
                    break;
                case "MARSHAL_TX_ERROR":
                case 15:
                    message.txValidationCode = 15;
                    break;
                case "NIL_TXACTION":
                case 16:
                    message.txValidationCode = 16;
                    break;
                case "EXPIRED_CHAINCODE":
                case 17:
                    message.txValidationCode = 17;
                    break;
                case "CHAINCODE_VERSION_CONFLICT":
                case 18:
                    message.txValidationCode = 18;
                    break;
                case "BAD_HEADER_EXTENSION":
                case 19:
                    message.txValidationCode = 19;
                    break;
                case "BAD_CHANNEL_HEADER":
                case 20:
                    message.txValidationCode = 20;
                    break;
                case "BAD_RESPONSE_PAYLOAD":
                case 21:
                    message.txValidationCode = 21;
                    break;
                case "BAD_RWSET":
                case 22:
                    message.txValidationCode = 22;
                    break;
                case "ILLEGAL_WRITESET":
                case 23:
                    message.txValidationCode = 23;
                    break;
                case "INVALID_WRITESET":
                case 24:
                    message.txValidationCode = 24;
                    break;
                case "INVALID_CHAINCODE":
                case 25:
                    message.txValidationCode = 25;
                    break;
                case "NOT_VALIDATED":
                case 254:
                    message.txValidationCode = 254;
                    break;
                case "INVALID_OTHER_REASON":
                case 255:
                    message.txValidationCode = 255;
                    break;
                }
                if (object.transactionActions != null) {
                    if (typeof object.transactionActions !== "object")
                        throw TypeError(".protos.FilteredTransaction.transactionActions: object expected");
                    message.transactionActions = $root.protos.FilteredTransactionActions.fromObject(object.transactionActions);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FilteredTransaction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.FilteredTransaction
             * @static
             * @param {protos.FilteredTransaction} message FilteredTransaction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FilteredTransaction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.txid = "";
                    object.type = options.enums === String ? "MESSAGE" : 0;
                    object.txValidationCode = options.enums === String ? "VALID" : 0;
                }
                if (message.txid != null && message.hasOwnProperty("txid"))
                    object.txid = message.txid;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.common.HeaderType[message.type] : message.type;
                if (message.txValidationCode != null && message.hasOwnProperty("txValidationCode"))
                    object.txValidationCode = options.enums === String ? $root.protos.TxValidationCode[message.txValidationCode] : message.txValidationCode;
                if (message.transactionActions != null && message.hasOwnProperty("transactionActions")) {
                    object.transactionActions = $root.protos.FilteredTransactionActions.toObject(message.transactionActions, options);
                    if (options.oneofs)
                        object.Data = "transactionActions";
                }
                return object;
            };
    
            /**
             * Converts this FilteredTransaction to JSON.
             * @function toJSON
             * @memberof protos.FilteredTransaction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FilteredTransaction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FilteredTransaction;
        })();
    
        protos.FilteredTransactionActions = (function() {
    
            /**
             * Properties of a FilteredTransactionActions.
             * @memberof protos
             * @interface IFilteredTransactionActions
             * @property {Array.<protos.IFilteredChaincodeAction>|null} [chaincodeActions] FilteredTransactionActions chaincodeActions
             */
    
            /**
             * Constructs a new FilteredTransactionActions.
             * @memberof protos
             * @classdesc Represents a FilteredTransactionActions.
             * @implements IFilteredTransactionActions
             * @constructor
             * @param {protos.IFilteredTransactionActions=} [properties] Properties to set
             */
            function FilteredTransactionActions(properties) {
                this.chaincodeActions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FilteredTransactionActions chaincodeActions.
             * @member {Array.<protos.IFilteredChaincodeAction>} chaincodeActions
             * @memberof protos.FilteredTransactionActions
             * @instance
             */
            FilteredTransactionActions.prototype.chaincodeActions = $util.emptyArray;
    
            /**
             * Creates a new FilteredTransactionActions instance using the specified properties.
             * @function create
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {protos.IFilteredTransactionActions=} [properties] Properties to set
             * @returns {protos.FilteredTransactionActions} FilteredTransactionActions instance
             */
            FilteredTransactionActions.create = function create(properties) {
                return new FilteredTransactionActions(properties);
            };
    
            /**
             * Encodes the specified FilteredTransactionActions message. Does not implicitly {@link protos.FilteredTransactionActions.verify|verify} messages.
             * @function encode
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {protos.IFilteredTransactionActions} message FilteredTransactionActions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredTransactionActions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodeActions != null && message.chaincodeActions.length)
                    for (var i = 0; i < message.chaincodeActions.length; ++i)
                        $root.protos.FilteredChaincodeAction.encode(message.chaincodeActions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FilteredTransactionActions message, length delimited. Does not implicitly {@link protos.FilteredTransactionActions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {protos.IFilteredTransactionActions} message FilteredTransactionActions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredTransactionActions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FilteredTransactionActions message from the specified reader or buffer.
             * @function decode
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.FilteredTransactionActions} FilteredTransactionActions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredTransactionActions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.FilteredTransactionActions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.chaincodeActions && message.chaincodeActions.length))
                            message.chaincodeActions = [];
                        message.chaincodeActions.push($root.protos.FilteredChaincodeAction.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FilteredTransactionActions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.FilteredTransactionActions} FilteredTransactionActions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredTransactionActions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FilteredTransactionActions message.
             * @function verify
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FilteredTransactionActions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodeActions != null && message.hasOwnProperty("chaincodeActions")) {
                    if (!Array.isArray(message.chaincodeActions))
                        return "chaincodeActions: array expected";
                    for (var i = 0; i < message.chaincodeActions.length; ++i) {
                        var error = $root.protos.FilteredChaincodeAction.verify(message.chaincodeActions[i]);
                        if (error)
                            return "chaincodeActions." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a FilteredTransactionActions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.FilteredTransactionActions} FilteredTransactionActions
             */
            FilteredTransactionActions.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.FilteredTransactionActions)
                    return object;
                var message = new $root.protos.FilteredTransactionActions();
                if (object.chaincodeActions) {
                    if (!Array.isArray(object.chaincodeActions))
                        throw TypeError(".protos.FilteredTransactionActions.chaincodeActions: array expected");
                    message.chaincodeActions = [];
                    for (var i = 0; i < object.chaincodeActions.length; ++i) {
                        if (typeof object.chaincodeActions[i] !== "object")
                            throw TypeError(".protos.FilteredTransactionActions.chaincodeActions: object expected");
                        message.chaincodeActions[i] = $root.protos.FilteredChaincodeAction.fromObject(object.chaincodeActions[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FilteredTransactionActions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.FilteredTransactionActions
             * @static
             * @param {protos.FilteredTransactionActions} message FilteredTransactionActions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FilteredTransactionActions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.chaincodeActions = [];
                if (message.chaincodeActions && message.chaincodeActions.length) {
                    object.chaincodeActions = [];
                    for (var j = 0; j < message.chaincodeActions.length; ++j)
                        object.chaincodeActions[j] = $root.protos.FilteredChaincodeAction.toObject(message.chaincodeActions[j], options);
                }
                return object;
            };
    
            /**
             * Converts this FilteredTransactionActions to JSON.
             * @function toJSON
             * @memberof protos.FilteredTransactionActions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FilteredTransactionActions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FilteredTransactionActions;
        })();
    
        protos.FilteredChaincodeAction = (function() {
    
            /**
             * Properties of a FilteredChaincodeAction.
             * @memberof protos
             * @interface IFilteredChaincodeAction
             * @property {protos.IChaincodeEvent|null} [chaincodeEvent] FilteredChaincodeAction chaincodeEvent
             */
    
            /**
             * Constructs a new FilteredChaincodeAction.
             * @memberof protos
             * @classdesc Represents a FilteredChaincodeAction.
             * @implements IFilteredChaincodeAction
             * @constructor
             * @param {protos.IFilteredChaincodeAction=} [properties] Properties to set
             */
            function FilteredChaincodeAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * FilteredChaincodeAction chaincodeEvent.
             * @member {protos.IChaincodeEvent|null|undefined} chaincodeEvent
             * @memberof protos.FilteredChaincodeAction
             * @instance
             */
            FilteredChaincodeAction.prototype.chaincodeEvent = null;
    
            /**
             * Creates a new FilteredChaincodeAction instance using the specified properties.
             * @function create
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {protos.IFilteredChaincodeAction=} [properties] Properties to set
             * @returns {protos.FilteredChaincodeAction} FilteredChaincodeAction instance
             */
            FilteredChaincodeAction.create = function create(properties) {
                return new FilteredChaincodeAction(properties);
            };
    
            /**
             * Encodes the specified FilteredChaincodeAction message. Does not implicitly {@link protos.FilteredChaincodeAction.verify|verify} messages.
             * @function encode
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {protos.IFilteredChaincodeAction} message FilteredChaincodeAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredChaincodeAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodeEvent != null && message.hasOwnProperty("chaincodeEvent"))
                    $root.protos.ChaincodeEvent.encode(message.chaincodeEvent, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified FilteredChaincodeAction message, length delimited. Does not implicitly {@link protos.FilteredChaincodeAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {protos.IFilteredChaincodeAction} message FilteredChaincodeAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredChaincodeAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a FilteredChaincodeAction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.FilteredChaincodeAction} FilteredChaincodeAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredChaincodeAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.FilteredChaincodeAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincodeEvent = $root.protos.ChaincodeEvent.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a FilteredChaincodeAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.FilteredChaincodeAction} FilteredChaincodeAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredChaincodeAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a FilteredChaincodeAction message.
             * @function verify
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FilteredChaincodeAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodeEvent != null && message.hasOwnProperty("chaincodeEvent")) {
                    var error = $root.protos.ChaincodeEvent.verify(message.chaincodeEvent);
                    if (error)
                        return "chaincodeEvent." + error;
                }
                return null;
            };
    
            /**
             * Creates a FilteredChaincodeAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.FilteredChaincodeAction} FilteredChaincodeAction
             */
            FilteredChaincodeAction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.FilteredChaincodeAction)
                    return object;
                var message = new $root.protos.FilteredChaincodeAction();
                if (object.chaincodeEvent != null) {
                    if (typeof object.chaincodeEvent !== "object")
                        throw TypeError(".protos.FilteredChaincodeAction.chaincodeEvent: object expected");
                    message.chaincodeEvent = $root.protos.ChaincodeEvent.fromObject(object.chaincodeEvent);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a FilteredChaincodeAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.FilteredChaincodeAction
             * @static
             * @param {protos.FilteredChaincodeAction} message FilteredChaincodeAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FilteredChaincodeAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.chaincodeEvent = null;
                if (message.chaincodeEvent != null && message.hasOwnProperty("chaincodeEvent"))
                    object.chaincodeEvent = $root.protos.ChaincodeEvent.toObject(message.chaincodeEvent, options);
                return object;
            };
    
            /**
             * Converts this FilteredChaincodeAction to JSON.
             * @function toJSON
             * @memberof protos.FilteredChaincodeAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FilteredChaincodeAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return FilteredChaincodeAction;
        })();
    
        protos.BlockAndPrivateData = (function() {
    
            /**
             * Properties of a BlockAndPrivateData.
             * @memberof protos
             * @interface IBlockAndPrivateData
             * @property {common.IBlock|null} [block] BlockAndPrivateData block
             * @property {Object.<string,rwset.ITxPvtReadWriteSet>|null} [privateDataMap] BlockAndPrivateData privateDataMap
             */
    
            /**
             * Constructs a new BlockAndPrivateData.
             * @memberof protos
             * @classdesc Represents a BlockAndPrivateData.
             * @implements IBlockAndPrivateData
             * @constructor
             * @param {protos.IBlockAndPrivateData=} [properties] Properties to set
             */
            function BlockAndPrivateData(properties) {
                this.privateDataMap = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockAndPrivateData block.
             * @member {common.IBlock|null|undefined} block
             * @memberof protos.BlockAndPrivateData
             * @instance
             */
            BlockAndPrivateData.prototype.block = null;
    
            /**
             * BlockAndPrivateData privateDataMap.
             * @member {Object.<string,rwset.ITxPvtReadWriteSet>} privateDataMap
             * @memberof protos.BlockAndPrivateData
             * @instance
             */
            BlockAndPrivateData.prototype.privateDataMap = $util.emptyObject;
    
            /**
             * Creates a new BlockAndPrivateData instance using the specified properties.
             * @function create
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {protos.IBlockAndPrivateData=} [properties] Properties to set
             * @returns {protos.BlockAndPrivateData} BlockAndPrivateData instance
             */
            BlockAndPrivateData.create = function create(properties) {
                return new BlockAndPrivateData(properties);
            };
    
            /**
             * Encodes the specified BlockAndPrivateData message. Does not implicitly {@link protos.BlockAndPrivateData.verify|verify} messages.
             * @function encode
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {protos.IBlockAndPrivateData} message BlockAndPrivateData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockAndPrivateData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.block != null && message.hasOwnProperty("block"))
                    $root.common.Block.encode(message.block, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.privateDataMap != null && message.hasOwnProperty("privateDataMap"))
                    for (var keys = Object.keys(message.privateDataMap), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]);
                        $root.rwset.TxPvtReadWriteSet.encode(message.privateDataMap[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified BlockAndPrivateData message, length delimited. Does not implicitly {@link protos.BlockAndPrivateData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {protos.IBlockAndPrivateData} message BlockAndPrivateData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockAndPrivateData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockAndPrivateData message from the specified reader or buffer.
             * @function decode
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.BlockAndPrivateData} BlockAndPrivateData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockAndPrivateData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.BlockAndPrivateData(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.block = $root.common.Block.decode(reader, reader.uint32());
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.privateDataMap === $util.emptyObject)
                            message.privateDataMap = {};
                        key = reader.uint64();
                        reader.pos++;
                        message.privateDataMap[typeof key === "object" ? $util.longToHash(key) : key] = $root.rwset.TxPvtReadWriteSet.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockAndPrivateData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.BlockAndPrivateData} BlockAndPrivateData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockAndPrivateData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockAndPrivateData message.
             * @function verify
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockAndPrivateData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.block != null && message.hasOwnProperty("block")) {
                    var error = $root.common.Block.verify(message.block);
                    if (error)
                        return "block." + error;
                }
                if (message.privateDataMap != null && message.hasOwnProperty("privateDataMap")) {
                    if (!$util.isObject(message.privateDataMap))
                        return "privateDataMap: object expected";
                    var key = Object.keys(message.privateDataMap);
                    for (var i = 0; i < key.length; ++i) {
                        if (!$util.key64Re.test(key[i]))
                            return "privateDataMap: integer|Long key{k:uint64} expected";
                        {
                            var error = $root.rwset.TxPvtReadWriteSet.verify(message.privateDataMap[key[i]]);
                            if (error)
                                return "privateDataMap." + error;
                        }
                    }
                }
                return null;
            };
    
            /**
             * Creates a BlockAndPrivateData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.BlockAndPrivateData} BlockAndPrivateData
             */
            BlockAndPrivateData.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.BlockAndPrivateData)
                    return object;
                var message = new $root.protos.BlockAndPrivateData();
                if (object.block != null) {
                    if (typeof object.block !== "object")
                        throw TypeError(".protos.BlockAndPrivateData.block: object expected");
                    message.block = $root.common.Block.fromObject(object.block);
                }
                if (object.privateDataMap) {
                    if (typeof object.privateDataMap !== "object")
                        throw TypeError(".protos.BlockAndPrivateData.privateDataMap: object expected");
                    message.privateDataMap = {};
                    for (var keys = Object.keys(object.privateDataMap), i = 0; i < keys.length; ++i) {
                        if (typeof object.privateDataMap[keys[i]] !== "object")
                            throw TypeError(".protos.BlockAndPrivateData.privateDataMap: object expected");
                        message.privateDataMap[keys[i]] = $root.rwset.TxPvtReadWriteSet.fromObject(object.privateDataMap[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a BlockAndPrivateData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.BlockAndPrivateData
             * @static
             * @param {protos.BlockAndPrivateData} message BlockAndPrivateData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockAndPrivateData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.privateDataMap = {};
                if (options.defaults)
                    object.block = null;
                if (message.block != null && message.hasOwnProperty("block"))
                    object.block = $root.common.Block.toObject(message.block, options);
                var keys2;
                if (message.privateDataMap && (keys2 = Object.keys(message.privateDataMap)).length) {
                    object.privateDataMap = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.privateDataMap[keys2[j]] = $root.rwset.TxPvtReadWriteSet.toObject(message.privateDataMap[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this BlockAndPrivateData to JSON.
             * @function toJSON
             * @memberof protos.BlockAndPrivateData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockAndPrivateData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockAndPrivateData;
        })();
    
        protos.DeliverResponse = (function() {
    
            /**
             * Properties of a DeliverResponse.
             * @memberof protos
             * @interface IDeliverResponse
             * @property {common.Status|null} [status] DeliverResponse status
             * @property {common.IBlock|null} [block] DeliverResponse block
             * @property {protos.IFilteredBlock|null} [filteredBlock] DeliverResponse filteredBlock
             * @property {protos.IBlockAndPrivateData|null} [blockAndPrivateData] DeliverResponse blockAndPrivateData
             */
    
            /**
             * Constructs a new DeliverResponse.
             * @memberof protos
             * @classdesc Represents a DeliverResponse.
             * @implements IDeliverResponse
             * @constructor
             * @param {protos.IDeliverResponse=} [properties] Properties to set
             */
            function DeliverResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DeliverResponse status.
             * @member {common.Status} status
             * @memberof protos.DeliverResponse
             * @instance
             */
            DeliverResponse.prototype.status = 0;
    
            /**
             * DeliverResponse block.
             * @member {common.IBlock|null|undefined} block
             * @memberof protos.DeliverResponse
             * @instance
             */
            DeliverResponse.prototype.block = null;
    
            /**
             * DeliverResponse filteredBlock.
             * @member {protos.IFilteredBlock|null|undefined} filteredBlock
             * @memberof protos.DeliverResponse
             * @instance
             */
            DeliverResponse.prototype.filteredBlock = null;
    
            /**
             * DeliverResponse blockAndPrivateData.
             * @member {protos.IBlockAndPrivateData|null|undefined} blockAndPrivateData
             * @memberof protos.DeliverResponse
             * @instance
             */
            DeliverResponse.prototype.blockAndPrivateData = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * DeliverResponse Type.
             * @member {"status"|"block"|"filteredBlock"|"blockAndPrivateData"|undefined} Type
             * @memberof protos.DeliverResponse
             * @instance
             */
            Object.defineProperty(DeliverResponse.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["status", "block", "filteredBlock", "blockAndPrivateData"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new DeliverResponse instance using the specified properties.
             * @function create
             * @memberof protos.DeliverResponse
             * @static
             * @param {protos.IDeliverResponse=} [properties] Properties to set
             * @returns {protos.DeliverResponse} DeliverResponse instance
             */
            DeliverResponse.create = function create(properties) {
                return new DeliverResponse(properties);
            };
    
            /**
             * Encodes the specified DeliverResponse message. Does not implicitly {@link protos.DeliverResponse.verify|verify} messages.
             * @function encode
             * @memberof protos.DeliverResponse
             * @static
             * @param {protos.IDeliverResponse} message DeliverResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeliverResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.block != null && message.hasOwnProperty("block"))
                    $root.common.Block.encode(message.block, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.filteredBlock != null && message.hasOwnProperty("filteredBlock"))
                    $root.protos.FilteredBlock.encode(message.filteredBlock, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.blockAndPrivateData != null && message.hasOwnProperty("blockAndPrivateData"))
                    $root.protos.BlockAndPrivateData.encode(message.blockAndPrivateData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified DeliverResponse message, length delimited. Does not implicitly {@link protos.DeliverResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.DeliverResponse
             * @static
             * @param {protos.IDeliverResponse} message DeliverResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeliverResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DeliverResponse message from the specified reader or buffer.
             * @function decode
             * @memberof protos.DeliverResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.DeliverResponse} DeliverResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeliverResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DeliverResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        message.block = $root.common.Block.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.filteredBlock = $root.protos.FilteredBlock.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.blockAndPrivateData = $root.protos.BlockAndPrivateData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DeliverResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.DeliverResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.DeliverResponse} DeliverResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeliverResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DeliverResponse message.
             * @function verify
             * @memberof protos.DeliverResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeliverResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.status != null && message.hasOwnProperty("status")) {
                    properties.Type = 1;
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 200:
                    case 400:
                    case 403:
                    case 404:
                    case 413:
                    case 500:
                    case 501:
                    case 503:
                        break;
                    }
                }
                if (message.block != null && message.hasOwnProperty("block")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.common.Block.verify(message.block);
                        if (error)
                            return "block." + error;
                    }
                }
                if (message.filteredBlock != null && message.hasOwnProperty("filteredBlock")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.protos.FilteredBlock.verify(message.filteredBlock);
                        if (error)
                            return "filteredBlock." + error;
                    }
                }
                if (message.blockAndPrivateData != null && message.hasOwnProperty("blockAndPrivateData")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.protos.BlockAndPrivateData.verify(message.blockAndPrivateData);
                        if (error)
                            return "blockAndPrivateData." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a DeliverResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.DeliverResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.DeliverResponse} DeliverResponse
             */
            DeliverResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.DeliverResponse)
                    return object;
                var message = new $root.protos.DeliverResponse();
                switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 200:
                    message.status = 200;
                    break;
                case "BAD_REQUEST":
                case 400:
                    message.status = 400;
                    break;
                case "FORBIDDEN":
                case 403:
                    message.status = 403;
                    break;
                case "NOT_FOUND":
                case 404:
                    message.status = 404;
                    break;
                case "REQUEST_ENTITY_TOO_LARGE":
                case 413:
                    message.status = 413;
                    break;
                case "INTERNAL_SERVER_ERROR":
                case 500:
                    message.status = 500;
                    break;
                case "NOT_IMPLEMENTED":
                case 501:
                    message.status = 501;
                    break;
                case "SERVICE_UNAVAILABLE":
                case 503:
                    message.status = 503;
                    break;
                }
                if (object.block != null) {
                    if (typeof object.block !== "object")
                        throw TypeError(".protos.DeliverResponse.block: object expected");
                    message.block = $root.common.Block.fromObject(object.block);
                }
                if (object.filteredBlock != null) {
                    if (typeof object.filteredBlock !== "object")
                        throw TypeError(".protos.DeliverResponse.filteredBlock: object expected");
                    message.filteredBlock = $root.protos.FilteredBlock.fromObject(object.filteredBlock);
                }
                if (object.blockAndPrivateData != null) {
                    if (typeof object.blockAndPrivateData !== "object")
                        throw TypeError(".protos.DeliverResponse.blockAndPrivateData: object expected");
                    message.blockAndPrivateData = $root.protos.BlockAndPrivateData.fromObject(object.blockAndPrivateData);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DeliverResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.DeliverResponse
             * @static
             * @param {protos.DeliverResponse} message DeliverResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeliverResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.status != null && message.hasOwnProperty("status")) {
                    object.status = options.enums === String ? $root.common.Status[message.status] : message.status;
                    if (options.oneofs)
                        object.Type = "status";
                }
                if (message.block != null && message.hasOwnProperty("block")) {
                    object.block = $root.common.Block.toObject(message.block, options);
                    if (options.oneofs)
                        object.Type = "block";
                }
                if (message.filteredBlock != null && message.hasOwnProperty("filteredBlock")) {
                    object.filteredBlock = $root.protos.FilteredBlock.toObject(message.filteredBlock, options);
                    if (options.oneofs)
                        object.Type = "filteredBlock";
                }
                if (message.blockAndPrivateData != null && message.hasOwnProperty("blockAndPrivateData")) {
                    object.blockAndPrivateData = $root.protos.BlockAndPrivateData.toObject(message.blockAndPrivateData, options);
                    if (options.oneofs)
                        object.Type = "blockAndPrivateData";
                }
                return object;
            };
    
            /**
             * Converts this DeliverResponse to JSON.
             * @function toJSON
             * @memberof protos.DeliverResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeliverResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DeliverResponse;
        })();
    
        protos.Deliver = (function() {
    
            /**
             * Constructs a new Deliver service.
             * @memberof protos
             * @classdesc Represents a Deliver
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Deliver(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (Deliver.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Deliver;
    
            /**
             * Creates new Deliver service using the specified rpc implementation.
             * @function create
             * @memberof protos.Deliver
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Deliver} RPC service. Useful where requests and/or responses are streamed.
             */
            Deliver.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link protos.Deliver#deliver}.
             * @memberof protos.Deliver
             * @typedef DeliverCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {protos.DeliverResponse} [response] DeliverResponse
             */
    
            /**
             * Calls Deliver.
             * @function deliver
             * @memberof protos.Deliver
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @param {protos.Deliver.DeliverCallback} callback Node-style callback called with the error, if any, and DeliverResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Deliver.prototype.deliver = function deliver(request, callback) {
                return this.rpcCall(deliver, $root.common.Envelope, $root.protos.DeliverResponse, request, callback);
            }, "name", { value: "Deliver" });
    
            /**
             * Calls Deliver.
             * @function deliver
             * @memberof protos.Deliver
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @returns {Promise<protos.DeliverResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link protos.Deliver#deliverFiltered}.
             * @memberof protos.Deliver
             * @typedef DeliverFilteredCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {protos.DeliverResponse} [response] DeliverResponse
             */
    
            /**
             * Calls DeliverFiltered.
             * @function deliverFiltered
             * @memberof protos.Deliver
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @param {protos.Deliver.DeliverFilteredCallback} callback Node-style callback called with the error, if any, and DeliverResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Deliver.prototype.deliverFiltered = function deliverFiltered(request, callback) {
                return this.rpcCall(deliverFiltered, $root.common.Envelope, $root.protos.DeliverResponse, request, callback);
            }, "name", { value: "DeliverFiltered" });
    
            /**
             * Calls DeliverFiltered.
             * @function deliverFiltered
             * @memberof protos.Deliver
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @returns {Promise<protos.DeliverResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link protos.Deliver#deliverWithPrivateData}.
             * @memberof protos.Deliver
             * @typedef DeliverWithPrivateDataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {protos.DeliverResponse} [response] DeliverResponse
             */
    
            /**
             * Calls DeliverWithPrivateData.
             * @function deliverWithPrivateData
             * @memberof protos.Deliver
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @param {protos.Deliver.DeliverWithPrivateDataCallback} callback Node-style callback called with the error, if any, and DeliverResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Deliver.prototype.deliverWithPrivateData = function deliverWithPrivateData(request, callback) {
                return this.rpcCall(deliverWithPrivateData, $root.common.Envelope, $root.protos.DeliverResponse, request, callback);
            }, "name", { value: "DeliverWithPrivateData" });
    
            /**
             * Calls DeliverWithPrivateData.
             * @function deliverWithPrivateData
             * @memberof protos.Deliver
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @returns {Promise<protos.DeliverResponse>} Promise
             * @variation 2
             */
    
            return Deliver;
        })();
    
        protos.SignedTransaction = (function() {
    
            /**
             * Properties of a SignedTransaction.
             * @memberof protos
             * @interface ISignedTransaction
             * @property {Uint8Array|null} [transactionBytes] SignedTransaction transactionBytes
             * @property {Uint8Array|null} [signature] SignedTransaction signature
             */
    
            /**
             * Constructs a new SignedTransaction.
             * @memberof protos
             * @classdesc Represents a SignedTransaction.
             * @implements ISignedTransaction
             * @constructor
             * @param {protos.ISignedTransaction=} [properties] Properties to set
             */
            function SignedTransaction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignedTransaction transactionBytes.
             * @member {Uint8Array} transactionBytes
             * @memberof protos.SignedTransaction
             * @instance
             */
            SignedTransaction.prototype.transactionBytes = $util.newBuffer([]);
    
            /**
             * SignedTransaction signature.
             * @member {Uint8Array} signature
             * @memberof protos.SignedTransaction
             * @instance
             */
            SignedTransaction.prototype.signature = $util.newBuffer([]);
    
            /**
             * Creates a new SignedTransaction instance using the specified properties.
             * @function create
             * @memberof protos.SignedTransaction
             * @static
             * @param {protos.ISignedTransaction=} [properties] Properties to set
             * @returns {protos.SignedTransaction} SignedTransaction instance
             */
            SignedTransaction.create = function create(properties) {
                return new SignedTransaction(properties);
            };
    
            /**
             * Encodes the specified SignedTransaction message. Does not implicitly {@link protos.SignedTransaction.verify|verify} messages.
             * @function encode
             * @memberof protos.SignedTransaction
             * @static
             * @param {protos.ISignedTransaction} message SignedTransaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedTransaction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.transactionBytes != null && message.hasOwnProperty("transactionBytes"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.transactionBytes);
                if (message.signature != null && message.hasOwnProperty("signature"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                return writer;
            };
    
            /**
             * Encodes the specified SignedTransaction message, length delimited. Does not implicitly {@link protos.SignedTransaction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.SignedTransaction
             * @static
             * @param {protos.ISignedTransaction} message SignedTransaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedTransaction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignedTransaction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.SignedTransaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.SignedTransaction} SignedTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedTransaction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.SignedTransaction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.transactionBytes = reader.bytes();
                        break;
                    case 2:
                        message.signature = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SignedTransaction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.SignedTransaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.SignedTransaction} SignedTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedTransaction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignedTransaction message.
             * @function verify
             * @memberof protos.SignedTransaction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignedTransaction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.transactionBytes != null && message.hasOwnProperty("transactionBytes"))
                    if (!(message.transactionBytes && typeof message.transactionBytes.length === "number" || $util.isString(message.transactionBytes)))
                        return "transactionBytes: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                return null;
            };
    
            /**
             * Creates a SignedTransaction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.SignedTransaction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.SignedTransaction} SignedTransaction
             */
            SignedTransaction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.SignedTransaction)
                    return object;
                var message = new $root.protos.SignedTransaction();
                if (object.transactionBytes != null)
                    if (typeof object.transactionBytes === "string")
                        $util.base64.decode(object.transactionBytes, message.transactionBytes = $util.newBuffer($util.base64.length(object.transactionBytes)), 0);
                    else if (object.transactionBytes.length)
                        message.transactionBytes = object.transactionBytes;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                return message;
            };
    
            /**
             * Creates a plain object from a SignedTransaction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.SignedTransaction
             * @static
             * @param {protos.SignedTransaction} message SignedTransaction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignedTransaction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.transactionBytes = "";
                    else {
                        object.transactionBytes = [];
                        if (options.bytes !== Array)
                            object.transactionBytes = $util.newBuffer(object.transactionBytes);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                }
                if (message.transactionBytes != null && message.hasOwnProperty("transactionBytes"))
                    object.transactionBytes = options.bytes === String ? $util.base64.encode(message.transactionBytes, 0, message.transactionBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.transactionBytes) : message.transactionBytes;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                return object;
            };
    
            /**
             * Converts this SignedTransaction to JSON.
             * @function toJSON
             * @memberof protos.SignedTransaction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignedTransaction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignedTransaction;
        })();
    
        protos.ProcessedTransaction = (function() {
    
            /**
             * Properties of a ProcessedTransaction.
             * @memberof protos
             * @interface IProcessedTransaction
             * @property {common.IEnvelope|null} [transactionEnvelope] ProcessedTransaction transactionEnvelope
             * @property {number|null} [validationCode] ProcessedTransaction validationCode
             */
    
            /**
             * Constructs a new ProcessedTransaction.
             * @memberof protos
             * @classdesc Represents a ProcessedTransaction.
             * @implements IProcessedTransaction
             * @constructor
             * @param {protos.IProcessedTransaction=} [properties] Properties to set
             */
            function ProcessedTransaction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ProcessedTransaction transactionEnvelope.
             * @member {common.IEnvelope|null|undefined} transactionEnvelope
             * @memberof protos.ProcessedTransaction
             * @instance
             */
            ProcessedTransaction.prototype.transactionEnvelope = null;
    
            /**
             * ProcessedTransaction validationCode.
             * @member {number} validationCode
             * @memberof protos.ProcessedTransaction
             * @instance
             */
            ProcessedTransaction.prototype.validationCode = 0;
    
            /**
             * Creates a new ProcessedTransaction instance using the specified properties.
             * @function create
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {protos.IProcessedTransaction=} [properties] Properties to set
             * @returns {protos.ProcessedTransaction} ProcessedTransaction instance
             */
            ProcessedTransaction.create = function create(properties) {
                return new ProcessedTransaction(properties);
            };
    
            /**
             * Encodes the specified ProcessedTransaction message. Does not implicitly {@link protos.ProcessedTransaction.verify|verify} messages.
             * @function encode
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {protos.IProcessedTransaction} message ProcessedTransaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProcessedTransaction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.transactionEnvelope != null && message.hasOwnProperty("transactionEnvelope"))
                    $root.common.Envelope.encode(message.transactionEnvelope, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.validationCode != null && message.hasOwnProperty("validationCode"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.validationCode);
                return writer;
            };
    
            /**
             * Encodes the specified ProcessedTransaction message, length delimited. Does not implicitly {@link protos.ProcessedTransaction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {protos.IProcessedTransaction} message ProcessedTransaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProcessedTransaction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ProcessedTransaction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ProcessedTransaction} ProcessedTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProcessedTransaction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ProcessedTransaction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.transactionEnvelope = $root.common.Envelope.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.validationCode = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ProcessedTransaction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ProcessedTransaction} ProcessedTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProcessedTransaction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ProcessedTransaction message.
             * @function verify
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProcessedTransaction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.transactionEnvelope != null && message.hasOwnProperty("transactionEnvelope")) {
                    var error = $root.common.Envelope.verify(message.transactionEnvelope);
                    if (error)
                        return "transactionEnvelope." + error;
                }
                if (message.validationCode != null && message.hasOwnProperty("validationCode"))
                    if (!$util.isInteger(message.validationCode))
                        return "validationCode: integer expected";
                return null;
            };
    
            /**
             * Creates a ProcessedTransaction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ProcessedTransaction} ProcessedTransaction
             */
            ProcessedTransaction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ProcessedTransaction)
                    return object;
                var message = new $root.protos.ProcessedTransaction();
                if (object.transactionEnvelope != null) {
                    if (typeof object.transactionEnvelope !== "object")
                        throw TypeError(".protos.ProcessedTransaction.transactionEnvelope: object expected");
                    message.transactionEnvelope = $root.common.Envelope.fromObject(object.transactionEnvelope);
                }
                if (object.validationCode != null)
                    message.validationCode = object.validationCode | 0;
                return message;
            };
    
            /**
             * Creates a plain object from a ProcessedTransaction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ProcessedTransaction
             * @static
             * @param {protos.ProcessedTransaction} message ProcessedTransaction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProcessedTransaction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.transactionEnvelope = null;
                    object.validationCode = 0;
                }
                if (message.transactionEnvelope != null && message.hasOwnProperty("transactionEnvelope"))
                    object.transactionEnvelope = $root.common.Envelope.toObject(message.transactionEnvelope, options);
                if (message.validationCode != null && message.hasOwnProperty("validationCode"))
                    object.validationCode = message.validationCode;
                return object;
            };
    
            /**
             * Converts this ProcessedTransaction to JSON.
             * @function toJSON
             * @memberof protos.ProcessedTransaction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProcessedTransaction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ProcessedTransaction;
        })();
    
        protos.Transaction = (function() {
    
            /**
             * Properties of a Transaction.
             * @memberof protos
             * @interface ITransaction
             * @property {Array.<protos.ITransactionAction>|null} [actions] Transaction actions
             */
    
            /**
             * Constructs a new Transaction.
             * @memberof protos
             * @classdesc Represents a Transaction.
             * @implements ITransaction
             * @constructor
             * @param {protos.ITransaction=} [properties] Properties to set
             */
            function Transaction(properties) {
                this.actions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Transaction actions.
             * @member {Array.<protos.ITransactionAction>} actions
             * @memberof protos.Transaction
             * @instance
             */
            Transaction.prototype.actions = $util.emptyArray;
    
            /**
             * Creates a new Transaction instance using the specified properties.
             * @function create
             * @memberof protos.Transaction
             * @static
             * @param {protos.ITransaction=} [properties] Properties to set
             * @returns {protos.Transaction} Transaction instance
             */
            Transaction.create = function create(properties) {
                return new Transaction(properties);
            };
    
            /**
             * Encodes the specified Transaction message. Does not implicitly {@link protos.Transaction.verify|verify} messages.
             * @function encode
             * @memberof protos.Transaction
             * @static
             * @param {protos.ITransaction} message Transaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transaction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.actions != null && message.actions.length)
                    for (var i = 0; i < message.actions.length; ++i)
                        $root.protos.TransactionAction.encode(message.actions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Transaction message, length delimited. Does not implicitly {@link protos.Transaction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.Transaction
             * @static
             * @param {protos.ITransaction} message Transaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Transaction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.Transaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.Transaction} Transaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transaction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.Transaction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.protos.TransactionAction.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Transaction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.Transaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.Transaction} Transaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transaction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Transaction message.
             * @function verify
             * @memberof protos.Transaction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Transaction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.actions != null && message.hasOwnProperty("actions")) {
                    if (!Array.isArray(message.actions))
                        return "actions: array expected";
                    for (var i = 0; i < message.actions.length; ++i) {
                        var error = $root.protos.TransactionAction.verify(message.actions[i]);
                        if (error)
                            return "actions." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.Transaction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.Transaction} Transaction
             */
            Transaction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.Transaction)
                    return object;
                var message = new $root.protos.Transaction();
                if (object.actions) {
                    if (!Array.isArray(object.actions))
                        throw TypeError(".protos.Transaction.actions: array expected");
                    message.actions = [];
                    for (var i = 0; i < object.actions.length; ++i) {
                        if (typeof object.actions[i] !== "object")
                            throw TypeError(".protos.Transaction.actions: object expected");
                        message.actions[i] = $root.protos.TransactionAction.fromObject(object.actions[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Transaction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.Transaction
             * @static
             * @param {protos.Transaction} message Transaction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Transaction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.actions = [];
                if (message.actions && message.actions.length) {
                    object.actions = [];
                    for (var j = 0; j < message.actions.length; ++j)
                        object.actions[j] = $root.protos.TransactionAction.toObject(message.actions[j], options);
                }
                return object;
            };
    
            /**
             * Converts this Transaction to JSON.
             * @function toJSON
             * @memberof protos.Transaction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Transaction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Transaction;
        })();
    
        protos.TransactionAction = (function() {
    
            /**
             * Properties of a TransactionAction.
             * @memberof protos
             * @interface ITransactionAction
             * @property {Uint8Array|null} [header] TransactionAction header
             * @property {Uint8Array|null} [payload] TransactionAction payload
             */
    
            /**
             * Constructs a new TransactionAction.
             * @memberof protos
             * @classdesc Represents a TransactionAction.
             * @implements ITransactionAction
             * @constructor
             * @param {protos.ITransactionAction=} [properties] Properties to set
             */
            function TransactionAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TransactionAction header.
             * @member {Uint8Array} header
             * @memberof protos.TransactionAction
             * @instance
             */
            TransactionAction.prototype.header = $util.newBuffer([]);
    
            /**
             * TransactionAction payload.
             * @member {Uint8Array} payload
             * @memberof protos.TransactionAction
             * @instance
             */
            TransactionAction.prototype.payload = $util.newBuffer([]);
    
            /**
             * Creates a new TransactionAction instance using the specified properties.
             * @function create
             * @memberof protos.TransactionAction
             * @static
             * @param {protos.ITransactionAction=} [properties] Properties to set
             * @returns {protos.TransactionAction} TransactionAction instance
             */
            TransactionAction.create = function create(properties) {
                return new TransactionAction(properties);
            };
    
            /**
             * Encodes the specified TransactionAction message. Does not implicitly {@link protos.TransactionAction.verify|verify} messages.
             * @function encode
             * @memberof protos.TransactionAction
             * @static
             * @param {protos.ITransactionAction} message TransactionAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.header != null && message.hasOwnProperty("header"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.header);
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                return writer;
            };
    
            /**
             * Encodes the specified TransactionAction message, length delimited. Does not implicitly {@link protos.TransactionAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.TransactionAction
             * @static
             * @param {protos.ITransactionAction} message TransactionAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TransactionAction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.TransactionAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.TransactionAction} TransactionAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.TransactionAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.header = reader.bytes();
                        break;
                    case 2:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TransactionAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.TransactionAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.TransactionAction} TransactionAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TransactionAction message.
             * @function verify
             * @memberof protos.TransactionAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransactionAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.header != null && message.hasOwnProperty("header"))
                    if (!(message.header && typeof message.header.length === "number" || $util.isString(message.header)))
                        return "header: buffer expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };
    
            /**
             * Creates a TransactionAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.TransactionAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.TransactionAction} TransactionAction
             */
            TransactionAction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.TransactionAction)
                    return object;
                var message = new $root.protos.TransactionAction();
                if (object.header != null)
                    if (typeof object.header === "string")
                        $util.base64.decode(object.header, message.header = $util.newBuffer($util.base64.length(object.header)), 0);
                    else if (object.header.length)
                        message.header = object.header;
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };
    
            /**
             * Creates a plain object from a TransactionAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.TransactionAction
             * @static
             * @param {protos.TransactionAction} message TransactionAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransactionAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.header = "";
                    else {
                        object.header = [];
                        if (options.bytes !== Array)
                            object.header = $util.newBuffer(object.header);
                    }
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                }
                if (message.header != null && message.hasOwnProperty("header"))
                    object.header = options.bytes === String ? $util.base64.encode(message.header, 0, message.header.length) : options.bytes === Array ? Array.prototype.slice.call(message.header) : message.header;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };
    
            /**
             * Converts this TransactionAction to JSON.
             * @function toJSON
             * @memberof protos.TransactionAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransactionAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TransactionAction;
        })();
    
        protos.ChaincodeActionPayload = (function() {
    
            /**
             * Properties of a ChaincodeActionPayload.
             * @memberof protos
             * @interface IChaincodeActionPayload
             * @property {Uint8Array|null} [chaincodeProposalPayload] ChaincodeActionPayload chaincodeProposalPayload
             * @property {protos.IChaincodeEndorsedAction|null} [action] ChaincodeActionPayload action
             */
    
            /**
             * Constructs a new ChaincodeActionPayload.
             * @memberof protos
             * @classdesc Represents a ChaincodeActionPayload.
             * @implements IChaincodeActionPayload
             * @constructor
             * @param {protos.IChaincodeActionPayload=} [properties] Properties to set
             */
            function ChaincodeActionPayload(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeActionPayload chaincodeProposalPayload.
             * @member {Uint8Array} chaincodeProposalPayload
             * @memberof protos.ChaincodeActionPayload
             * @instance
             */
            ChaincodeActionPayload.prototype.chaincodeProposalPayload = $util.newBuffer([]);
    
            /**
             * ChaincodeActionPayload action.
             * @member {protos.IChaincodeEndorsedAction|null|undefined} action
             * @memberof protos.ChaincodeActionPayload
             * @instance
             */
            ChaincodeActionPayload.prototype.action = null;
    
            /**
             * Creates a new ChaincodeActionPayload instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {protos.IChaincodeActionPayload=} [properties] Properties to set
             * @returns {protos.ChaincodeActionPayload} ChaincodeActionPayload instance
             */
            ChaincodeActionPayload.create = function create(properties) {
                return new ChaincodeActionPayload(properties);
            };
    
            /**
             * Encodes the specified ChaincodeActionPayload message. Does not implicitly {@link protos.ChaincodeActionPayload.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {protos.IChaincodeActionPayload} message ChaincodeActionPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeActionPayload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodeProposalPayload != null && message.hasOwnProperty("chaincodeProposalPayload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chaincodeProposalPayload);
                if (message.action != null && message.hasOwnProperty("action"))
                    $root.protos.ChaincodeEndorsedAction.encode(message.action, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeActionPayload message, length delimited. Does not implicitly {@link protos.ChaincodeActionPayload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {protos.IChaincodeActionPayload} message ChaincodeActionPayload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeActionPayload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeActionPayload message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeActionPayload} ChaincodeActionPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeActionPayload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeActionPayload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincodeProposalPayload = reader.bytes();
                        break;
                    case 2:
                        message.action = $root.protos.ChaincodeEndorsedAction.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeActionPayload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeActionPayload} ChaincodeActionPayload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeActionPayload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeActionPayload message.
             * @function verify
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeActionPayload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodeProposalPayload != null && message.hasOwnProperty("chaincodeProposalPayload"))
                    if (!(message.chaincodeProposalPayload && typeof message.chaincodeProposalPayload.length === "number" || $util.isString(message.chaincodeProposalPayload)))
                        return "chaincodeProposalPayload: buffer expected";
                if (message.action != null && message.hasOwnProperty("action")) {
                    var error = $root.protos.ChaincodeEndorsedAction.verify(message.action);
                    if (error)
                        return "action." + error;
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeActionPayload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeActionPayload} ChaincodeActionPayload
             */
            ChaincodeActionPayload.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeActionPayload)
                    return object;
                var message = new $root.protos.ChaincodeActionPayload();
                if (object.chaincodeProposalPayload != null)
                    if (typeof object.chaincodeProposalPayload === "string")
                        $util.base64.decode(object.chaincodeProposalPayload, message.chaincodeProposalPayload = $util.newBuffer($util.base64.length(object.chaincodeProposalPayload)), 0);
                    else if (object.chaincodeProposalPayload.length)
                        message.chaincodeProposalPayload = object.chaincodeProposalPayload;
                if (object.action != null) {
                    if (typeof object.action !== "object")
                        throw TypeError(".protos.ChaincodeActionPayload.action: object expected");
                    message.action = $root.protos.ChaincodeEndorsedAction.fromObject(object.action);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeActionPayload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeActionPayload
             * @static
             * @param {protos.ChaincodeActionPayload} message ChaincodeActionPayload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeActionPayload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.chaincodeProposalPayload = "";
                    else {
                        object.chaincodeProposalPayload = [];
                        if (options.bytes !== Array)
                            object.chaincodeProposalPayload = $util.newBuffer(object.chaincodeProposalPayload);
                    }
                    object.action = null;
                }
                if (message.chaincodeProposalPayload != null && message.hasOwnProperty("chaincodeProposalPayload"))
                    object.chaincodeProposalPayload = options.bytes === String ? $util.base64.encode(message.chaincodeProposalPayload, 0, message.chaincodeProposalPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.chaincodeProposalPayload) : message.chaincodeProposalPayload;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = $root.protos.ChaincodeEndorsedAction.toObject(message.action, options);
                return object;
            };
    
            /**
             * Converts this ChaincodeActionPayload to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeActionPayload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeActionPayload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeActionPayload;
        })();
    
        protos.ChaincodeEndorsedAction = (function() {
    
            /**
             * Properties of a ChaincodeEndorsedAction.
             * @memberof protos
             * @interface IChaincodeEndorsedAction
             * @property {Uint8Array|null} [proposalResponsePayload] ChaincodeEndorsedAction proposalResponsePayload
             * @property {Array.<protos.IEndorsement>|null} [endorsements] ChaincodeEndorsedAction endorsements
             */
    
            /**
             * Constructs a new ChaincodeEndorsedAction.
             * @memberof protos
             * @classdesc Represents a ChaincodeEndorsedAction.
             * @implements IChaincodeEndorsedAction
             * @constructor
             * @param {protos.IChaincodeEndorsedAction=} [properties] Properties to set
             */
            function ChaincodeEndorsedAction(properties) {
                this.endorsements = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeEndorsedAction proposalResponsePayload.
             * @member {Uint8Array} proposalResponsePayload
             * @memberof protos.ChaincodeEndorsedAction
             * @instance
             */
            ChaincodeEndorsedAction.prototype.proposalResponsePayload = $util.newBuffer([]);
    
            /**
             * ChaincodeEndorsedAction endorsements.
             * @member {Array.<protos.IEndorsement>} endorsements
             * @memberof protos.ChaincodeEndorsedAction
             * @instance
             */
            ChaincodeEndorsedAction.prototype.endorsements = $util.emptyArray;
    
            /**
             * Creates a new ChaincodeEndorsedAction instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {protos.IChaincodeEndorsedAction=} [properties] Properties to set
             * @returns {protos.ChaincodeEndorsedAction} ChaincodeEndorsedAction instance
             */
            ChaincodeEndorsedAction.create = function create(properties) {
                return new ChaincodeEndorsedAction(properties);
            };
    
            /**
             * Encodes the specified ChaincodeEndorsedAction message. Does not implicitly {@link protos.ChaincodeEndorsedAction.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {protos.IChaincodeEndorsedAction} message ChaincodeEndorsedAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEndorsedAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.proposalResponsePayload != null && message.hasOwnProperty("proposalResponsePayload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.proposalResponsePayload);
                if (message.endorsements != null && message.endorsements.length)
                    for (var i = 0; i < message.endorsements.length; ++i)
                        $root.protos.Endorsement.encode(message.endorsements[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeEndorsedAction message, length delimited. Does not implicitly {@link protos.ChaincodeEndorsedAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {protos.IChaincodeEndorsedAction} message ChaincodeEndorsedAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEndorsedAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeEndorsedAction message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeEndorsedAction} ChaincodeEndorsedAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEndorsedAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeEndorsedAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.proposalResponsePayload = reader.bytes();
                        break;
                    case 2:
                        if (!(message.endorsements && message.endorsements.length))
                            message.endorsements = [];
                        message.endorsements.push($root.protos.Endorsement.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeEndorsedAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeEndorsedAction} ChaincodeEndorsedAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEndorsedAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeEndorsedAction message.
             * @function verify
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeEndorsedAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.proposalResponsePayload != null && message.hasOwnProperty("proposalResponsePayload"))
                    if (!(message.proposalResponsePayload && typeof message.proposalResponsePayload.length === "number" || $util.isString(message.proposalResponsePayload)))
                        return "proposalResponsePayload: buffer expected";
                if (message.endorsements != null && message.hasOwnProperty("endorsements")) {
                    if (!Array.isArray(message.endorsements))
                        return "endorsements: array expected";
                    for (var i = 0; i < message.endorsements.length; ++i) {
                        var error = $root.protos.Endorsement.verify(message.endorsements[i]);
                        if (error)
                            return "endorsements." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeEndorsedAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeEndorsedAction} ChaincodeEndorsedAction
             */
            ChaincodeEndorsedAction.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeEndorsedAction)
                    return object;
                var message = new $root.protos.ChaincodeEndorsedAction();
                if (object.proposalResponsePayload != null)
                    if (typeof object.proposalResponsePayload === "string")
                        $util.base64.decode(object.proposalResponsePayload, message.proposalResponsePayload = $util.newBuffer($util.base64.length(object.proposalResponsePayload)), 0);
                    else if (object.proposalResponsePayload.length)
                        message.proposalResponsePayload = object.proposalResponsePayload;
                if (object.endorsements) {
                    if (!Array.isArray(object.endorsements))
                        throw TypeError(".protos.ChaincodeEndorsedAction.endorsements: array expected");
                    message.endorsements = [];
                    for (var i = 0; i < object.endorsements.length; ++i) {
                        if (typeof object.endorsements[i] !== "object")
                            throw TypeError(".protos.ChaincodeEndorsedAction.endorsements: object expected");
                        message.endorsements[i] = $root.protos.Endorsement.fromObject(object.endorsements[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeEndorsedAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeEndorsedAction
             * @static
             * @param {protos.ChaincodeEndorsedAction} message ChaincodeEndorsedAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeEndorsedAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.endorsements = [];
                if (options.defaults)
                    if (options.bytes === String)
                        object.proposalResponsePayload = "";
                    else {
                        object.proposalResponsePayload = [];
                        if (options.bytes !== Array)
                            object.proposalResponsePayload = $util.newBuffer(object.proposalResponsePayload);
                    }
                if (message.proposalResponsePayload != null && message.hasOwnProperty("proposalResponsePayload"))
                    object.proposalResponsePayload = options.bytes === String ? $util.base64.encode(message.proposalResponsePayload, 0, message.proposalResponsePayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposalResponsePayload) : message.proposalResponsePayload;
                if (message.endorsements && message.endorsements.length) {
                    object.endorsements = [];
                    for (var j = 0; j < message.endorsements.length; ++j)
                        object.endorsements[j] = $root.protos.Endorsement.toObject(message.endorsements[j], options);
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeEndorsedAction to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeEndorsedAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeEndorsedAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeEndorsedAction;
        })();
    
        /**
         * TxValidationCode enum.
         * @name protos.TxValidationCode
         * @enum {string}
         * @property {number} VALID=0 VALID value
         * @property {number} NIL_ENVELOPE=1 NIL_ENVELOPE value
         * @property {number} BAD_PAYLOAD=2 BAD_PAYLOAD value
         * @property {number} BAD_COMMON_HEADER=3 BAD_COMMON_HEADER value
         * @property {number} BAD_CREATOR_SIGNATURE=4 BAD_CREATOR_SIGNATURE value
         * @property {number} INVALID_ENDORSER_TRANSACTION=5 INVALID_ENDORSER_TRANSACTION value
         * @property {number} INVALID_CONFIG_TRANSACTION=6 INVALID_CONFIG_TRANSACTION value
         * @property {number} UNSUPPORTED_TX_PAYLOAD=7 UNSUPPORTED_TX_PAYLOAD value
         * @property {number} BAD_PROPOSAL_TXID=8 BAD_PROPOSAL_TXID value
         * @property {number} DUPLICATE_TXID=9 DUPLICATE_TXID value
         * @property {number} ENDORSEMENT_POLICY_FAILURE=10 ENDORSEMENT_POLICY_FAILURE value
         * @property {number} MVCC_READ_CONFLICT=11 MVCC_READ_CONFLICT value
         * @property {number} PHANTOM_READ_CONFLICT=12 PHANTOM_READ_CONFLICT value
         * @property {number} UNKNOWN_TX_TYPE=13 UNKNOWN_TX_TYPE value
         * @property {number} TARGET_CHAIN_NOT_FOUND=14 TARGET_CHAIN_NOT_FOUND value
         * @property {number} MARSHAL_TX_ERROR=15 MARSHAL_TX_ERROR value
         * @property {number} NIL_TXACTION=16 NIL_TXACTION value
         * @property {number} EXPIRED_CHAINCODE=17 EXPIRED_CHAINCODE value
         * @property {number} CHAINCODE_VERSION_CONFLICT=18 CHAINCODE_VERSION_CONFLICT value
         * @property {number} BAD_HEADER_EXTENSION=19 BAD_HEADER_EXTENSION value
         * @property {number} BAD_CHANNEL_HEADER=20 BAD_CHANNEL_HEADER value
         * @property {number} BAD_RESPONSE_PAYLOAD=21 BAD_RESPONSE_PAYLOAD value
         * @property {number} BAD_RWSET=22 BAD_RWSET value
         * @property {number} ILLEGAL_WRITESET=23 ILLEGAL_WRITESET value
         * @property {number} INVALID_WRITESET=24 INVALID_WRITESET value
         * @property {number} INVALID_CHAINCODE=25 INVALID_CHAINCODE value
         * @property {number} NOT_VALIDATED=254 NOT_VALIDATED value
         * @property {number} INVALID_OTHER_REASON=255 INVALID_OTHER_REASON value
         */
        protos.TxValidationCode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "VALID"] = 0;
            values[valuesById[1] = "NIL_ENVELOPE"] = 1;
            values[valuesById[2] = "BAD_PAYLOAD"] = 2;
            values[valuesById[3] = "BAD_COMMON_HEADER"] = 3;
            values[valuesById[4] = "BAD_CREATOR_SIGNATURE"] = 4;
            values[valuesById[5] = "INVALID_ENDORSER_TRANSACTION"] = 5;
            values[valuesById[6] = "INVALID_CONFIG_TRANSACTION"] = 6;
            values[valuesById[7] = "UNSUPPORTED_TX_PAYLOAD"] = 7;
            values[valuesById[8] = "BAD_PROPOSAL_TXID"] = 8;
            values[valuesById[9] = "DUPLICATE_TXID"] = 9;
            values[valuesById[10] = "ENDORSEMENT_POLICY_FAILURE"] = 10;
            values[valuesById[11] = "MVCC_READ_CONFLICT"] = 11;
            values[valuesById[12] = "PHANTOM_READ_CONFLICT"] = 12;
            values[valuesById[13] = "UNKNOWN_TX_TYPE"] = 13;
            values[valuesById[14] = "TARGET_CHAIN_NOT_FOUND"] = 14;
            values[valuesById[15] = "MARSHAL_TX_ERROR"] = 15;
            values[valuesById[16] = "NIL_TXACTION"] = 16;
            values[valuesById[17] = "EXPIRED_CHAINCODE"] = 17;
            values[valuesById[18] = "CHAINCODE_VERSION_CONFLICT"] = 18;
            values[valuesById[19] = "BAD_HEADER_EXTENSION"] = 19;
            values[valuesById[20] = "BAD_CHANNEL_HEADER"] = 20;
            values[valuesById[21] = "BAD_RESPONSE_PAYLOAD"] = 21;
            values[valuesById[22] = "BAD_RWSET"] = 22;
            values[valuesById[23] = "ILLEGAL_WRITESET"] = 23;
            values[valuesById[24] = "INVALID_WRITESET"] = 24;
            values[valuesById[25] = "INVALID_CHAINCODE"] = 25;
            values[valuesById[254] = "NOT_VALIDATED"] = 254;
            values[valuesById[255] = "INVALID_OTHER_REASON"] = 255;
            return values;
        })();
    
        /**
         * MetaDataKeys enum.
         * @name protos.MetaDataKeys
         * @enum {string}
         * @property {number} VALIDATION_PARAMETER=0 VALIDATION_PARAMETER value
         * @property {number} VALIDATION_PARAMETER_V2=1 VALIDATION_PARAMETER_V2 value
         */
        protos.MetaDataKeys = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "VALIDATION_PARAMETER"] = 0;
            values[valuesById[1] = "VALIDATION_PARAMETER_V2"] = 1;
            return values;
        })();
    
        protos.ApplicationPolicy = (function() {
    
            /**
             * Properties of an ApplicationPolicy.
             * @memberof protos
             * @interface IApplicationPolicy
             * @property {common.ISignaturePolicyEnvelope|null} [signaturePolicy] ApplicationPolicy signaturePolicy
             * @property {string|null} [channelConfigPolicyReference] ApplicationPolicy channelConfigPolicyReference
             */
    
            /**
             * Constructs a new ApplicationPolicy.
             * @memberof protos
             * @classdesc Represents an ApplicationPolicy.
             * @implements IApplicationPolicy
             * @constructor
             * @param {protos.IApplicationPolicy=} [properties] Properties to set
             */
            function ApplicationPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ApplicationPolicy signaturePolicy.
             * @member {common.ISignaturePolicyEnvelope|null|undefined} signaturePolicy
             * @memberof protos.ApplicationPolicy
             * @instance
             */
            ApplicationPolicy.prototype.signaturePolicy = null;
    
            /**
             * ApplicationPolicy channelConfigPolicyReference.
             * @member {string} channelConfigPolicyReference
             * @memberof protos.ApplicationPolicy
             * @instance
             */
            ApplicationPolicy.prototype.channelConfigPolicyReference = "";
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * ApplicationPolicy Type.
             * @member {"signaturePolicy"|"channelConfigPolicyReference"|undefined} Type
             * @memberof protos.ApplicationPolicy
             * @instance
             */
            Object.defineProperty(ApplicationPolicy.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["signaturePolicy", "channelConfigPolicyReference"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new ApplicationPolicy instance using the specified properties.
             * @function create
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {protos.IApplicationPolicy=} [properties] Properties to set
             * @returns {protos.ApplicationPolicy} ApplicationPolicy instance
             */
            ApplicationPolicy.create = function create(properties) {
                return new ApplicationPolicy(properties);
            };
    
            /**
             * Encodes the specified ApplicationPolicy message. Does not implicitly {@link protos.ApplicationPolicy.verify|verify} messages.
             * @function encode
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {protos.IApplicationPolicy} message ApplicationPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplicationPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.signaturePolicy != null && message.hasOwnProperty("signaturePolicy"))
                    $root.common.SignaturePolicyEnvelope.encode(message.signaturePolicy, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.channelConfigPolicyReference != null && message.hasOwnProperty("channelConfigPolicyReference"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.channelConfigPolicyReference);
                return writer;
            };
    
            /**
             * Encodes the specified ApplicationPolicy message, length delimited. Does not implicitly {@link protos.ApplicationPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {protos.IApplicationPolicy} message ApplicationPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApplicationPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ApplicationPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ApplicationPolicy} ApplicationPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplicationPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ApplicationPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.signaturePolicy = $root.common.SignaturePolicyEnvelope.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.channelConfigPolicyReference = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ApplicationPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ApplicationPolicy} ApplicationPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApplicationPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ApplicationPolicy message.
             * @function verify
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApplicationPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.signaturePolicy != null && message.hasOwnProperty("signaturePolicy")) {
                    properties.Type = 1;
                    {
                        var error = $root.common.SignaturePolicyEnvelope.verify(message.signaturePolicy);
                        if (error)
                            return "signaturePolicy." + error;
                    }
                }
                if (message.channelConfigPolicyReference != null && message.hasOwnProperty("channelConfigPolicyReference")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    if (!$util.isString(message.channelConfigPolicyReference))
                        return "channelConfigPolicyReference: string expected";
                }
                return null;
            };
    
            /**
             * Creates an ApplicationPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ApplicationPolicy} ApplicationPolicy
             */
            ApplicationPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ApplicationPolicy)
                    return object;
                var message = new $root.protos.ApplicationPolicy();
                if (object.signaturePolicy != null) {
                    if (typeof object.signaturePolicy !== "object")
                        throw TypeError(".protos.ApplicationPolicy.signaturePolicy: object expected");
                    message.signaturePolicy = $root.common.SignaturePolicyEnvelope.fromObject(object.signaturePolicy);
                }
                if (object.channelConfigPolicyReference != null)
                    message.channelConfigPolicyReference = String(object.channelConfigPolicyReference);
                return message;
            };
    
            /**
             * Creates a plain object from an ApplicationPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ApplicationPolicy
             * @static
             * @param {protos.ApplicationPolicy} message ApplicationPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ApplicationPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.signaturePolicy != null && message.hasOwnProperty("signaturePolicy")) {
                    object.signaturePolicy = $root.common.SignaturePolicyEnvelope.toObject(message.signaturePolicy, options);
                    if (options.oneofs)
                        object.Type = "signaturePolicy";
                }
                if (message.channelConfigPolicyReference != null && message.hasOwnProperty("channelConfigPolicyReference")) {
                    object.channelConfigPolicyReference = message.channelConfigPolicyReference;
                    if (options.oneofs)
                        object.Type = "channelConfigPolicyReference";
                }
                return object;
            };
    
            /**
             * Converts this ApplicationPolicy to JSON.
             * @function toJSON
             * @memberof protos.ApplicationPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ApplicationPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ApplicationPolicy;
        })();
    
        protos.ChaincodeIdentifier = (function() {
    
            /**
             * Properties of a ChaincodeIdentifier.
             * @memberof protos
             * @interface IChaincodeIdentifier
             * @property {Uint8Array|null} [hash] ChaincodeIdentifier hash
             * @property {string|null} [version] ChaincodeIdentifier version
             */
    
            /**
             * Constructs a new ChaincodeIdentifier.
             * @memberof protos
             * @classdesc Represents a ChaincodeIdentifier.
             * @implements IChaincodeIdentifier
             * @constructor
             * @param {protos.IChaincodeIdentifier=} [properties] Properties to set
             */
            function ChaincodeIdentifier(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeIdentifier hash.
             * @member {Uint8Array} hash
             * @memberof protos.ChaincodeIdentifier
             * @instance
             */
            ChaincodeIdentifier.prototype.hash = $util.newBuffer([]);
    
            /**
             * ChaincodeIdentifier version.
             * @member {string} version
             * @memberof protos.ChaincodeIdentifier
             * @instance
             */
            ChaincodeIdentifier.prototype.version = "";
    
            /**
             * Creates a new ChaincodeIdentifier instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {protos.IChaincodeIdentifier=} [properties] Properties to set
             * @returns {protos.ChaincodeIdentifier} ChaincodeIdentifier instance
             */
            ChaincodeIdentifier.create = function create(properties) {
                return new ChaincodeIdentifier(properties);
            };
    
            /**
             * Encodes the specified ChaincodeIdentifier message. Does not implicitly {@link protos.ChaincodeIdentifier.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {protos.IChaincodeIdentifier} message ChaincodeIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeIdentifier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && message.hasOwnProperty("hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeIdentifier message, length delimited. Does not implicitly {@link protos.ChaincodeIdentifier.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {protos.IChaincodeIdentifier} message ChaincodeIdentifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeIdentifier message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeIdentifier} ChaincodeIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeIdentifier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeIdentifier();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hash = reader.bytes();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeIdentifier message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeIdentifier} ChaincodeIdentifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeIdentifier.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeIdentifier message.
             * @function verify
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeIdentifier.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeIdentifier message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeIdentifier} ChaincodeIdentifier
             */
            ChaincodeIdentifier.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeIdentifier)
                    return object;
                var message = new $root.protos.ChaincodeIdentifier();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.version != null)
                    message.version = String(object.version);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeIdentifier message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeIdentifier
             * @static
             * @param {protos.ChaincodeIdentifier} message ChaincodeIdentifier
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeIdentifier.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    object.version = "";
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                return object;
            };
    
            /**
             * Converts this ChaincodeIdentifier to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeIdentifier
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeIdentifier.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeIdentifier;
        })();
    
        protos.ChaincodeValidation = (function() {
    
            /**
             * Properties of a ChaincodeValidation.
             * @memberof protos
             * @interface IChaincodeValidation
             * @property {string|null} [name] ChaincodeValidation name
             * @property {Uint8Array|null} [argument] ChaincodeValidation argument
             */
    
            /**
             * Constructs a new ChaincodeValidation.
             * @memberof protos
             * @classdesc Represents a ChaincodeValidation.
             * @implements IChaincodeValidation
             * @constructor
             * @param {protos.IChaincodeValidation=} [properties] Properties to set
             */
            function ChaincodeValidation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeValidation name.
             * @member {string} name
             * @memberof protos.ChaincodeValidation
             * @instance
             */
            ChaincodeValidation.prototype.name = "";
    
            /**
             * ChaincodeValidation argument.
             * @member {Uint8Array} argument
             * @memberof protos.ChaincodeValidation
             * @instance
             */
            ChaincodeValidation.prototype.argument = $util.newBuffer([]);
    
            /**
             * Creates a new ChaincodeValidation instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {protos.IChaincodeValidation=} [properties] Properties to set
             * @returns {protos.ChaincodeValidation} ChaincodeValidation instance
             */
            ChaincodeValidation.create = function create(properties) {
                return new ChaincodeValidation(properties);
            };
    
            /**
             * Encodes the specified ChaincodeValidation message. Does not implicitly {@link protos.ChaincodeValidation.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {protos.IChaincodeValidation} message ChaincodeValidation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeValidation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.argument != null && message.hasOwnProperty("argument"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.argument);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeValidation message, length delimited. Does not implicitly {@link protos.ChaincodeValidation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {protos.IChaincodeValidation} message ChaincodeValidation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeValidation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeValidation message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeValidation} ChaincodeValidation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeValidation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeValidation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.argument = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeValidation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeValidation} ChaincodeValidation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeValidation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeValidation message.
             * @function verify
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeValidation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.argument != null && message.hasOwnProperty("argument"))
                    if (!(message.argument && typeof message.argument.length === "number" || $util.isString(message.argument)))
                        return "argument: buffer expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeValidation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeValidation} ChaincodeValidation
             */
            ChaincodeValidation.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeValidation)
                    return object;
                var message = new $root.protos.ChaincodeValidation();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.argument != null)
                    if (typeof object.argument === "string")
                        $util.base64.decode(object.argument, message.argument = $util.newBuffer($util.base64.length(object.argument)), 0);
                    else if (object.argument.length)
                        message.argument = object.argument;
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeValidation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeValidation
             * @static
             * @param {protos.ChaincodeValidation} message ChaincodeValidation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeValidation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    if (options.bytes === String)
                        object.argument = "";
                    else {
                        object.argument = [];
                        if (options.bytes !== Array)
                            object.argument = $util.newBuffer(object.argument);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.argument != null && message.hasOwnProperty("argument"))
                    object.argument = options.bytes === String ? $util.base64.encode(message.argument, 0, message.argument.length) : options.bytes === Array ? Array.prototype.slice.call(message.argument) : message.argument;
                return object;
            };
    
            /**
             * Converts this ChaincodeValidation to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeValidation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeValidation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeValidation;
        })();
    
        protos.VSCCArgs = (function() {
    
            /**
             * Properties of a VSCCArgs.
             * @memberof protos
             * @interface IVSCCArgs
             * @property {string|null} [endorsementPolicyRef] VSCCArgs endorsementPolicyRef
             */
    
            /**
             * Constructs a new VSCCArgs.
             * @memberof protos
             * @classdesc Represents a VSCCArgs.
             * @implements IVSCCArgs
             * @constructor
             * @param {protos.IVSCCArgs=} [properties] Properties to set
             */
            function VSCCArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * VSCCArgs endorsementPolicyRef.
             * @member {string} endorsementPolicyRef
             * @memberof protos.VSCCArgs
             * @instance
             */
            VSCCArgs.prototype.endorsementPolicyRef = "";
    
            /**
             * Creates a new VSCCArgs instance using the specified properties.
             * @function create
             * @memberof protos.VSCCArgs
             * @static
             * @param {protos.IVSCCArgs=} [properties] Properties to set
             * @returns {protos.VSCCArgs} VSCCArgs instance
             */
            VSCCArgs.create = function create(properties) {
                return new VSCCArgs(properties);
            };
    
            /**
             * Encodes the specified VSCCArgs message. Does not implicitly {@link protos.VSCCArgs.verify|verify} messages.
             * @function encode
             * @memberof protos.VSCCArgs
             * @static
             * @param {protos.IVSCCArgs} message VSCCArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VSCCArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endorsementPolicyRef != null && message.hasOwnProperty("endorsementPolicyRef"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.endorsementPolicyRef);
                return writer;
            };
    
            /**
             * Encodes the specified VSCCArgs message, length delimited. Does not implicitly {@link protos.VSCCArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.VSCCArgs
             * @static
             * @param {protos.IVSCCArgs} message VSCCArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VSCCArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a VSCCArgs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.VSCCArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.VSCCArgs} VSCCArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VSCCArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.VSCCArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.endorsementPolicyRef = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a VSCCArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.VSCCArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.VSCCArgs} VSCCArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VSCCArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a VSCCArgs message.
             * @function verify
             * @memberof protos.VSCCArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VSCCArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endorsementPolicyRef != null && message.hasOwnProperty("endorsementPolicyRef"))
                    if (!$util.isString(message.endorsementPolicyRef))
                        return "endorsementPolicyRef: string expected";
                return null;
            };
    
            /**
             * Creates a VSCCArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.VSCCArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.VSCCArgs} VSCCArgs
             */
            VSCCArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.VSCCArgs)
                    return object;
                var message = new $root.protos.VSCCArgs();
                if (object.endorsementPolicyRef != null)
                    message.endorsementPolicyRef = String(object.endorsementPolicyRef);
                return message;
            };
    
            /**
             * Creates a plain object from a VSCCArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.VSCCArgs
             * @static
             * @param {protos.VSCCArgs} message VSCCArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VSCCArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.endorsementPolicyRef = "";
                if (message.endorsementPolicyRef != null && message.hasOwnProperty("endorsementPolicyRef"))
                    object.endorsementPolicyRef = message.endorsementPolicyRef;
                return object;
            };
    
            /**
             * Converts this VSCCArgs to JSON.
             * @function toJSON
             * @memberof protos.VSCCArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VSCCArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return VSCCArgs;
        })();
    
        protos.ChaincodeEndorsement = (function() {
    
            /**
             * Properties of a ChaincodeEndorsement.
             * @memberof protos
             * @interface IChaincodeEndorsement
             * @property {string|null} [name] ChaincodeEndorsement name
             */
    
            /**
             * Constructs a new ChaincodeEndorsement.
             * @memberof protos
             * @classdesc Represents a ChaincodeEndorsement.
             * @implements IChaincodeEndorsement
             * @constructor
             * @param {protos.IChaincodeEndorsement=} [properties] Properties to set
             */
            function ChaincodeEndorsement(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeEndorsement name.
             * @member {string} name
             * @memberof protos.ChaincodeEndorsement
             * @instance
             */
            ChaincodeEndorsement.prototype.name = "";
    
            /**
             * Creates a new ChaincodeEndorsement instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {protos.IChaincodeEndorsement=} [properties] Properties to set
             * @returns {protos.ChaincodeEndorsement} ChaincodeEndorsement instance
             */
            ChaincodeEndorsement.create = function create(properties) {
                return new ChaincodeEndorsement(properties);
            };
    
            /**
             * Encodes the specified ChaincodeEndorsement message. Does not implicitly {@link protos.ChaincodeEndorsement.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {protos.IChaincodeEndorsement} message ChaincodeEndorsement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEndorsement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeEndorsement message, length delimited. Does not implicitly {@link protos.ChaincodeEndorsement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {protos.IChaincodeEndorsement} message ChaincodeEndorsement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEndorsement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeEndorsement message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeEndorsement} ChaincodeEndorsement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEndorsement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeEndorsement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeEndorsement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeEndorsement} ChaincodeEndorsement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEndorsement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeEndorsement message.
             * @function verify
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeEndorsement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeEndorsement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeEndorsement} ChaincodeEndorsement
             */
            ChaincodeEndorsement.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeEndorsement)
                    return object;
                var message = new $root.protos.ChaincodeEndorsement();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeEndorsement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeEndorsement
             * @static
             * @param {protos.ChaincodeEndorsement} message ChaincodeEndorsement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeEndorsement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this ChaincodeEndorsement to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeEndorsement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeEndorsement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeEndorsement;
        })();
    
        protos.ConfigTree = (function() {
    
            /**
             * Properties of a ConfigTree.
             * @memberof protos
             * @interface IConfigTree
             * @property {common.IConfig|null} [channelConfig] ConfigTree channelConfig
             * @property {common.IConfig|null} [resourcesConfig] ConfigTree resourcesConfig
             */
    
            /**
             * Constructs a new ConfigTree.
             * @memberof protos
             * @classdesc Represents a ConfigTree.
             * @implements IConfigTree
             * @constructor
             * @param {protos.IConfigTree=} [properties] Properties to set
             */
            function ConfigTree(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigTree channelConfig.
             * @member {common.IConfig|null|undefined} channelConfig
             * @memberof protos.ConfigTree
             * @instance
             */
            ConfigTree.prototype.channelConfig = null;
    
            /**
             * ConfigTree resourcesConfig.
             * @member {common.IConfig|null|undefined} resourcesConfig
             * @memberof protos.ConfigTree
             * @instance
             */
            ConfigTree.prototype.resourcesConfig = null;
    
            /**
             * Creates a new ConfigTree instance using the specified properties.
             * @function create
             * @memberof protos.ConfigTree
             * @static
             * @param {protos.IConfigTree=} [properties] Properties to set
             * @returns {protos.ConfigTree} ConfigTree instance
             */
            ConfigTree.create = function create(properties) {
                return new ConfigTree(properties);
            };
    
            /**
             * Encodes the specified ConfigTree message. Does not implicitly {@link protos.ConfigTree.verify|verify} messages.
             * @function encode
             * @memberof protos.ConfigTree
             * @static
             * @param {protos.IConfigTree} message ConfigTree message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigTree.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channelConfig != null && message.hasOwnProperty("channelConfig"))
                    $root.common.Config.encode(message.channelConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.resourcesConfig != null && message.hasOwnProperty("resourcesConfig"))
                    $root.common.Config.encode(message.resourcesConfig, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigTree message, length delimited. Does not implicitly {@link protos.ConfigTree.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ConfigTree
             * @static
             * @param {protos.IConfigTree} message ConfigTree message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigTree.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigTree message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ConfigTree
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ConfigTree} ConfigTree
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigTree.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ConfigTree();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channelConfig = $root.common.Config.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.resourcesConfig = $root.common.Config.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigTree message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ConfigTree
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ConfigTree} ConfigTree
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigTree.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigTree message.
             * @function verify
             * @memberof protos.ConfigTree
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigTree.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channelConfig != null && message.hasOwnProperty("channelConfig")) {
                    var error = $root.common.Config.verify(message.channelConfig);
                    if (error)
                        return "channelConfig." + error;
                }
                if (message.resourcesConfig != null && message.hasOwnProperty("resourcesConfig")) {
                    var error = $root.common.Config.verify(message.resourcesConfig);
                    if (error)
                        return "resourcesConfig." + error;
                }
                return null;
            };
    
            /**
             * Creates a ConfigTree message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ConfigTree
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ConfigTree} ConfigTree
             */
            ConfigTree.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ConfigTree)
                    return object;
                var message = new $root.protos.ConfigTree();
                if (object.channelConfig != null) {
                    if (typeof object.channelConfig !== "object")
                        throw TypeError(".protos.ConfigTree.channelConfig: object expected");
                    message.channelConfig = $root.common.Config.fromObject(object.channelConfig);
                }
                if (object.resourcesConfig != null) {
                    if (typeof object.resourcesConfig !== "object")
                        throw TypeError(".protos.ConfigTree.resourcesConfig: object expected");
                    message.resourcesConfig = $root.common.Config.fromObject(object.resourcesConfig);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigTree message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ConfigTree
             * @static
             * @param {protos.ConfigTree} message ConfigTree
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigTree.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channelConfig = null;
                    object.resourcesConfig = null;
                }
                if (message.channelConfig != null && message.hasOwnProperty("channelConfig"))
                    object.channelConfig = $root.common.Config.toObject(message.channelConfig, options);
                if (message.resourcesConfig != null && message.hasOwnProperty("resourcesConfig"))
                    object.resourcesConfig = $root.common.Config.toObject(message.resourcesConfig, options);
                return object;
            };
    
            /**
             * Converts this ConfigTree to JSON.
             * @function toJSON
             * @memberof protos.ConfigTree
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigTree.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigTree;
        })();
    
        protos.ChaincodeMessage = (function() {
    
            /**
             * Properties of a ChaincodeMessage.
             * @memberof protos
             * @interface IChaincodeMessage
             * @property {protos.ChaincodeMessage.Type|null} [type] ChaincodeMessage type
             * @property {google.protobuf.ITimestamp|null} [timestamp] ChaincodeMessage timestamp
             * @property {Uint8Array|null} [payload] ChaincodeMessage payload
             * @property {string|null} [txid] ChaincodeMessage txid
             * @property {protos.ISignedProposal|null} [proposal] ChaincodeMessage proposal
             * @property {protos.IChaincodeEvent|null} [chaincodeEvent] ChaincodeMessage chaincodeEvent
             * @property {string|null} [channelId] ChaincodeMessage channelId
             */
    
            /**
             * Constructs a new ChaincodeMessage.
             * @memberof protos
             * @classdesc Represents a ChaincodeMessage.
             * @implements IChaincodeMessage
             * @constructor
             * @param {protos.IChaincodeMessage=} [properties] Properties to set
             */
            function ChaincodeMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeMessage type.
             * @member {protos.ChaincodeMessage.Type} type
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.type = 0;
    
            /**
             * ChaincodeMessage timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.timestamp = null;
    
            /**
             * ChaincodeMessage payload.
             * @member {Uint8Array} payload
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.payload = $util.newBuffer([]);
    
            /**
             * ChaincodeMessage txid.
             * @member {string} txid
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.txid = "";
    
            /**
             * ChaincodeMessage proposal.
             * @member {protos.ISignedProposal|null|undefined} proposal
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.proposal = null;
    
            /**
             * ChaincodeMessage chaincodeEvent.
             * @member {protos.IChaincodeEvent|null|undefined} chaincodeEvent
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.chaincodeEvent = null;
    
            /**
             * ChaincodeMessage channelId.
             * @member {string} channelId
             * @memberof protos.ChaincodeMessage
             * @instance
             */
            ChaincodeMessage.prototype.channelId = "";
    
            /**
             * Creates a new ChaincodeMessage instance using the specified properties.
             * @function create
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {protos.IChaincodeMessage=} [properties] Properties to set
             * @returns {protos.ChaincodeMessage} ChaincodeMessage instance
             */
            ChaincodeMessage.create = function create(properties) {
                return new ChaincodeMessage(properties);
            };
    
            /**
             * Encodes the specified ChaincodeMessage message. Does not implicitly {@link protos.ChaincodeMessage.verify|verify} messages.
             * @function encode
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {protos.IChaincodeMessage} message ChaincodeMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
                if (message.txid != null && message.hasOwnProperty("txid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.txid);
                if (message.proposal != null && message.hasOwnProperty("proposal"))
                    $root.protos.SignedProposal.encode(message.proposal, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.chaincodeEvent != null && message.hasOwnProperty("chaincodeEvent"))
                    $root.protos.ChaincodeEvent.encode(message.chaincodeEvent, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.channelId);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeMessage message, length delimited. Does not implicitly {@link protos.ChaincodeMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {protos.IChaincodeMessage} message ChaincodeMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeMessage message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ChaincodeMessage} ChaincodeMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ChaincodeMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.payload = reader.bytes();
                        break;
                    case 4:
                        message.txid = reader.string();
                        break;
                    case 5:
                        message.proposal = $root.protos.SignedProposal.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.chaincodeEvent = $root.protos.ChaincodeEvent.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.channelId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ChaincodeMessage} ChaincodeMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeMessage message.
             * @function verify
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                        break;
                    }
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.txid != null && message.hasOwnProperty("txid"))
                    if (!$util.isString(message.txid))
                        return "txid: string expected";
                if (message.proposal != null && message.hasOwnProperty("proposal")) {
                    var error = $root.protos.SignedProposal.verify(message.proposal);
                    if (error)
                        return "proposal." + error;
                }
                if (message.chaincodeEvent != null && message.hasOwnProperty("chaincodeEvent")) {
                    var error = $root.protos.ChaincodeEvent.verify(message.chaincodeEvent);
                    if (error)
                        return "chaincodeEvent." + error;
                }
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (!$util.isString(message.channelId))
                        return "channelId: string expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ChaincodeMessage} ChaincodeMessage
             */
            ChaincodeMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ChaincodeMessage)
                    return object;
                var message = new $root.protos.ChaincodeMessage();
                switch (object.type) {
                case "UNDEFINED":
                case 0:
                    message.type = 0;
                    break;
                case "REGISTER":
                case 1:
                    message.type = 1;
                    break;
                case "REGISTERED":
                case 2:
                    message.type = 2;
                    break;
                case "INIT":
                case 3:
                    message.type = 3;
                    break;
                case "READY":
                case 4:
                    message.type = 4;
                    break;
                case "TRANSACTION":
                case 5:
                    message.type = 5;
                    break;
                case "COMPLETED":
                case 6:
                    message.type = 6;
                    break;
                case "ERROR":
                case 7:
                    message.type = 7;
                    break;
                case "GET_STATE":
                case 8:
                    message.type = 8;
                    break;
                case "PUT_STATE":
                case 9:
                    message.type = 9;
                    break;
                case "DEL_STATE":
                case 10:
                    message.type = 10;
                    break;
                case "INVOKE_CHAINCODE":
                case 11:
                    message.type = 11;
                    break;
                case "RESPONSE":
                case 13:
                    message.type = 13;
                    break;
                case "GET_STATE_BY_RANGE":
                case 14:
                    message.type = 14;
                    break;
                case "GET_QUERY_RESULT":
                case 15:
                    message.type = 15;
                    break;
                case "QUERY_STATE_NEXT":
                case 16:
                    message.type = 16;
                    break;
                case "QUERY_STATE_CLOSE":
                case 17:
                    message.type = 17;
                    break;
                case "KEEPALIVE":
                case 18:
                    message.type = 18;
                    break;
                case "GET_HISTORY_FOR_KEY":
                case 19:
                    message.type = 19;
                    break;
                case "GET_STATE_METADATA":
                case 20:
                    message.type = 20;
                    break;
                case "PUT_STATE_METADATA":
                case 21:
                    message.type = 21;
                    break;
                case "GET_PRIVATE_DATA_HASH":
                case 22:
                    message.type = 22;
                    break;
                }
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".protos.ChaincodeMessage.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.txid != null)
                    message.txid = String(object.txid);
                if (object.proposal != null) {
                    if (typeof object.proposal !== "object")
                        throw TypeError(".protos.ChaincodeMessage.proposal: object expected");
                    message.proposal = $root.protos.SignedProposal.fromObject(object.proposal);
                }
                if (object.chaincodeEvent != null) {
                    if (typeof object.chaincodeEvent !== "object")
                        throw TypeError(".protos.ChaincodeMessage.chaincodeEvent: object expected");
                    message.chaincodeEvent = $root.protos.ChaincodeEvent.fromObject(object.chaincodeEvent);
                }
                if (object.channelId != null)
                    message.channelId = String(object.channelId);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ChaincodeMessage
             * @static
             * @param {protos.ChaincodeMessage} message ChaincodeMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNDEFINED" : 0;
                    object.timestamp = null;
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    object.txid = "";
                    object.proposal = null;
                    object.chaincodeEvent = null;
                    object.channelId = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protos.ChaincodeMessage.Type[message.type] : message.type;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.txid != null && message.hasOwnProperty("txid"))
                    object.txid = message.txid;
                if (message.proposal != null && message.hasOwnProperty("proposal"))
                    object.proposal = $root.protos.SignedProposal.toObject(message.proposal, options);
                if (message.chaincodeEvent != null && message.hasOwnProperty("chaincodeEvent"))
                    object.chaincodeEvent = $root.protos.ChaincodeEvent.toObject(message.chaincodeEvent, options);
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    object.channelId = message.channelId;
                return object;
            };
    
            /**
             * Converts this ChaincodeMessage to JSON.
             * @function toJSON
             * @memberof protos.ChaincodeMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Type enum.
             * @name protos.ChaincodeMessage.Type
             * @enum {string}
             * @property {number} UNDEFINED=0 UNDEFINED value
             * @property {number} REGISTER=1 REGISTER value
             * @property {number} REGISTERED=2 REGISTERED value
             * @property {number} INIT=3 INIT value
             * @property {number} READY=4 READY value
             * @property {number} TRANSACTION=5 TRANSACTION value
             * @property {number} COMPLETED=6 COMPLETED value
             * @property {number} ERROR=7 ERROR value
             * @property {number} GET_STATE=8 GET_STATE value
             * @property {number} PUT_STATE=9 PUT_STATE value
             * @property {number} DEL_STATE=10 DEL_STATE value
             * @property {number} INVOKE_CHAINCODE=11 INVOKE_CHAINCODE value
             * @property {number} RESPONSE=13 RESPONSE value
             * @property {number} GET_STATE_BY_RANGE=14 GET_STATE_BY_RANGE value
             * @property {number} GET_QUERY_RESULT=15 GET_QUERY_RESULT value
             * @property {number} QUERY_STATE_NEXT=16 QUERY_STATE_NEXT value
             * @property {number} QUERY_STATE_CLOSE=17 QUERY_STATE_CLOSE value
             * @property {number} KEEPALIVE=18 KEEPALIVE value
             * @property {number} GET_HISTORY_FOR_KEY=19 GET_HISTORY_FOR_KEY value
             * @property {number} GET_STATE_METADATA=20 GET_STATE_METADATA value
             * @property {number} PUT_STATE_METADATA=21 PUT_STATE_METADATA value
             * @property {number} GET_PRIVATE_DATA_HASH=22 GET_PRIVATE_DATA_HASH value
             */
            ChaincodeMessage.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNDEFINED"] = 0;
                values[valuesById[1] = "REGISTER"] = 1;
                values[valuesById[2] = "REGISTERED"] = 2;
                values[valuesById[3] = "INIT"] = 3;
                values[valuesById[4] = "READY"] = 4;
                values[valuesById[5] = "TRANSACTION"] = 5;
                values[valuesById[6] = "COMPLETED"] = 6;
                values[valuesById[7] = "ERROR"] = 7;
                values[valuesById[8] = "GET_STATE"] = 8;
                values[valuesById[9] = "PUT_STATE"] = 9;
                values[valuesById[10] = "DEL_STATE"] = 10;
                values[valuesById[11] = "INVOKE_CHAINCODE"] = 11;
                values[valuesById[13] = "RESPONSE"] = 13;
                values[valuesById[14] = "GET_STATE_BY_RANGE"] = 14;
                values[valuesById[15] = "GET_QUERY_RESULT"] = 15;
                values[valuesById[16] = "QUERY_STATE_NEXT"] = 16;
                values[valuesById[17] = "QUERY_STATE_CLOSE"] = 17;
                values[valuesById[18] = "KEEPALIVE"] = 18;
                values[valuesById[19] = "GET_HISTORY_FOR_KEY"] = 19;
                values[valuesById[20] = "GET_STATE_METADATA"] = 20;
                values[valuesById[21] = "PUT_STATE_METADATA"] = 21;
                values[valuesById[22] = "GET_PRIVATE_DATA_HASH"] = 22;
                return values;
            })();
    
            return ChaincodeMessage;
        })();
    
        protos.GetState = (function() {
    
            /**
             * Properties of a GetState.
             * @memberof protos
             * @interface IGetState
             * @property {string|null} [key] GetState key
             * @property {string|null} [collection] GetState collection
             */
    
            /**
             * Constructs a new GetState.
             * @memberof protos
             * @classdesc Represents a GetState.
             * @implements IGetState
             * @constructor
             * @param {protos.IGetState=} [properties] Properties to set
             */
            function GetState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetState key.
             * @member {string} key
             * @memberof protos.GetState
             * @instance
             */
            GetState.prototype.key = "";
    
            /**
             * GetState collection.
             * @member {string} collection
             * @memberof protos.GetState
             * @instance
             */
            GetState.prototype.collection = "";
    
            /**
             * Creates a new GetState instance using the specified properties.
             * @function create
             * @memberof protos.GetState
             * @static
             * @param {protos.IGetState=} [properties] Properties to set
             * @returns {protos.GetState} GetState instance
             */
            GetState.create = function create(properties) {
                return new GetState(properties);
            };
    
            /**
             * Encodes the specified GetState message. Does not implicitly {@link protos.GetState.verify|verify} messages.
             * @function encode
             * @memberof protos.GetState
             * @static
             * @param {protos.IGetState} message GetState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.collection != null && message.hasOwnProperty("collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                return writer;
            };
    
            /**
             * Encodes the specified GetState message, length delimited. Does not implicitly {@link protos.GetState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.GetState
             * @static
             * @param {protos.IGetState} message GetState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetState message from the specified reader or buffer.
             * @function decode
             * @memberof protos.GetState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.GetState} GetState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.GetState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.GetState} GetState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetState message.
             * @function verify
             * @memberof protos.GetState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                return null;
            };
    
            /**
             * Creates a GetState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.GetState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.GetState} GetState
             */
            GetState.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.GetState)
                    return object;
                var message = new $root.protos.GetState();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.collection != null)
                    message.collection = String(object.collection);
                return message;
            };
    
            /**
             * Creates a plain object from a GetState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.GetState
             * @static
             * @param {protos.GetState} message GetState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.collection = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                return object;
            };
    
            /**
             * Converts this GetState to JSON.
             * @function toJSON
             * @memberof protos.GetState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetState;
        })();
    
        protos.GetStateMetadata = (function() {
    
            /**
             * Properties of a GetStateMetadata.
             * @memberof protos
             * @interface IGetStateMetadata
             * @property {string|null} [key] GetStateMetadata key
             * @property {string|null} [collection] GetStateMetadata collection
             */
    
            /**
             * Constructs a new GetStateMetadata.
             * @memberof protos
             * @classdesc Represents a GetStateMetadata.
             * @implements IGetStateMetadata
             * @constructor
             * @param {protos.IGetStateMetadata=} [properties] Properties to set
             */
            function GetStateMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetStateMetadata key.
             * @member {string} key
             * @memberof protos.GetStateMetadata
             * @instance
             */
            GetStateMetadata.prototype.key = "";
    
            /**
             * GetStateMetadata collection.
             * @member {string} collection
             * @memberof protos.GetStateMetadata
             * @instance
             */
            GetStateMetadata.prototype.collection = "";
    
            /**
             * Creates a new GetStateMetadata instance using the specified properties.
             * @function create
             * @memberof protos.GetStateMetadata
             * @static
             * @param {protos.IGetStateMetadata=} [properties] Properties to set
             * @returns {protos.GetStateMetadata} GetStateMetadata instance
             */
            GetStateMetadata.create = function create(properties) {
                return new GetStateMetadata(properties);
            };
    
            /**
             * Encodes the specified GetStateMetadata message. Does not implicitly {@link protos.GetStateMetadata.verify|verify} messages.
             * @function encode
             * @memberof protos.GetStateMetadata
             * @static
             * @param {protos.IGetStateMetadata} message GetStateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStateMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.collection != null && message.hasOwnProperty("collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                return writer;
            };
    
            /**
             * Encodes the specified GetStateMetadata message, length delimited. Does not implicitly {@link protos.GetStateMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.GetStateMetadata
             * @static
             * @param {protos.IGetStateMetadata} message GetStateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStateMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetStateMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof protos.GetStateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.GetStateMetadata} GetStateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStateMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetStateMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetStateMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.GetStateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.GetStateMetadata} GetStateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStateMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetStateMetadata message.
             * @function verify
             * @memberof protos.GetStateMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetStateMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                return null;
            };
    
            /**
             * Creates a GetStateMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.GetStateMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.GetStateMetadata} GetStateMetadata
             */
            GetStateMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.GetStateMetadata)
                    return object;
                var message = new $root.protos.GetStateMetadata();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.collection != null)
                    message.collection = String(object.collection);
                return message;
            };
    
            /**
             * Creates a plain object from a GetStateMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.GetStateMetadata
             * @static
             * @param {protos.GetStateMetadata} message GetStateMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetStateMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.collection = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                return object;
            };
    
            /**
             * Converts this GetStateMetadata to JSON.
             * @function toJSON
             * @memberof protos.GetStateMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetStateMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetStateMetadata;
        })();
    
        protos.PutState = (function() {
    
            /**
             * Properties of a PutState.
             * @memberof protos
             * @interface IPutState
             * @property {string|null} [key] PutState key
             * @property {Uint8Array|null} [value] PutState value
             * @property {string|null} [collection] PutState collection
             */
    
            /**
             * Constructs a new PutState.
             * @memberof protos
             * @classdesc Represents a PutState.
             * @implements IPutState
             * @constructor
             * @param {protos.IPutState=} [properties] Properties to set
             */
            function PutState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PutState key.
             * @member {string} key
             * @memberof protos.PutState
             * @instance
             */
            PutState.prototype.key = "";
    
            /**
             * PutState value.
             * @member {Uint8Array} value
             * @memberof protos.PutState
             * @instance
             */
            PutState.prototype.value = $util.newBuffer([]);
    
            /**
             * PutState collection.
             * @member {string} collection
             * @memberof protos.PutState
             * @instance
             */
            PutState.prototype.collection = "";
    
            /**
             * Creates a new PutState instance using the specified properties.
             * @function create
             * @memberof protos.PutState
             * @static
             * @param {protos.IPutState=} [properties] Properties to set
             * @returns {protos.PutState} PutState instance
             */
            PutState.create = function create(properties) {
                return new PutState(properties);
            };
    
            /**
             * Encodes the specified PutState message. Does not implicitly {@link protos.PutState.verify|verify} messages.
             * @function encode
             * @memberof protos.PutState
             * @static
             * @param {protos.IPutState} message PutState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PutState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.collection != null && message.hasOwnProperty("collection"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.collection);
                return writer;
            };
    
            /**
             * Encodes the specified PutState message, length delimited. Does not implicitly {@link protos.PutState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.PutState
             * @static
             * @param {protos.IPutState} message PutState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PutState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PutState message from the specified reader or buffer.
             * @function decode
             * @memberof protos.PutState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.PutState} PutState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PutState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.PutState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.collection = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PutState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.PutState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.PutState} PutState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PutState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PutState message.
             * @function verify
             * @memberof protos.PutState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PutState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                return null;
            };
    
            /**
             * Creates a PutState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.PutState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.PutState} PutState
             */
            PutState.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.PutState)
                    return object;
                var message = new $root.protos.PutState();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.collection != null)
                    message.collection = String(object.collection);
                return message;
            };
    
            /**
             * Creates a plain object from a PutState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.PutState
             * @static
             * @param {protos.PutState} message PutState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PutState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.collection = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                return object;
            };
    
            /**
             * Converts this PutState to JSON.
             * @function toJSON
             * @memberof protos.PutState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PutState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PutState;
        })();
    
        protos.PutStateMetadata = (function() {
    
            /**
             * Properties of a PutStateMetadata.
             * @memberof protos
             * @interface IPutStateMetadata
             * @property {string|null} [key] PutStateMetadata key
             * @property {string|null} [collection] PutStateMetadata collection
             * @property {protos.IStateMetadata|null} [metadata] PutStateMetadata metadata
             */
    
            /**
             * Constructs a new PutStateMetadata.
             * @memberof protos
             * @classdesc Represents a PutStateMetadata.
             * @implements IPutStateMetadata
             * @constructor
             * @param {protos.IPutStateMetadata=} [properties] Properties to set
             */
            function PutStateMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PutStateMetadata key.
             * @member {string} key
             * @memberof protos.PutStateMetadata
             * @instance
             */
            PutStateMetadata.prototype.key = "";
    
            /**
             * PutStateMetadata collection.
             * @member {string} collection
             * @memberof protos.PutStateMetadata
             * @instance
             */
            PutStateMetadata.prototype.collection = "";
    
            /**
             * PutStateMetadata metadata.
             * @member {protos.IStateMetadata|null|undefined} metadata
             * @memberof protos.PutStateMetadata
             * @instance
             */
            PutStateMetadata.prototype.metadata = null;
    
            /**
             * Creates a new PutStateMetadata instance using the specified properties.
             * @function create
             * @memberof protos.PutStateMetadata
             * @static
             * @param {protos.IPutStateMetadata=} [properties] Properties to set
             * @returns {protos.PutStateMetadata} PutStateMetadata instance
             */
            PutStateMetadata.create = function create(properties) {
                return new PutStateMetadata(properties);
            };
    
            /**
             * Encodes the specified PutStateMetadata message. Does not implicitly {@link protos.PutStateMetadata.verify|verify} messages.
             * @function encode
             * @memberof protos.PutStateMetadata
             * @static
             * @param {protos.IPutStateMetadata} message PutStateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PutStateMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.collection != null && message.hasOwnProperty("collection"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.collection);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.protos.StateMetadata.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PutStateMetadata message, length delimited. Does not implicitly {@link protos.PutStateMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.PutStateMetadata
             * @static
             * @param {protos.IPutStateMetadata} message PutStateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PutStateMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PutStateMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof protos.PutStateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.PutStateMetadata} PutStateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PutStateMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.PutStateMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 3:
                        message.collection = reader.string();
                        break;
                    case 4:
                        message.metadata = $root.protos.StateMetadata.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PutStateMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.PutStateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.PutStateMetadata} PutStateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PutStateMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PutStateMetadata message.
             * @function verify
             * @memberof protos.PutStateMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PutStateMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    var error = $root.protos.StateMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };
    
            /**
             * Creates a PutStateMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.PutStateMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.PutStateMetadata} PutStateMetadata
             */
            PutStateMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.PutStateMetadata)
                    return object;
                var message = new $root.protos.PutStateMetadata();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".protos.PutStateMetadata.metadata: object expected");
                    message.metadata = $root.protos.StateMetadata.fromObject(object.metadata);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PutStateMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.PutStateMetadata
             * @static
             * @param {protos.PutStateMetadata} message PutStateMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PutStateMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.collection = "";
                    object.metadata = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.protos.StateMetadata.toObject(message.metadata, options);
                return object;
            };
    
            /**
             * Converts this PutStateMetadata to JSON.
             * @function toJSON
             * @memberof protos.PutStateMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PutStateMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PutStateMetadata;
        })();
    
        protos.DelState = (function() {
    
            /**
             * Properties of a DelState.
             * @memberof protos
             * @interface IDelState
             * @property {string|null} [key] DelState key
             * @property {string|null} [collection] DelState collection
             */
    
            /**
             * Constructs a new DelState.
             * @memberof protos
             * @classdesc Represents a DelState.
             * @implements IDelState
             * @constructor
             * @param {protos.IDelState=} [properties] Properties to set
             */
            function DelState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DelState key.
             * @member {string} key
             * @memberof protos.DelState
             * @instance
             */
            DelState.prototype.key = "";
    
            /**
             * DelState collection.
             * @member {string} collection
             * @memberof protos.DelState
             * @instance
             */
            DelState.prototype.collection = "";
    
            /**
             * Creates a new DelState instance using the specified properties.
             * @function create
             * @memberof protos.DelState
             * @static
             * @param {protos.IDelState=} [properties] Properties to set
             * @returns {protos.DelState} DelState instance
             */
            DelState.create = function create(properties) {
                return new DelState(properties);
            };
    
            /**
             * Encodes the specified DelState message. Does not implicitly {@link protos.DelState.verify|verify} messages.
             * @function encode
             * @memberof protos.DelState
             * @static
             * @param {protos.IDelState} message DelState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DelState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.collection != null && message.hasOwnProperty("collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                return writer;
            };
    
            /**
             * Encodes the specified DelState message, length delimited. Does not implicitly {@link protos.DelState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.DelState
             * @static
             * @param {protos.IDelState} message DelState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DelState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DelState message from the specified reader or buffer.
             * @function decode
             * @memberof protos.DelState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.DelState} DelState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DelState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.DelState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DelState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.DelState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.DelState} DelState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DelState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DelState message.
             * @function verify
             * @memberof protos.DelState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DelState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                return null;
            };
    
            /**
             * Creates a DelState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.DelState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.DelState} DelState
             */
            DelState.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.DelState)
                    return object;
                var message = new $root.protos.DelState();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.collection != null)
                    message.collection = String(object.collection);
                return message;
            };
    
            /**
             * Creates a plain object from a DelState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.DelState
             * @static
             * @param {protos.DelState} message DelState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DelState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.collection = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                return object;
            };
    
            /**
             * Converts this DelState to JSON.
             * @function toJSON
             * @memberof protos.DelState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DelState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DelState;
        })();
    
        protos.GetStateByRange = (function() {
    
            /**
             * Properties of a GetStateByRange.
             * @memberof protos
             * @interface IGetStateByRange
             * @property {string|null} [startKey] GetStateByRange startKey
             * @property {string|null} [endKey] GetStateByRange endKey
             * @property {string|null} [collection] GetStateByRange collection
             * @property {Uint8Array|null} [metadata] GetStateByRange metadata
             */
    
            /**
             * Constructs a new GetStateByRange.
             * @memberof protos
             * @classdesc Represents a GetStateByRange.
             * @implements IGetStateByRange
             * @constructor
             * @param {protos.IGetStateByRange=} [properties] Properties to set
             */
            function GetStateByRange(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetStateByRange startKey.
             * @member {string} startKey
             * @memberof protos.GetStateByRange
             * @instance
             */
            GetStateByRange.prototype.startKey = "";
    
            /**
             * GetStateByRange endKey.
             * @member {string} endKey
             * @memberof protos.GetStateByRange
             * @instance
             */
            GetStateByRange.prototype.endKey = "";
    
            /**
             * GetStateByRange collection.
             * @member {string} collection
             * @memberof protos.GetStateByRange
             * @instance
             */
            GetStateByRange.prototype.collection = "";
    
            /**
             * GetStateByRange metadata.
             * @member {Uint8Array} metadata
             * @memberof protos.GetStateByRange
             * @instance
             */
            GetStateByRange.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Creates a new GetStateByRange instance using the specified properties.
             * @function create
             * @memberof protos.GetStateByRange
             * @static
             * @param {protos.IGetStateByRange=} [properties] Properties to set
             * @returns {protos.GetStateByRange} GetStateByRange instance
             */
            GetStateByRange.create = function create(properties) {
                return new GetStateByRange(properties);
            };
    
            /**
             * Encodes the specified GetStateByRange message. Does not implicitly {@link protos.GetStateByRange.verify|verify} messages.
             * @function encode
             * @memberof protos.GetStateByRange
             * @static
             * @param {protos.IGetStateByRange} message GetStateByRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStateByRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.startKey != null && message.hasOwnProperty("startKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.startKey);
                if (message.endKey != null && message.hasOwnProperty("endKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.endKey);
                if (message.collection != null && message.hasOwnProperty("collection"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.collection);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.metadata);
                return writer;
            };
    
            /**
             * Encodes the specified GetStateByRange message, length delimited. Does not implicitly {@link protos.GetStateByRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.GetStateByRange
             * @static
             * @param {protos.IGetStateByRange} message GetStateByRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStateByRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetStateByRange message from the specified reader or buffer.
             * @function decode
             * @memberof protos.GetStateByRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.GetStateByRange} GetStateByRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStateByRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetStateByRange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.startKey = reader.string();
                        break;
                    case 2:
                        message.endKey = reader.string();
                        break;
                    case 3:
                        message.collection = reader.string();
                        break;
                    case 4:
                        message.metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetStateByRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.GetStateByRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.GetStateByRange} GetStateByRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStateByRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetStateByRange message.
             * @function verify
             * @memberof protos.GetStateByRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetStateByRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.startKey != null && message.hasOwnProperty("startKey"))
                    if (!$util.isString(message.startKey))
                        return "startKey: string expected";
                if (message.endKey != null && message.hasOwnProperty("endKey"))
                    if (!$util.isString(message.endKey))
                        return "endKey: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates a GetStateByRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.GetStateByRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.GetStateByRange} GetStateByRange
             */
            GetStateByRange.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.GetStateByRange)
                    return object;
                var message = new $root.protos.GetStateByRange();
                if (object.startKey != null)
                    message.startKey = String(object.startKey);
                if (object.endKey != null)
                    message.endKey = String(object.endKey);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                return message;
            };
    
            /**
             * Creates a plain object from a GetStateByRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.GetStateByRange
             * @static
             * @param {protos.GetStateByRange} message GetStateByRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetStateByRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.startKey = "";
                    object.endKey = "";
                    object.collection = "";
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                }
                if (message.startKey != null && message.hasOwnProperty("startKey"))
                    object.startKey = message.startKey;
                if (message.endKey != null && message.hasOwnProperty("endKey"))
                    object.endKey = message.endKey;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                return object;
            };
    
            /**
             * Converts this GetStateByRange to JSON.
             * @function toJSON
             * @memberof protos.GetStateByRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetStateByRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetStateByRange;
        })();
    
        protos.GetQueryResult = (function() {
    
            /**
             * Properties of a GetQueryResult.
             * @memberof protos
             * @interface IGetQueryResult
             * @property {string|null} [query] GetQueryResult query
             * @property {string|null} [collection] GetQueryResult collection
             * @property {Uint8Array|null} [metadata] GetQueryResult metadata
             */
    
            /**
             * Constructs a new GetQueryResult.
             * @memberof protos
             * @classdesc Represents a GetQueryResult.
             * @implements IGetQueryResult
             * @constructor
             * @param {protos.IGetQueryResult=} [properties] Properties to set
             */
            function GetQueryResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetQueryResult query.
             * @member {string} query
             * @memberof protos.GetQueryResult
             * @instance
             */
            GetQueryResult.prototype.query = "";
    
            /**
             * GetQueryResult collection.
             * @member {string} collection
             * @memberof protos.GetQueryResult
             * @instance
             */
            GetQueryResult.prototype.collection = "";
    
            /**
             * GetQueryResult metadata.
             * @member {Uint8Array} metadata
             * @memberof protos.GetQueryResult
             * @instance
             */
            GetQueryResult.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Creates a new GetQueryResult instance using the specified properties.
             * @function create
             * @memberof protos.GetQueryResult
             * @static
             * @param {protos.IGetQueryResult=} [properties] Properties to set
             * @returns {protos.GetQueryResult} GetQueryResult instance
             */
            GetQueryResult.create = function create(properties) {
                return new GetQueryResult(properties);
            };
    
            /**
             * Encodes the specified GetQueryResult message. Does not implicitly {@link protos.GetQueryResult.verify|verify} messages.
             * @function encode
             * @memberof protos.GetQueryResult
             * @static
             * @param {protos.IGetQueryResult} message GetQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetQueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && message.hasOwnProperty("query"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
                if (message.collection != null && message.hasOwnProperty("collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.metadata);
                return writer;
            };
    
            /**
             * Encodes the specified GetQueryResult message, length delimited. Does not implicitly {@link protos.GetQueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.GetQueryResult
             * @static
             * @param {protos.IGetQueryResult} message GetQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetQueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetQueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof protos.GetQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.GetQueryResult} GetQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetQueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetQueryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.query = reader.string();
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    case 3:
                        message.metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetQueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.GetQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.GetQueryResult} GetQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetQueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetQueryResult message.
             * @function verify
             * @memberof protos.GetQueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetQueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query"))
                    if (!$util.isString(message.query))
                        return "query: string expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates a GetQueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.GetQueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.GetQueryResult} GetQueryResult
             */
            GetQueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.GetQueryResult)
                    return object;
                var message = new $root.protos.GetQueryResult();
                if (object.query != null)
                    message.query = String(object.query);
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                return message;
            };
    
            /**
             * Creates a plain object from a GetQueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.GetQueryResult
             * @static
             * @param {protos.GetQueryResult} message GetQueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetQueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.query = "";
                    object.collection = "";
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                }
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = message.query;
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                return object;
            };
    
            /**
             * Converts this GetQueryResult to JSON.
             * @function toJSON
             * @memberof protos.GetQueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetQueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetQueryResult;
        })();
    
        protos.QueryMetadata = (function() {
    
            /**
             * Properties of a QueryMetadata.
             * @memberof protos
             * @interface IQueryMetadata
             * @property {number|null} [pageSize] QueryMetadata pageSize
             * @property {string|null} [bookmark] QueryMetadata bookmark
             */
    
            /**
             * Constructs a new QueryMetadata.
             * @memberof protos
             * @classdesc Represents a QueryMetadata.
             * @implements IQueryMetadata
             * @constructor
             * @param {protos.IQueryMetadata=} [properties] Properties to set
             */
            function QueryMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryMetadata pageSize.
             * @member {number} pageSize
             * @memberof protos.QueryMetadata
             * @instance
             */
            QueryMetadata.prototype.pageSize = 0;
    
            /**
             * QueryMetadata bookmark.
             * @member {string} bookmark
             * @memberof protos.QueryMetadata
             * @instance
             */
            QueryMetadata.prototype.bookmark = "";
    
            /**
             * Creates a new QueryMetadata instance using the specified properties.
             * @function create
             * @memberof protos.QueryMetadata
             * @static
             * @param {protos.IQueryMetadata=} [properties] Properties to set
             * @returns {protos.QueryMetadata} QueryMetadata instance
             */
            QueryMetadata.create = function create(properties) {
                return new QueryMetadata(properties);
            };
    
            /**
             * Encodes the specified QueryMetadata message. Does not implicitly {@link protos.QueryMetadata.verify|verify} messages.
             * @function encode
             * @memberof protos.QueryMetadata
             * @static
             * @param {protos.IQueryMetadata} message QueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pageSize);
                if (message.bookmark != null && message.hasOwnProperty("bookmark"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.bookmark);
                return writer;
            };
    
            /**
             * Encodes the specified QueryMetadata message, length delimited. Does not implicitly {@link protos.QueryMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.QueryMetadata
             * @static
             * @param {protos.IQueryMetadata} message QueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof protos.QueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.QueryMetadata} QueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.QueryMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.pageSize = reader.int32();
                        break;
                    case 2:
                        message.bookmark = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.QueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.QueryMetadata} QueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryMetadata message.
             * @function verify
             * @memberof protos.QueryMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    if (!$util.isInteger(message.pageSize))
                        return "pageSize: integer expected";
                if (message.bookmark != null && message.hasOwnProperty("bookmark"))
                    if (!$util.isString(message.bookmark))
                        return "bookmark: string expected";
                return null;
            };
    
            /**
             * Creates a QueryMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.QueryMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.QueryMetadata} QueryMetadata
             */
            QueryMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.QueryMetadata)
                    return object;
                var message = new $root.protos.QueryMetadata();
                if (object.pageSize != null)
                    message.pageSize = object.pageSize | 0;
                if (object.bookmark != null)
                    message.bookmark = String(object.bookmark);
                return message;
            };
    
            /**
             * Creates a plain object from a QueryMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.QueryMetadata
             * @static
             * @param {protos.QueryMetadata} message QueryMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.pageSize = 0;
                    object.bookmark = "";
                }
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    object.pageSize = message.pageSize;
                if (message.bookmark != null && message.hasOwnProperty("bookmark"))
                    object.bookmark = message.bookmark;
                return object;
            };
    
            /**
             * Converts this QueryMetadata to JSON.
             * @function toJSON
             * @memberof protos.QueryMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryMetadata;
        })();
    
        protos.GetHistoryForKey = (function() {
    
            /**
             * Properties of a GetHistoryForKey.
             * @memberof protos
             * @interface IGetHistoryForKey
             * @property {string|null} [key] GetHistoryForKey key
             */
    
            /**
             * Constructs a new GetHistoryForKey.
             * @memberof protos
             * @classdesc Represents a GetHistoryForKey.
             * @implements IGetHistoryForKey
             * @constructor
             * @param {protos.IGetHistoryForKey=} [properties] Properties to set
             */
            function GetHistoryForKey(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetHistoryForKey key.
             * @member {string} key
             * @memberof protos.GetHistoryForKey
             * @instance
             */
            GetHistoryForKey.prototype.key = "";
    
            /**
             * Creates a new GetHistoryForKey instance using the specified properties.
             * @function create
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {protos.IGetHistoryForKey=} [properties] Properties to set
             * @returns {protos.GetHistoryForKey} GetHistoryForKey instance
             */
            GetHistoryForKey.create = function create(properties) {
                return new GetHistoryForKey(properties);
            };
    
            /**
             * Encodes the specified GetHistoryForKey message. Does not implicitly {@link protos.GetHistoryForKey.verify|verify} messages.
             * @function encode
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {protos.IGetHistoryForKey} message GetHistoryForKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryForKey.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                return writer;
            };
    
            /**
             * Encodes the specified GetHistoryForKey message, length delimited. Does not implicitly {@link protos.GetHistoryForKey.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {protos.IGetHistoryForKey} message GetHistoryForKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryForKey.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetHistoryForKey message from the specified reader or buffer.
             * @function decode
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.GetHistoryForKey} GetHistoryForKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryForKey.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.GetHistoryForKey();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetHistoryForKey message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.GetHistoryForKey} GetHistoryForKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryForKey.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetHistoryForKey message.
             * @function verify
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHistoryForKey.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                return null;
            };
    
            /**
             * Creates a GetHistoryForKey message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.GetHistoryForKey} GetHistoryForKey
             */
            GetHistoryForKey.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.GetHistoryForKey)
                    return object;
                var message = new $root.protos.GetHistoryForKey();
                if (object.key != null)
                    message.key = String(object.key);
                return message;
            };
    
            /**
             * Creates a plain object from a GetHistoryForKey message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.GetHistoryForKey
             * @static
             * @param {protos.GetHistoryForKey} message GetHistoryForKey
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHistoryForKey.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.key = "";
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                return object;
            };
    
            /**
             * Converts this GetHistoryForKey to JSON.
             * @function toJSON
             * @memberof protos.GetHistoryForKey
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHistoryForKey.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetHistoryForKey;
        })();
    
        protos.QueryStateNext = (function() {
    
            /**
             * Properties of a QueryStateNext.
             * @memberof protos
             * @interface IQueryStateNext
             * @property {string|null} [id] QueryStateNext id
             */
    
            /**
             * Constructs a new QueryStateNext.
             * @memberof protos
             * @classdesc Represents a QueryStateNext.
             * @implements IQueryStateNext
             * @constructor
             * @param {protos.IQueryStateNext=} [properties] Properties to set
             */
            function QueryStateNext(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryStateNext id.
             * @member {string} id
             * @memberof protos.QueryStateNext
             * @instance
             */
            QueryStateNext.prototype.id = "";
    
            /**
             * Creates a new QueryStateNext instance using the specified properties.
             * @function create
             * @memberof protos.QueryStateNext
             * @static
             * @param {protos.IQueryStateNext=} [properties] Properties to set
             * @returns {protos.QueryStateNext} QueryStateNext instance
             */
            QueryStateNext.create = function create(properties) {
                return new QueryStateNext(properties);
            };
    
            /**
             * Encodes the specified QueryStateNext message. Does not implicitly {@link protos.QueryStateNext.verify|verify} messages.
             * @function encode
             * @memberof protos.QueryStateNext
             * @static
             * @param {protos.IQueryStateNext} message QueryStateNext message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStateNext.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };
    
            /**
             * Encodes the specified QueryStateNext message, length delimited. Does not implicitly {@link protos.QueryStateNext.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.QueryStateNext
             * @static
             * @param {protos.IQueryStateNext} message QueryStateNext message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStateNext.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryStateNext message from the specified reader or buffer.
             * @function decode
             * @memberof protos.QueryStateNext
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.QueryStateNext} QueryStateNext
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStateNext.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.QueryStateNext();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryStateNext message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.QueryStateNext
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.QueryStateNext} QueryStateNext
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStateNext.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryStateNext message.
             * @function verify
             * @memberof protos.QueryStateNext
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryStateNext.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };
    
            /**
             * Creates a QueryStateNext message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.QueryStateNext
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.QueryStateNext} QueryStateNext
             */
            QueryStateNext.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.QueryStateNext)
                    return object;
                var message = new $root.protos.QueryStateNext();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };
    
            /**
             * Creates a plain object from a QueryStateNext message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.QueryStateNext
             * @static
             * @param {protos.QueryStateNext} message QueryStateNext
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryStateNext.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };
    
            /**
             * Converts this QueryStateNext to JSON.
             * @function toJSON
             * @memberof protos.QueryStateNext
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryStateNext.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryStateNext;
        })();
    
        protos.QueryStateClose = (function() {
    
            /**
             * Properties of a QueryStateClose.
             * @memberof protos
             * @interface IQueryStateClose
             * @property {string|null} [id] QueryStateClose id
             */
    
            /**
             * Constructs a new QueryStateClose.
             * @memberof protos
             * @classdesc Represents a QueryStateClose.
             * @implements IQueryStateClose
             * @constructor
             * @param {protos.IQueryStateClose=} [properties] Properties to set
             */
            function QueryStateClose(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryStateClose id.
             * @member {string} id
             * @memberof protos.QueryStateClose
             * @instance
             */
            QueryStateClose.prototype.id = "";
    
            /**
             * Creates a new QueryStateClose instance using the specified properties.
             * @function create
             * @memberof protos.QueryStateClose
             * @static
             * @param {protos.IQueryStateClose=} [properties] Properties to set
             * @returns {protos.QueryStateClose} QueryStateClose instance
             */
            QueryStateClose.create = function create(properties) {
                return new QueryStateClose(properties);
            };
    
            /**
             * Encodes the specified QueryStateClose message. Does not implicitly {@link protos.QueryStateClose.verify|verify} messages.
             * @function encode
             * @memberof protos.QueryStateClose
             * @static
             * @param {protos.IQueryStateClose} message QueryStateClose message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStateClose.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };
    
            /**
             * Encodes the specified QueryStateClose message, length delimited. Does not implicitly {@link protos.QueryStateClose.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.QueryStateClose
             * @static
             * @param {protos.IQueryStateClose} message QueryStateClose message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStateClose.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryStateClose message from the specified reader or buffer.
             * @function decode
             * @memberof protos.QueryStateClose
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.QueryStateClose} QueryStateClose
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStateClose.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.QueryStateClose();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryStateClose message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.QueryStateClose
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.QueryStateClose} QueryStateClose
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStateClose.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryStateClose message.
             * @function verify
             * @memberof protos.QueryStateClose
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryStateClose.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };
    
            /**
             * Creates a QueryStateClose message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.QueryStateClose
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.QueryStateClose} QueryStateClose
             */
            QueryStateClose.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.QueryStateClose)
                    return object;
                var message = new $root.protos.QueryStateClose();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };
    
            /**
             * Creates a plain object from a QueryStateClose message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.QueryStateClose
             * @static
             * @param {protos.QueryStateClose} message QueryStateClose
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryStateClose.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };
    
            /**
             * Converts this QueryStateClose to JSON.
             * @function toJSON
             * @memberof protos.QueryStateClose
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryStateClose.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryStateClose;
        })();
    
        protos.QueryResultBytes = (function() {
    
            /**
             * Properties of a QueryResultBytes.
             * @memberof protos
             * @interface IQueryResultBytes
             * @property {Uint8Array|null} [resultBytes] QueryResultBytes resultBytes
             */
    
            /**
             * Constructs a new QueryResultBytes.
             * @memberof protos
             * @classdesc Represents a QueryResultBytes.
             * @implements IQueryResultBytes
             * @constructor
             * @param {protos.IQueryResultBytes=} [properties] Properties to set
             */
            function QueryResultBytes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryResultBytes resultBytes.
             * @member {Uint8Array} resultBytes
             * @memberof protos.QueryResultBytes
             * @instance
             */
            QueryResultBytes.prototype.resultBytes = $util.newBuffer([]);
    
            /**
             * Creates a new QueryResultBytes instance using the specified properties.
             * @function create
             * @memberof protos.QueryResultBytes
             * @static
             * @param {protos.IQueryResultBytes=} [properties] Properties to set
             * @returns {protos.QueryResultBytes} QueryResultBytes instance
             */
            QueryResultBytes.create = function create(properties) {
                return new QueryResultBytes(properties);
            };
    
            /**
             * Encodes the specified QueryResultBytes message. Does not implicitly {@link protos.QueryResultBytes.verify|verify} messages.
             * @function encode
             * @memberof protos.QueryResultBytes
             * @static
             * @param {protos.IQueryResultBytes} message QueryResultBytes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResultBytes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resultBytes != null && message.hasOwnProperty("resultBytes"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.resultBytes);
                return writer;
            };
    
            /**
             * Encodes the specified QueryResultBytes message, length delimited. Does not implicitly {@link protos.QueryResultBytes.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.QueryResultBytes
             * @static
             * @param {protos.IQueryResultBytes} message QueryResultBytes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResultBytes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryResultBytes message from the specified reader or buffer.
             * @function decode
             * @memberof protos.QueryResultBytes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.QueryResultBytes} QueryResultBytes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResultBytes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.QueryResultBytes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resultBytes = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryResultBytes message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.QueryResultBytes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.QueryResultBytes} QueryResultBytes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResultBytes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryResultBytes message.
             * @function verify
             * @memberof protos.QueryResultBytes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryResultBytes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resultBytes != null && message.hasOwnProperty("resultBytes"))
                    if (!(message.resultBytes && typeof message.resultBytes.length === "number" || $util.isString(message.resultBytes)))
                        return "resultBytes: buffer expected";
                return null;
            };
    
            /**
             * Creates a QueryResultBytes message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.QueryResultBytes
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.QueryResultBytes} QueryResultBytes
             */
            QueryResultBytes.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.QueryResultBytes)
                    return object;
                var message = new $root.protos.QueryResultBytes();
                if (object.resultBytes != null)
                    if (typeof object.resultBytes === "string")
                        $util.base64.decode(object.resultBytes, message.resultBytes = $util.newBuffer($util.base64.length(object.resultBytes)), 0);
                    else if (object.resultBytes.length)
                        message.resultBytes = object.resultBytes;
                return message;
            };
    
            /**
             * Creates a plain object from a QueryResultBytes message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.QueryResultBytes
             * @static
             * @param {protos.QueryResultBytes} message QueryResultBytes
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryResultBytes.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.resultBytes = "";
                    else {
                        object.resultBytes = [];
                        if (options.bytes !== Array)
                            object.resultBytes = $util.newBuffer(object.resultBytes);
                    }
                if (message.resultBytes != null && message.hasOwnProperty("resultBytes"))
                    object.resultBytes = options.bytes === String ? $util.base64.encode(message.resultBytes, 0, message.resultBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.resultBytes) : message.resultBytes;
                return object;
            };
    
            /**
             * Converts this QueryResultBytes to JSON.
             * @function toJSON
             * @memberof protos.QueryResultBytes
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryResultBytes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryResultBytes;
        })();
    
        protos.QueryResponse = (function() {
    
            /**
             * Properties of a QueryResponse.
             * @memberof protos
             * @interface IQueryResponse
             * @property {Array.<protos.IQueryResultBytes>|null} [results] QueryResponse results
             * @property {boolean|null} [hasMore] QueryResponse hasMore
             * @property {string|null} [id] QueryResponse id
             * @property {Uint8Array|null} [metadata] QueryResponse metadata
             */
    
            /**
             * Constructs a new QueryResponse.
             * @memberof protos
             * @classdesc Represents a QueryResponse.
             * @implements IQueryResponse
             * @constructor
             * @param {protos.IQueryResponse=} [properties] Properties to set
             */
            function QueryResponse(properties) {
                this.results = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryResponse results.
             * @member {Array.<protos.IQueryResultBytes>} results
             * @memberof protos.QueryResponse
             * @instance
             */
            QueryResponse.prototype.results = $util.emptyArray;
    
            /**
             * QueryResponse hasMore.
             * @member {boolean} hasMore
             * @memberof protos.QueryResponse
             * @instance
             */
            QueryResponse.prototype.hasMore = false;
    
            /**
             * QueryResponse id.
             * @member {string} id
             * @memberof protos.QueryResponse
             * @instance
             */
            QueryResponse.prototype.id = "";
    
            /**
             * QueryResponse metadata.
             * @member {Uint8Array} metadata
             * @memberof protos.QueryResponse
             * @instance
             */
            QueryResponse.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Creates a new QueryResponse instance using the specified properties.
             * @function create
             * @memberof protos.QueryResponse
             * @static
             * @param {protos.IQueryResponse=} [properties] Properties to set
             * @returns {protos.QueryResponse} QueryResponse instance
             */
            QueryResponse.create = function create(properties) {
                return new QueryResponse(properties);
            };
    
            /**
             * Encodes the specified QueryResponse message. Does not implicitly {@link protos.QueryResponse.verify|verify} messages.
             * @function encode
             * @memberof protos.QueryResponse
             * @static
             * @param {protos.IQueryResponse} message QueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.results != null && message.results.length)
                    for (var i = 0; i < message.results.length; ++i)
                        $root.protos.QueryResultBytes.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.hasMore != null && message.hasOwnProperty("hasMore"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hasMore);
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.metadata);
                return writer;
            };
    
            /**
             * Encodes the specified QueryResponse message, length delimited. Does not implicitly {@link protos.QueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.QueryResponse
             * @static
             * @param {protos.IQueryResponse} message QueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof protos.QueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.QueryResponse} QueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.QueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.results && message.results.length))
                            message.results = [];
                        message.results.push($root.protos.QueryResultBytes.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.hasMore = reader.bool();
                        break;
                    case 3:
                        message.id = reader.string();
                        break;
                    case 4:
                        message.metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.QueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.QueryResponse} QueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryResponse message.
             * @function verify
             * @memberof protos.QueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.results != null && message.hasOwnProperty("results")) {
                    if (!Array.isArray(message.results))
                        return "results: array expected";
                    for (var i = 0; i < message.results.length; ++i) {
                        var error = $root.protos.QueryResultBytes.verify(message.results[i]);
                        if (error)
                            return "results." + error;
                    }
                }
                if (message.hasMore != null && message.hasOwnProperty("hasMore"))
                    if (typeof message.hasMore !== "boolean")
                        return "hasMore: boolean expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates a QueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.QueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.QueryResponse} QueryResponse
             */
            QueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.QueryResponse)
                    return object;
                var message = new $root.protos.QueryResponse();
                if (object.results) {
                    if (!Array.isArray(object.results))
                        throw TypeError(".protos.QueryResponse.results: array expected");
                    message.results = [];
                    for (var i = 0; i < object.results.length; ++i) {
                        if (typeof object.results[i] !== "object")
                            throw TypeError(".protos.QueryResponse.results: object expected");
                        message.results[i] = $root.protos.QueryResultBytes.fromObject(object.results[i]);
                    }
                }
                if (object.hasMore != null)
                    message.hasMore = Boolean(object.hasMore);
                if (object.id != null)
                    message.id = String(object.id);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                return message;
            };
    
            /**
             * Creates a plain object from a QueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.QueryResponse
             * @static
             * @param {protos.QueryResponse} message QueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.results = [];
                if (options.defaults) {
                    object.hasMore = false;
                    object.id = "";
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                }
                if (message.results && message.results.length) {
                    object.results = [];
                    for (var j = 0; j < message.results.length; ++j)
                        object.results[j] = $root.protos.QueryResultBytes.toObject(message.results[j], options);
                }
                if (message.hasMore != null && message.hasOwnProperty("hasMore"))
                    object.hasMore = message.hasMore;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                return object;
            };
    
            /**
             * Converts this QueryResponse to JSON.
             * @function toJSON
             * @memberof protos.QueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryResponse;
        })();
    
        protos.QueryResponseMetadata = (function() {
    
            /**
             * Properties of a QueryResponseMetadata.
             * @memberof protos
             * @interface IQueryResponseMetadata
             * @property {number|null} [fetchedRecordsCount] QueryResponseMetadata fetchedRecordsCount
             * @property {string|null} [bookmark] QueryResponseMetadata bookmark
             */
    
            /**
             * Constructs a new QueryResponseMetadata.
             * @memberof protos
             * @classdesc Represents a QueryResponseMetadata.
             * @implements IQueryResponseMetadata
             * @constructor
             * @param {protos.IQueryResponseMetadata=} [properties] Properties to set
             */
            function QueryResponseMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryResponseMetadata fetchedRecordsCount.
             * @member {number} fetchedRecordsCount
             * @memberof protos.QueryResponseMetadata
             * @instance
             */
            QueryResponseMetadata.prototype.fetchedRecordsCount = 0;
    
            /**
             * QueryResponseMetadata bookmark.
             * @member {string} bookmark
             * @memberof protos.QueryResponseMetadata
             * @instance
             */
            QueryResponseMetadata.prototype.bookmark = "";
    
            /**
             * Creates a new QueryResponseMetadata instance using the specified properties.
             * @function create
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {protos.IQueryResponseMetadata=} [properties] Properties to set
             * @returns {protos.QueryResponseMetadata} QueryResponseMetadata instance
             */
            QueryResponseMetadata.create = function create(properties) {
                return new QueryResponseMetadata(properties);
            };
    
            /**
             * Encodes the specified QueryResponseMetadata message. Does not implicitly {@link protos.QueryResponseMetadata.verify|verify} messages.
             * @function encode
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {protos.IQueryResponseMetadata} message QueryResponseMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResponseMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fetchedRecordsCount != null && message.hasOwnProperty("fetchedRecordsCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fetchedRecordsCount);
                if (message.bookmark != null && message.hasOwnProperty("bookmark"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.bookmark);
                return writer;
            };
    
            /**
             * Encodes the specified QueryResponseMetadata message, length delimited. Does not implicitly {@link protos.QueryResponseMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {protos.IQueryResponseMetadata} message QueryResponseMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryResponseMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryResponseMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.QueryResponseMetadata} QueryResponseMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResponseMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.QueryResponseMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fetchedRecordsCount = reader.int32();
                        break;
                    case 2:
                        message.bookmark = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryResponseMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.QueryResponseMetadata} QueryResponseMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryResponseMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryResponseMetadata message.
             * @function verify
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryResponseMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fetchedRecordsCount != null && message.hasOwnProperty("fetchedRecordsCount"))
                    if (!$util.isInteger(message.fetchedRecordsCount))
                        return "fetchedRecordsCount: integer expected";
                if (message.bookmark != null && message.hasOwnProperty("bookmark"))
                    if (!$util.isString(message.bookmark))
                        return "bookmark: string expected";
                return null;
            };
    
            /**
             * Creates a QueryResponseMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.QueryResponseMetadata} QueryResponseMetadata
             */
            QueryResponseMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.QueryResponseMetadata)
                    return object;
                var message = new $root.protos.QueryResponseMetadata();
                if (object.fetchedRecordsCount != null)
                    message.fetchedRecordsCount = object.fetchedRecordsCount | 0;
                if (object.bookmark != null)
                    message.bookmark = String(object.bookmark);
                return message;
            };
    
            /**
             * Creates a plain object from a QueryResponseMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.QueryResponseMetadata
             * @static
             * @param {protos.QueryResponseMetadata} message QueryResponseMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryResponseMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fetchedRecordsCount = 0;
                    object.bookmark = "";
                }
                if (message.fetchedRecordsCount != null && message.hasOwnProperty("fetchedRecordsCount"))
                    object.fetchedRecordsCount = message.fetchedRecordsCount;
                if (message.bookmark != null && message.hasOwnProperty("bookmark"))
                    object.bookmark = message.bookmark;
                return object;
            };
    
            /**
             * Converts this QueryResponseMetadata to JSON.
             * @function toJSON
             * @memberof protos.QueryResponseMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryResponseMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryResponseMetadata;
        })();
    
        protos.StateMetadata = (function() {
    
            /**
             * Properties of a StateMetadata.
             * @memberof protos
             * @interface IStateMetadata
             * @property {string|null} [metakey] StateMetadata metakey
             * @property {Uint8Array|null} [value] StateMetadata value
             */
    
            /**
             * Constructs a new StateMetadata.
             * @memberof protos
             * @classdesc Represents a StateMetadata.
             * @implements IStateMetadata
             * @constructor
             * @param {protos.IStateMetadata=} [properties] Properties to set
             */
            function StateMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateMetadata metakey.
             * @member {string} metakey
             * @memberof protos.StateMetadata
             * @instance
             */
            StateMetadata.prototype.metakey = "";
    
            /**
             * StateMetadata value.
             * @member {Uint8Array} value
             * @memberof protos.StateMetadata
             * @instance
             */
            StateMetadata.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new StateMetadata instance using the specified properties.
             * @function create
             * @memberof protos.StateMetadata
             * @static
             * @param {protos.IStateMetadata=} [properties] Properties to set
             * @returns {protos.StateMetadata} StateMetadata instance
             */
            StateMetadata.create = function create(properties) {
                return new StateMetadata(properties);
            };
    
            /**
             * Encodes the specified StateMetadata message. Does not implicitly {@link protos.StateMetadata.verify|verify} messages.
             * @function encode
             * @memberof protos.StateMetadata
             * @static
             * @param {protos.IStateMetadata} message StateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.metakey != null && message.hasOwnProperty("metakey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.metakey);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified StateMetadata message, length delimited. Does not implicitly {@link protos.StateMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.StateMetadata
             * @static
             * @param {protos.IStateMetadata} message StateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof protos.StateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.StateMetadata} StateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StateMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.metakey = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.StateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.StateMetadata} StateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateMetadata message.
             * @function verify
             * @memberof protos.StateMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.metakey != null && message.hasOwnProperty("metakey"))
                    if (!$util.isString(message.metakey))
                        return "metakey: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a StateMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.StateMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.StateMetadata} StateMetadata
             */
            StateMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.StateMetadata)
                    return object;
                var message = new $root.protos.StateMetadata();
                if (object.metakey != null)
                    message.metakey = String(object.metakey);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a StateMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.StateMetadata
             * @static
             * @param {protos.StateMetadata} message StateMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.metakey = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.metakey != null && message.hasOwnProperty("metakey"))
                    object.metakey = message.metakey;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this StateMetadata to JSON.
             * @function toJSON
             * @memberof protos.StateMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateMetadata;
        })();
    
        protos.StateMetadataResult = (function() {
    
            /**
             * Properties of a StateMetadataResult.
             * @memberof protos
             * @interface IStateMetadataResult
             * @property {Array.<protos.IStateMetadata>|null} [entries] StateMetadataResult entries
             */
    
            /**
             * Constructs a new StateMetadataResult.
             * @memberof protos
             * @classdesc Represents a StateMetadataResult.
             * @implements IStateMetadataResult
             * @constructor
             * @param {protos.IStateMetadataResult=} [properties] Properties to set
             */
            function StateMetadataResult(properties) {
                this.entries = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateMetadataResult entries.
             * @member {Array.<protos.IStateMetadata>} entries
             * @memberof protos.StateMetadataResult
             * @instance
             */
            StateMetadataResult.prototype.entries = $util.emptyArray;
    
            /**
             * Creates a new StateMetadataResult instance using the specified properties.
             * @function create
             * @memberof protos.StateMetadataResult
             * @static
             * @param {protos.IStateMetadataResult=} [properties] Properties to set
             * @returns {protos.StateMetadataResult} StateMetadataResult instance
             */
            StateMetadataResult.create = function create(properties) {
                return new StateMetadataResult(properties);
            };
    
            /**
             * Encodes the specified StateMetadataResult message. Does not implicitly {@link protos.StateMetadataResult.verify|verify} messages.
             * @function encode
             * @memberof protos.StateMetadataResult
             * @static
             * @param {protos.IStateMetadataResult} message StateMetadataResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateMetadataResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entries != null && message.entries.length)
                    for (var i = 0; i < message.entries.length; ++i)
                        $root.protos.StateMetadata.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StateMetadataResult message, length delimited. Does not implicitly {@link protos.StateMetadataResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.StateMetadataResult
             * @static
             * @param {protos.IStateMetadataResult} message StateMetadataResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateMetadataResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateMetadataResult message from the specified reader or buffer.
             * @function decode
             * @memberof protos.StateMetadataResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.StateMetadataResult} StateMetadataResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateMetadataResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.StateMetadataResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.entries && message.entries.length))
                            message.entries = [];
                        message.entries.push($root.protos.StateMetadata.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateMetadataResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.StateMetadataResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.StateMetadataResult} StateMetadataResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateMetadataResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateMetadataResult message.
             * @function verify
             * @memberof protos.StateMetadataResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateMetadataResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entries != null && message.hasOwnProperty("entries")) {
                    if (!Array.isArray(message.entries))
                        return "entries: array expected";
                    for (var i = 0; i < message.entries.length; ++i) {
                        var error = $root.protos.StateMetadata.verify(message.entries[i]);
                        if (error)
                            return "entries." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a StateMetadataResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.StateMetadataResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.StateMetadataResult} StateMetadataResult
             */
            StateMetadataResult.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.StateMetadataResult)
                    return object;
                var message = new $root.protos.StateMetadataResult();
                if (object.entries) {
                    if (!Array.isArray(object.entries))
                        throw TypeError(".protos.StateMetadataResult.entries: array expected");
                    message.entries = [];
                    for (var i = 0; i < object.entries.length; ++i) {
                        if (typeof object.entries[i] !== "object")
                            throw TypeError(".protos.StateMetadataResult.entries: object expected");
                        message.entries[i] = $root.protos.StateMetadata.fromObject(object.entries[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StateMetadataResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.StateMetadataResult
             * @static
             * @param {protos.StateMetadataResult} message StateMetadataResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateMetadataResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.entries = [];
                if (message.entries && message.entries.length) {
                    object.entries = [];
                    for (var j = 0; j < message.entries.length; ++j)
                        object.entries[j] = $root.protos.StateMetadata.toObject(message.entries[j], options);
                }
                return object;
            };
    
            /**
             * Converts this StateMetadataResult to JSON.
             * @function toJSON
             * @memberof protos.StateMetadataResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateMetadataResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateMetadataResult;
        })();
    
        protos.ChaincodeSupport = (function() {
    
            /**
             * Constructs a new ChaincodeSupport service.
             * @memberof protos
             * @classdesc Represents a ChaincodeSupport
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ChaincodeSupport(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (ChaincodeSupport.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ChaincodeSupport;
    
            /**
             * Creates new ChaincodeSupport service using the specified rpc implementation.
             * @function create
             * @memberof protos.ChaincodeSupport
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ChaincodeSupport} RPC service. Useful where requests and/or responses are streamed.
             */
            ChaincodeSupport.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link protos.ChaincodeSupport#register}.
             * @memberof protos.ChaincodeSupport
             * @typedef RegisterCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {protos.ChaincodeMessage} [response] ChaincodeMessage
             */
    
            /**
             * Calls Register.
             * @function register
             * @memberof protos.ChaincodeSupport
             * @instance
             * @param {protos.IChaincodeMessage} request ChaincodeMessage message or plain object
             * @param {protos.ChaincodeSupport.RegisterCallback} callback Node-style callback called with the error, if any, and ChaincodeMessage
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ChaincodeSupport.prototype.register = function register(request, callback) {
                return this.rpcCall(register, $root.protos.ChaincodeMessage, $root.protos.ChaincodeMessage, request, callback);
            }, "name", { value: "Register" });
    
            /**
             * Calls Register.
             * @function register
             * @memberof protos.ChaincodeSupport
             * @instance
             * @param {protos.IChaincodeMessage} request ChaincodeMessage message or plain object
             * @returns {Promise<protos.ChaincodeMessage>} Promise
             * @variation 2
             */
    
            return ChaincodeSupport;
        })();
    
        protos.AnchorPeers = (function() {
    
            /**
             * Properties of an AnchorPeers.
             * @memberof protos
             * @interface IAnchorPeers
             * @property {Array.<protos.IAnchorPeer>|null} [anchorPeers] AnchorPeers anchorPeers
             */
    
            /**
             * Constructs a new AnchorPeers.
             * @memberof protos
             * @classdesc Represents an AnchorPeers.
             * @implements IAnchorPeers
             * @constructor
             * @param {protos.IAnchorPeers=} [properties] Properties to set
             */
            function AnchorPeers(properties) {
                this.anchorPeers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AnchorPeers anchorPeers.
             * @member {Array.<protos.IAnchorPeer>} anchorPeers
             * @memberof protos.AnchorPeers
             * @instance
             */
            AnchorPeers.prototype.anchorPeers = $util.emptyArray;
    
            /**
             * Creates a new AnchorPeers instance using the specified properties.
             * @function create
             * @memberof protos.AnchorPeers
             * @static
             * @param {protos.IAnchorPeers=} [properties] Properties to set
             * @returns {protos.AnchorPeers} AnchorPeers instance
             */
            AnchorPeers.create = function create(properties) {
                return new AnchorPeers(properties);
            };
    
            /**
             * Encodes the specified AnchorPeers message. Does not implicitly {@link protos.AnchorPeers.verify|verify} messages.
             * @function encode
             * @memberof protos.AnchorPeers
             * @static
             * @param {protos.IAnchorPeers} message AnchorPeers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnchorPeers.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.anchorPeers != null && message.anchorPeers.length)
                    for (var i = 0; i < message.anchorPeers.length; ++i)
                        $root.protos.AnchorPeer.encode(message.anchorPeers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified AnchorPeers message, length delimited. Does not implicitly {@link protos.AnchorPeers.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.AnchorPeers
             * @static
             * @param {protos.IAnchorPeers} message AnchorPeers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnchorPeers.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AnchorPeers message from the specified reader or buffer.
             * @function decode
             * @memberof protos.AnchorPeers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.AnchorPeers} AnchorPeers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnchorPeers.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.AnchorPeers();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.anchorPeers && message.anchorPeers.length))
                            message.anchorPeers = [];
                        message.anchorPeers.push($root.protos.AnchorPeer.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AnchorPeers message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.AnchorPeers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.AnchorPeers} AnchorPeers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnchorPeers.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AnchorPeers message.
             * @function verify
             * @memberof protos.AnchorPeers
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AnchorPeers.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.anchorPeers != null && message.hasOwnProperty("anchorPeers")) {
                    if (!Array.isArray(message.anchorPeers))
                        return "anchorPeers: array expected";
                    for (var i = 0; i < message.anchorPeers.length; ++i) {
                        var error = $root.protos.AnchorPeer.verify(message.anchorPeers[i]);
                        if (error)
                            return "anchorPeers." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates an AnchorPeers message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.AnchorPeers
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.AnchorPeers} AnchorPeers
             */
            AnchorPeers.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.AnchorPeers)
                    return object;
                var message = new $root.protos.AnchorPeers();
                if (object.anchorPeers) {
                    if (!Array.isArray(object.anchorPeers))
                        throw TypeError(".protos.AnchorPeers.anchorPeers: array expected");
                    message.anchorPeers = [];
                    for (var i = 0; i < object.anchorPeers.length; ++i) {
                        if (typeof object.anchorPeers[i] !== "object")
                            throw TypeError(".protos.AnchorPeers.anchorPeers: object expected");
                        message.anchorPeers[i] = $root.protos.AnchorPeer.fromObject(object.anchorPeers[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from an AnchorPeers message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.AnchorPeers
             * @static
             * @param {protos.AnchorPeers} message AnchorPeers
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AnchorPeers.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.anchorPeers = [];
                if (message.anchorPeers && message.anchorPeers.length) {
                    object.anchorPeers = [];
                    for (var j = 0; j < message.anchorPeers.length; ++j)
                        object.anchorPeers[j] = $root.protos.AnchorPeer.toObject(message.anchorPeers[j], options);
                }
                return object;
            };
    
            /**
             * Converts this AnchorPeers to JSON.
             * @function toJSON
             * @memberof protos.AnchorPeers
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AnchorPeers.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AnchorPeers;
        })();
    
        protos.AnchorPeer = (function() {
    
            /**
             * Properties of an AnchorPeer.
             * @memberof protos
             * @interface IAnchorPeer
             * @property {string|null} [host] AnchorPeer host
             * @property {number|null} [port] AnchorPeer port
             */
    
            /**
             * Constructs a new AnchorPeer.
             * @memberof protos
             * @classdesc Represents an AnchorPeer.
             * @implements IAnchorPeer
             * @constructor
             * @param {protos.IAnchorPeer=} [properties] Properties to set
             */
            function AnchorPeer(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AnchorPeer host.
             * @member {string} host
             * @memberof protos.AnchorPeer
             * @instance
             */
            AnchorPeer.prototype.host = "";
    
            /**
             * AnchorPeer port.
             * @member {number} port
             * @memberof protos.AnchorPeer
             * @instance
             */
            AnchorPeer.prototype.port = 0;
    
            /**
             * Creates a new AnchorPeer instance using the specified properties.
             * @function create
             * @memberof protos.AnchorPeer
             * @static
             * @param {protos.IAnchorPeer=} [properties] Properties to set
             * @returns {protos.AnchorPeer} AnchorPeer instance
             */
            AnchorPeer.create = function create(properties) {
                return new AnchorPeer(properties);
            };
    
            /**
             * Encodes the specified AnchorPeer message. Does not implicitly {@link protos.AnchorPeer.verify|verify} messages.
             * @function encode
             * @memberof protos.AnchorPeer
             * @static
             * @param {protos.IAnchorPeer} message AnchorPeer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnchorPeer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.host != null && message.hasOwnProperty("host"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
                if (message.port != null && message.hasOwnProperty("port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
                return writer;
            };
    
            /**
             * Encodes the specified AnchorPeer message, length delimited. Does not implicitly {@link protos.AnchorPeer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.AnchorPeer
             * @static
             * @param {protos.IAnchorPeer} message AnchorPeer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnchorPeer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AnchorPeer message from the specified reader or buffer.
             * @function decode
             * @memberof protos.AnchorPeer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.AnchorPeer} AnchorPeer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnchorPeer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.AnchorPeer();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.host = reader.string();
                        break;
                    case 2:
                        message.port = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AnchorPeer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.AnchorPeer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.AnchorPeer} AnchorPeer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnchorPeer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AnchorPeer message.
             * @function verify
             * @memberof protos.AnchorPeer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AnchorPeer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                return null;
            };
    
            /**
             * Creates an AnchorPeer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.AnchorPeer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.AnchorPeer} AnchorPeer
             */
            AnchorPeer.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.AnchorPeer)
                    return object;
                var message = new $root.protos.AnchorPeer();
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port | 0;
                return message;
            };
    
            /**
             * Creates a plain object from an AnchorPeer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.AnchorPeer
             * @static
             * @param {protos.AnchorPeer} message AnchorPeer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AnchorPeer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.host = "";
                    object.port = 0;
                }
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                return object;
            };
    
            /**
             * Converts this AnchorPeer to JSON.
             * @function toJSON
             * @memberof protos.AnchorPeer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AnchorPeer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AnchorPeer;
        })();
    
        protos.APIResource = (function() {
    
            /**
             * Properties of a APIResource.
             * @memberof protos
             * @interface IAPIResource
             * @property {string|null} [policyRef] APIResource policyRef
             */
    
            /**
             * Constructs a new APIResource.
             * @memberof protos
             * @classdesc Represents a APIResource.
             * @implements IAPIResource
             * @constructor
             * @param {protos.IAPIResource=} [properties] Properties to set
             */
            function APIResource(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * APIResource policyRef.
             * @member {string} policyRef
             * @memberof protos.APIResource
             * @instance
             */
            APIResource.prototype.policyRef = "";
    
            /**
             * Creates a new APIResource instance using the specified properties.
             * @function create
             * @memberof protos.APIResource
             * @static
             * @param {protos.IAPIResource=} [properties] Properties to set
             * @returns {protos.APIResource} APIResource instance
             */
            APIResource.create = function create(properties) {
                return new APIResource(properties);
            };
    
            /**
             * Encodes the specified APIResource message. Does not implicitly {@link protos.APIResource.verify|verify} messages.
             * @function encode
             * @memberof protos.APIResource
             * @static
             * @param {protos.IAPIResource} message APIResource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            APIResource.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.policyRef != null && message.hasOwnProperty("policyRef"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.policyRef);
                return writer;
            };
    
            /**
             * Encodes the specified APIResource message, length delimited. Does not implicitly {@link protos.APIResource.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.APIResource
             * @static
             * @param {protos.IAPIResource} message APIResource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            APIResource.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a APIResource message from the specified reader or buffer.
             * @function decode
             * @memberof protos.APIResource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.APIResource} APIResource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            APIResource.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.APIResource();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.policyRef = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a APIResource message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.APIResource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.APIResource} APIResource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            APIResource.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a APIResource message.
             * @function verify
             * @memberof protos.APIResource
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            APIResource.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.policyRef != null && message.hasOwnProperty("policyRef"))
                    if (!$util.isString(message.policyRef))
                        return "policyRef: string expected";
                return null;
            };
    
            /**
             * Creates a APIResource message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.APIResource
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.APIResource} APIResource
             */
            APIResource.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.APIResource)
                    return object;
                var message = new $root.protos.APIResource();
                if (object.policyRef != null)
                    message.policyRef = String(object.policyRef);
                return message;
            };
    
            /**
             * Creates a plain object from a APIResource message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.APIResource
             * @static
             * @param {protos.APIResource} message APIResource
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            APIResource.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.policyRef = "";
                if (message.policyRef != null && message.hasOwnProperty("policyRef"))
                    object.policyRef = message.policyRef;
                return object;
            };
    
            /**
             * Converts this APIResource to JSON.
             * @function toJSON
             * @memberof protos.APIResource
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            APIResource.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return APIResource;
        })();
    
        protos.ACLs = (function() {
    
            /**
             * Properties of a ACLs.
             * @memberof protos
             * @interface IACLs
             * @property {Object.<string,protos.IAPIResource>|null} [acls] ACLs acls
             */
    
            /**
             * Constructs a new ACLs.
             * @memberof protos
             * @classdesc Represents a ACLs.
             * @implements IACLs
             * @constructor
             * @param {protos.IACLs=} [properties] Properties to set
             */
            function ACLs(properties) {
                this.acls = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ACLs acls.
             * @member {Object.<string,protos.IAPIResource>} acls
             * @memberof protos.ACLs
             * @instance
             */
            ACLs.prototype.acls = $util.emptyObject;
    
            /**
             * Creates a new ACLs instance using the specified properties.
             * @function create
             * @memberof protos.ACLs
             * @static
             * @param {protos.IACLs=} [properties] Properties to set
             * @returns {protos.ACLs} ACLs instance
             */
            ACLs.create = function create(properties) {
                return new ACLs(properties);
            };
    
            /**
             * Encodes the specified ACLs message. Does not implicitly {@link protos.ACLs.verify|verify} messages.
             * @function encode
             * @memberof protos.ACLs
             * @static
             * @param {protos.IACLs} message ACLs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ACLs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.acls != null && message.hasOwnProperty("acls"))
                    for (var keys = Object.keys(message.acls), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.protos.APIResource.encode(message.acls[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified ACLs message, length delimited. Does not implicitly {@link protos.ACLs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protos.ACLs
             * @static
             * @param {protos.IACLs} message ACLs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ACLs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ACLs message from the specified reader or buffer.
             * @function decode
             * @memberof protos.ACLs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protos.ACLs} ACLs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ACLs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protos.ACLs(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.acls === $util.emptyObject)
                            message.acls = {};
                        key = reader.string();
                        reader.pos++;
                        message.acls[key] = $root.protos.APIResource.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ACLs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protos.ACLs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protos.ACLs} ACLs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ACLs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ACLs message.
             * @function verify
             * @memberof protos.ACLs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ACLs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.acls != null && message.hasOwnProperty("acls")) {
                    if (!$util.isObject(message.acls))
                        return "acls: object expected";
                    var key = Object.keys(message.acls);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.protos.APIResource.verify(message.acls[key[i]]);
                        if (error)
                            return "acls." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ACLs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protos.ACLs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protos.ACLs} ACLs
             */
            ACLs.fromObject = function fromObject(object) {
                if (object instanceof $root.protos.ACLs)
                    return object;
                var message = new $root.protos.ACLs();
                if (object.acls) {
                    if (typeof object.acls !== "object")
                        throw TypeError(".protos.ACLs.acls: object expected");
                    message.acls = {};
                    for (var keys = Object.keys(object.acls), i = 0; i < keys.length; ++i) {
                        if (typeof object.acls[keys[i]] !== "object")
                            throw TypeError(".protos.ACLs.acls: object expected");
                        message.acls[keys[i]] = $root.protos.APIResource.fromObject(object.acls[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ACLs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protos.ACLs
             * @static
             * @param {protos.ACLs} message ACLs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ACLs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.acls = {};
                var keys2;
                if (message.acls && (keys2 = Object.keys(message.acls)).length) {
                    object.acls = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.acls[keys2[j]] = $root.protos.APIResource.toObject(message.acls[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this ACLs to JSON.
             * @function toJSON
             * @memberof protos.ACLs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ACLs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ACLs;
        })();
    
        return protos;
    })();
    
    $root.rwset = (function() {
    
        /**
         * Namespace rwset.
         * @exports rwset
         * @namespace
         */
        var rwset = {};
    
        rwset.TxReadWriteSet = (function() {
    
            /**
             * Properties of a TxReadWriteSet.
             * @memberof rwset
             * @interface ITxReadWriteSet
             * @property {rwset.TxReadWriteSet.DataModel|null} [dataModel] TxReadWriteSet dataModel
             * @property {Array.<rwset.INsReadWriteSet>|null} [nsRwset] TxReadWriteSet nsRwset
             */
    
            /**
             * Constructs a new TxReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a TxReadWriteSet.
             * @implements ITxReadWriteSet
             * @constructor
             * @param {rwset.ITxReadWriteSet=} [properties] Properties to set
             */
            function TxReadWriteSet(properties) {
                this.nsRwset = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TxReadWriteSet dataModel.
             * @member {rwset.TxReadWriteSet.DataModel} dataModel
             * @memberof rwset.TxReadWriteSet
             * @instance
             */
            TxReadWriteSet.prototype.dataModel = 0;
    
            /**
             * TxReadWriteSet nsRwset.
             * @member {Array.<rwset.INsReadWriteSet>} nsRwset
             * @memberof rwset.TxReadWriteSet
             * @instance
             */
            TxReadWriteSet.prototype.nsRwset = $util.emptyArray;
    
            /**
             * Creates a new TxReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {rwset.ITxReadWriteSet=} [properties] Properties to set
             * @returns {rwset.TxReadWriteSet} TxReadWriteSet instance
             */
            TxReadWriteSet.create = function create(properties) {
                return new TxReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified TxReadWriteSet message. Does not implicitly {@link rwset.TxReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {rwset.ITxReadWriteSet} message TxReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dataModel != null && message.hasOwnProperty("dataModel"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dataModel);
                if (message.nsRwset != null && message.nsRwset.length)
                    for (var i = 0; i < message.nsRwset.length; ++i)
                        $root.rwset.NsReadWriteSet.encode(message.nsRwset[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified TxReadWriteSet message, length delimited. Does not implicitly {@link rwset.TxReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {rwset.ITxReadWriteSet} message TxReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TxReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.TxReadWriteSet} TxReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.TxReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dataModel = reader.int32();
                        break;
                    case 2:
                        if (!(message.nsRwset && message.nsRwset.length))
                            message.nsRwset = [];
                        message.nsRwset.push($root.rwset.NsReadWriteSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TxReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.TxReadWriteSet} TxReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TxReadWriteSet message.
             * @function verify
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dataModel != null && message.hasOwnProperty("dataModel"))
                    switch (message.dataModel) {
                    default:
                        return "dataModel: enum value expected";
                    case 0:
                        break;
                    }
                if (message.nsRwset != null && message.hasOwnProperty("nsRwset")) {
                    if (!Array.isArray(message.nsRwset))
                        return "nsRwset: array expected";
                    for (var i = 0; i < message.nsRwset.length; ++i) {
                        var error = $root.rwset.NsReadWriteSet.verify(message.nsRwset[i]);
                        if (error)
                            return "nsRwset." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a TxReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.TxReadWriteSet} TxReadWriteSet
             */
            TxReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.TxReadWriteSet)
                    return object;
                var message = new $root.rwset.TxReadWriteSet();
                switch (object.dataModel) {
                case "KV":
                case 0:
                    message.dataModel = 0;
                    break;
                }
                if (object.nsRwset) {
                    if (!Array.isArray(object.nsRwset))
                        throw TypeError(".rwset.TxReadWriteSet.nsRwset: array expected");
                    message.nsRwset = [];
                    for (var i = 0; i < object.nsRwset.length; ++i) {
                        if (typeof object.nsRwset[i] !== "object")
                            throw TypeError(".rwset.TxReadWriteSet.nsRwset: object expected");
                        message.nsRwset[i] = $root.rwset.NsReadWriteSet.fromObject(object.nsRwset[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a TxReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.TxReadWriteSet
             * @static
             * @param {rwset.TxReadWriteSet} message TxReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.nsRwset = [];
                if (options.defaults)
                    object.dataModel = options.enums === String ? "KV" : 0;
                if (message.dataModel != null && message.hasOwnProperty("dataModel"))
                    object.dataModel = options.enums === String ? $root.rwset.TxReadWriteSet.DataModel[message.dataModel] : message.dataModel;
                if (message.nsRwset && message.nsRwset.length) {
                    object.nsRwset = [];
                    for (var j = 0; j < message.nsRwset.length; ++j)
                        object.nsRwset[j] = $root.rwset.NsReadWriteSet.toObject(message.nsRwset[j], options);
                }
                return object;
            };
    
            /**
             * Converts this TxReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.TxReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * DataModel enum.
             * @name rwset.TxReadWriteSet.DataModel
             * @enum {string}
             * @property {number} KV=0 KV value
             */
            TxReadWriteSet.DataModel = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "KV"] = 0;
                return values;
            })();
    
            return TxReadWriteSet;
        })();
    
        rwset.NsReadWriteSet = (function() {
    
            /**
             * Properties of a NsReadWriteSet.
             * @memberof rwset
             * @interface INsReadWriteSet
             * @property {string|null} [namespace] NsReadWriteSet namespace
             * @property {Uint8Array|null} [rwset] NsReadWriteSet rwset
             * @property {Array.<rwset.ICollectionHashedReadWriteSet>|null} [collectionHashedRwset] NsReadWriteSet collectionHashedRwset
             */
    
            /**
             * Constructs a new NsReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a NsReadWriteSet.
             * @implements INsReadWriteSet
             * @constructor
             * @param {rwset.INsReadWriteSet=} [properties] Properties to set
             */
            function NsReadWriteSet(properties) {
                this.collectionHashedRwset = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NsReadWriteSet namespace.
             * @member {string} namespace
             * @memberof rwset.NsReadWriteSet
             * @instance
             */
            NsReadWriteSet.prototype.namespace = "";
    
            /**
             * NsReadWriteSet rwset.
             * @member {Uint8Array} rwset
             * @memberof rwset.NsReadWriteSet
             * @instance
             */
            NsReadWriteSet.prototype.rwset = $util.newBuffer([]);
    
            /**
             * NsReadWriteSet collectionHashedRwset.
             * @member {Array.<rwset.ICollectionHashedReadWriteSet>} collectionHashedRwset
             * @memberof rwset.NsReadWriteSet
             * @instance
             */
            NsReadWriteSet.prototype.collectionHashedRwset = $util.emptyArray;
    
            /**
             * Creates a new NsReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {rwset.INsReadWriteSet=} [properties] Properties to set
             * @returns {rwset.NsReadWriteSet} NsReadWriteSet instance
             */
            NsReadWriteSet.create = function create(properties) {
                return new NsReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified NsReadWriteSet message. Does not implicitly {@link rwset.NsReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {rwset.INsReadWriteSet} message NsReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NsReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rwset);
                if (message.collectionHashedRwset != null && message.collectionHashedRwset.length)
                    for (var i = 0; i < message.collectionHashedRwset.length; ++i)
                        $root.rwset.CollectionHashedReadWriteSet.encode(message.collectionHashedRwset[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified NsReadWriteSet message, length delimited. Does not implicitly {@link rwset.NsReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {rwset.INsReadWriteSet} message NsReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NsReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NsReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.NsReadWriteSet} NsReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NsReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.NsReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.namespace = reader.string();
                        break;
                    case 2:
                        message.rwset = reader.bytes();
                        break;
                    case 3:
                        if (!(message.collectionHashedRwset && message.collectionHashedRwset.length))
                            message.collectionHashedRwset = [];
                        message.collectionHashedRwset.push($root.rwset.CollectionHashedReadWriteSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NsReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.NsReadWriteSet} NsReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NsReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NsReadWriteSet message.
             * @function verify
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NsReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    if (!(message.rwset && typeof message.rwset.length === "number" || $util.isString(message.rwset)))
                        return "rwset: buffer expected";
                if (message.collectionHashedRwset != null && message.hasOwnProperty("collectionHashedRwset")) {
                    if (!Array.isArray(message.collectionHashedRwset))
                        return "collectionHashedRwset: array expected";
                    for (var i = 0; i < message.collectionHashedRwset.length; ++i) {
                        var error = $root.rwset.CollectionHashedReadWriteSet.verify(message.collectionHashedRwset[i]);
                        if (error)
                            return "collectionHashedRwset." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a NsReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.NsReadWriteSet} NsReadWriteSet
             */
            NsReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.NsReadWriteSet)
                    return object;
                var message = new $root.rwset.NsReadWriteSet();
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.rwset != null)
                    if (typeof object.rwset === "string")
                        $util.base64.decode(object.rwset, message.rwset = $util.newBuffer($util.base64.length(object.rwset)), 0);
                    else if (object.rwset.length)
                        message.rwset = object.rwset;
                if (object.collectionHashedRwset) {
                    if (!Array.isArray(object.collectionHashedRwset))
                        throw TypeError(".rwset.NsReadWriteSet.collectionHashedRwset: array expected");
                    message.collectionHashedRwset = [];
                    for (var i = 0; i < object.collectionHashedRwset.length; ++i) {
                        if (typeof object.collectionHashedRwset[i] !== "object")
                            throw TypeError(".rwset.NsReadWriteSet.collectionHashedRwset: object expected");
                        message.collectionHashedRwset[i] = $root.rwset.CollectionHashedReadWriteSet.fromObject(object.collectionHashedRwset[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a NsReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.NsReadWriteSet
             * @static
             * @param {rwset.NsReadWriteSet} message NsReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NsReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.collectionHashedRwset = [];
                if (options.defaults) {
                    object.namespace = "";
                    if (options.bytes === String)
                        object.rwset = "";
                    else {
                        object.rwset = [];
                        if (options.bytes !== Array)
                            object.rwset = $util.newBuffer(object.rwset);
                    }
                }
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    object.rwset = options.bytes === String ? $util.base64.encode(message.rwset, 0, message.rwset.length) : options.bytes === Array ? Array.prototype.slice.call(message.rwset) : message.rwset;
                if (message.collectionHashedRwset && message.collectionHashedRwset.length) {
                    object.collectionHashedRwset = [];
                    for (var j = 0; j < message.collectionHashedRwset.length; ++j)
                        object.collectionHashedRwset[j] = $root.rwset.CollectionHashedReadWriteSet.toObject(message.collectionHashedRwset[j], options);
                }
                return object;
            };
    
            /**
             * Converts this NsReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.NsReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NsReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return NsReadWriteSet;
        })();
    
        rwset.CollectionHashedReadWriteSet = (function() {
    
            /**
             * Properties of a CollectionHashedReadWriteSet.
             * @memberof rwset
             * @interface ICollectionHashedReadWriteSet
             * @property {string|null} [collectionName] CollectionHashedReadWriteSet collectionName
             * @property {Uint8Array|null} [hashedRwset] CollectionHashedReadWriteSet hashedRwset
             * @property {Uint8Array|null} [pvtRwsetHash] CollectionHashedReadWriteSet pvtRwsetHash
             */
    
            /**
             * Constructs a new CollectionHashedReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a CollectionHashedReadWriteSet.
             * @implements ICollectionHashedReadWriteSet
             * @constructor
             * @param {rwset.ICollectionHashedReadWriteSet=} [properties] Properties to set
             */
            function CollectionHashedReadWriteSet(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionHashedReadWriteSet collectionName.
             * @member {string} collectionName
             * @memberof rwset.CollectionHashedReadWriteSet
             * @instance
             */
            CollectionHashedReadWriteSet.prototype.collectionName = "";
    
            /**
             * CollectionHashedReadWriteSet hashedRwset.
             * @member {Uint8Array} hashedRwset
             * @memberof rwset.CollectionHashedReadWriteSet
             * @instance
             */
            CollectionHashedReadWriteSet.prototype.hashedRwset = $util.newBuffer([]);
    
            /**
             * CollectionHashedReadWriteSet pvtRwsetHash.
             * @member {Uint8Array} pvtRwsetHash
             * @memberof rwset.CollectionHashedReadWriteSet
             * @instance
             */
            CollectionHashedReadWriteSet.prototype.pvtRwsetHash = $util.newBuffer([]);
    
            /**
             * Creates a new CollectionHashedReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {rwset.ICollectionHashedReadWriteSet=} [properties] Properties to set
             * @returns {rwset.CollectionHashedReadWriteSet} CollectionHashedReadWriteSet instance
             */
            CollectionHashedReadWriteSet.create = function create(properties) {
                return new CollectionHashedReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified CollectionHashedReadWriteSet message. Does not implicitly {@link rwset.CollectionHashedReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {rwset.ICollectionHashedReadWriteSet} message CollectionHashedReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionHashedReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collectionName != null && message.hasOwnProperty("collectionName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collectionName);
                if (message.hashedRwset != null && message.hasOwnProperty("hashedRwset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hashedRwset);
                if (message.pvtRwsetHash != null && message.hasOwnProperty("pvtRwsetHash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pvtRwsetHash);
                return writer;
            };
    
            /**
             * Encodes the specified CollectionHashedReadWriteSet message, length delimited. Does not implicitly {@link rwset.CollectionHashedReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {rwset.ICollectionHashedReadWriteSet} message CollectionHashedReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionHashedReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionHashedReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.CollectionHashedReadWriteSet} CollectionHashedReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionHashedReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.CollectionHashedReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collectionName = reader.string();
                        break;
                    case 2:
                        message.hashedRwset = reader.bytes();
                        break;
                    case 3:
                        message.pvtRwsetHash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionHashedReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.CollectionHashedReadWriteSet} CollectionHashedReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionHashedReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionHashedReadWriteSet message.
             * @function verify
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionHashedReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collectionName != null && message.hasOwnProperty("collectionName"))
                    if (!$util.isString(message.collectionName))
                        return "collectionName: string expected";
                if (message.hashedRwset != null && message.hasOwnProperty("hashedRwset"))
                    if (!(message.hashedRwset && typeof message.hashedRwset.length === "number" || $util.isString(message.hashedRwset)))
                        return "hashedRwset: buffer expected";
                if (message.pvtRwsetHash != null && message.hasOwnProperty("pvtRwsetHash"))
                    if (!(message.pvtRwsetHash && typeof message.pvtRwsetHash.length === "number" || $util.isString(message.pvtRwsetHash)))
                        return "pvtRwsetHash: buffer expected";
                return null;
            };
    
            /**
             * Creates a CollectionHashedReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.CollectionHashedReadWriteSet} CollectionHashedReadWriteSet
             */
            CollectionHashedReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.CollectionHashedReadWriteSet)
                    return object;
                var message = new $root.rwset.CollectionHashedReadWriteSet();
                if (object.collectionName != null)
                    message.collectionName = String(object.collectionName);
                if (object.hashedRwset != null)
                    if (typeof object.hashedRwset === "string")
                        $util.base64.decode(object.hashedRwset, message.hashedRwset = $util.newBuffer($util.base64.length(object.hashedRwset)), 0);
                    else if (object.hashedRwset.length)
                        message.hashedRwset = object.hashedRwset;
                if (object.pvtRwsetHash != null)
                    if (typeof object.pvtRwsetHash === "string")
                        $util.base64.decode(object.pvtRwsetHash, message.pvtRwsetHash = $util.newBuffer($util.base64.length(object.pvtRwsetHash)), 0);
                    else if (object.pvtRwsetHash.length)
                        message.pvtRwsetHash = object.pvtRwsetHash;
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionHashedReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.CollectionHashedReadWriteSet
             * @static
             * @param {rwset.CollectionHashedReadWriteSet} message CollectionHashedReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionHashedReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collectionName = "";
                    if (options.bytes === String)
                        object.hashedRwset = "";
                    else {
                        object.hashedRwset = [];
                        if (options.bytes !== Array)
                            object.hashedRwset = $util.newBuffer(object.hashedRwset);
                    }
                    if (options.bytes === String)
                        object.pvtRwsetHash = "";
                    else {
                        object.pvtRwsetHash = [];
                        if (options.bytes !== Array)
                            object.pvtRwsetHash = $util.newBuffer(object.pvtRwsetHash);
                    }
                }
                if (message.collectionName != null && message.hasOwnProperty("collectionName"))
                    object.collectionName = message.collectionName;
                if (message.hashedRwset != null && message.hasOwnProperty("hashedRwset"))
                    object.hashedRwset = options.bytes === String ? $util.base64.encode(message.hashedRwset, 0, message.hashedRwset.length) : options.bytes === Array ? Array.prototype.slice.call(message.hashedRwset) : message.hashedRwset;
                if (message.pvtRwsetHash != null && message.hasOwnProperty("pvtRwsetHash"))
                    object.pvtRwsetHash = options.bytes === String ? $util.base64.encode(message.pvtRwsetHash, 0, message.pvtRwsetHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.pvtRwsetHash) : message.pvtRwsetHash;
                return object;
            };
    
            /**
             * Converts this CollectionHashedReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.CollectionHashedReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionHashedReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionHashedReadWriteSet;
        })();
    
        rwset.TxPvtReadWriteSet = (function() {
    
            /**
             * Properties of a TxPvtReadWriteSet.
             * @memberof rwset
             * @interface ITxPvtReadWriteSet
             * @property {rwset.TxReadWriteSet.DataModel|null} [dataModel] TxPvtReadWriteSet dataModel
             * @property {Array.<rwset.INsPvtReadWriteSet>|null} [nsPvtRwset] TxPvtReadWriteSet nsPvtRwset
             */
    
            /**
             * Constructs a new TxPvtReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a TxPvtReadWriteSet.
             * @implements ITxPvtReadWriteSet
             * @constructor
             * @param {rwset.ITxPvtReadWriteSet=} [properties] Properties to set
             */
            function TxPvtReadWriteSet(properties) {
                this.nsPvtRwset = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TxPvtReadWriteSet dataModel.
             * @member {rwset.TxReadWriteSet.DataModel} dataModel
             * @memberof rwset.TxPvtReadWriteSet
             * @instance
             */
            TxPvtReadWriteSet.prototype.dataModel = 0;
    
            /**
             * TxPvtReadWriteSet nsPvtRwset.
             * @member {Array.<rwset.INsPvtReadWriteSet>} nsPvtRwset
             * @memberof rwset.TxPvtReadWriteSet
             * @instance
             */
            TxPvtReadWriteSet.prototype.nsPvtRwset = $util.emptyArray;
    
            /**
             * Creates a new TxPvtReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {rwset.ITxPvtReadWriteSet=} [properties] Properties to set
             * @returns {rwset.TxPvtReadWriteSet} TxPvtReadWriteSet instance
             */
            TxPvtReadWriteSet.create = function create(properties) {
                return new TxPvtReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified TxPvtReadWriteSet message. Does not implicitly {@link rwset.TxPvtReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {rwset.ITxPvtReadWriteSet} message TxPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxPvtReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dataModel != null && message.hasOwnProperty("dataModel"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dataModel);
                if (message.nsPvtRwset != null && message.nsPvtRwset.length)
                    for (var i = 0; i < message.nsPvtRwset.length; ++i)
                        $root.rwset.NsPvtReadWriteSet.encode(message.nsPvtRwset[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified TxPvtReadWriteSet message, length delimited. Does not implicitly {@link rwset.TxPvtReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {rwset.ITxPvtReadWriteSet} message TxPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxPvtReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TxPvtReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.TxPvtReadWriteSet} TxPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxPvtReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.TxPvtReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dataModel = reader.int32();
                        break;
                    case 2:
                        if (!(message.nsPvtRwset && message.nsPvtRwset.length))
                            message.nsPvtRwset = [];
                        message.nsPvtRwset.push($root.rwset.NsPvtReadWriteSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TxPvtReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.TxPvtReadWriteSet} TxPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxPvtReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TxPvtReadWriteSet message.
             * @function verify
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxPvtReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dataModel != null && message.hasOwnProperty("dataModel"))
                    switch (message.dataModel) {
                    default:
                        return "dataModel: enum value expected";
                    case 0:
                        break;
                    }
                if (message.nsPvtRwset != null && message.hasOwnProperty("nsPvtRwset")) {
                    if (!Array.isArray(message.nsPvtRwset))
                        return "nsPvtRwset: array expected";
                    for (var i = 0; i < message.nsPvtRwset.length; ++i) {
                        var error = $root.rwset.NsPvtReadWriteSet.verify(message.nsPvtRwset[i]);
                        if (error)
                            return "nsPvtRwset." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a TxPvtReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.TxPvtReadWriteSet} TxPvtReadWriteSet
             */
            TxPvtReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.TxPvtReadWriteSet)
                    return object;
                var message = new $root.rwset.TxPvtReadWriteSet();
                switch (object.dataModel) {
                case "KV":
                case 0:
                    message.dataModel = 0;
                    break;
                }
                if (object.nsPvtRwset) {
                    if (!Array.isArray(object.nsPvtRwset))
                        throw TypeError(".rwset.TxPvtReadWriteSet.nsPvtRwset: array expected");
                    message.nsPvtRwset = [];
                    for (var i = 0; i < object.nsPvtRwset.length; ++i) {
                        if (typeof object.nsPvtRwset[i] !== "object")
                            throw TypeError(".rwset.TxPvtReadWriteSet.nsPvtRwset: object expected");
                        message.nsPvtRwset[i] = $root.rwset.NsPvtReadWriteSet.fromObject(object.nsPvtRwset[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a TxPvtReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.TxPvtReadWriteSet
             * @static
             * @param {rwset.TxPvtReadWriteSet} message TxPvtReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxPvtReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.nsPvtRwset = [];
                if (options.defaults)
                    object.dataModel = options.enums === String ? "KV" : 0;
                if (message.dataModel != null && message.hasOwnProperty("dataModel"))
                    object.dataModel = options.enums === String ? $root.rwset.TxReadWriteSet.DataModel[message.dataModel] : message.dataModel;
                if (message.nsPvtRwset && message.nsPvtRwset.length) {
                    object.nsPvtRwset = [];
                    for (var j = 0; j < message.nsPvtRwset.length; ++j)
                        object.nsPvtRwset[j] = $root.rwset.NsPvtReadWriteSet.toObject(message.nsPvtRwset[j], options);
                }
                return object;
            };
    
            /**
             * Converts this TxPvtReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.TxPvtReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxPvtReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TxPvtReadWriteSet;
        })();
    
        rwset.NsPvtReadWriteSet = (function() {
    
            /**
             * Properties of a NsPvtReadWriteSet.
             * @memberof rwset
             * @interface INsPvtReadWriteSet
             * @property {string|null} [namespace] NsPvtReadWriteSet namespace
             * @property {Array.<rwset.ICollectionPvtReadWriteSet>|null} [collectionPvtRwset] NsPvtReadWriteSet collectionPvtRwset
             */
    
            /**
             * Constructs a new NsPvtReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a NsPvtReadWriteSet.
             * @implements INsPvtReadWriteSet
             * @constructor
             * @param {rwset.INsPvtReadWriteSet=} [properties] Properties to set
             */
            function NsPvtReadWriteSet(properties) {
                this.collectionPvtRwset = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NsPvtReadWriteSet namespace.
             * @member {string} namespace
             * @memberof rwset.NsPvtReadWriteSet
             * @instance
             */
            NsPvtReadWriteSet.prototype.namespace = "";
    
            /**
             * NsPvtReadWriteSet collectionPvtRwset.
             * @member {Array.<rwset.ICollectionPvtReadWriteSet>} collectionPvtRwset
             * @memberof rwset.NsPvtReadWriteSet
             * @instance
             */
            NsPvtReadWriteSet.prototype.collectionPvtRwset = $util.emptyArray;
    
            /**
             * Creates a new NsPvtReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {rwset.INsPvtReadWriteSet=} [properties] Properties to set
             * @returns {rwset.NsPvtReadWriteSet} NsPvtReadWriteSet instance
             */
            NsPvtReadWriteSet.create = function create(properties) {
                return new NsPvtReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified NsPvtReadWriteSet message. Does not implicitly {@link rwset.NsPvtReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {rwset.INsPvtReadWriteSet} message NsPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NsPvtReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
                if (message.collectionPvtRwset != null && message.collectionPvtRwset.length)
                    for (var i = 0; i < message.collectionPvtRwset.length; ++i)
                        $root.rwset.CollectionPvtReadWriteSet.encode(message.collectionPvtRwset[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified NsPvtReadWriteSet message, length delimited. Does not implicitly {@link rwset.NsPvtReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {rwset.INsPvtReadWriteSet} message NsPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NsPvtReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NsPvtReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.NsPvtReadWriteSet} NsPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NsPvtReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.NsPvtReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.namespace = reader.string();
                        break;
                    case 2:
                        if (!(message.collectionPvtRwset && message.collectionPvtRwset.length))
                            message.collectionPvtRwset = [];
                        message.collectionPvtRwset.push($root.rwset.CollectionPvtReadWriteSet.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NsPvtReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.NsPvtReadWriteSet} NsPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NsPvtReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NsPvtReadWriteSet message.
             * @function verify
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NsPvtReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.collectionPvtRwset != null && message.hasOwnProperty("collectionPvtRwset")) {
                    if (!Array.isArray(message.collectionPvtRwset))
                        return "collectionPvtRwset: array expected";
                    for (var i = 0; i < message.collectionPvtRwset.length; ++i) {
                        var error = $root.rwset.CollectionPvtReadWriteSet.verify(message.collectionPvtRwset[i]);
                        if (error)
                            return "collectionPvtRwset." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a NsPvtReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.NsPvtReadWriteSet} NsPvtReadWriteSet
             */
            NsPvtReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.NsPvtReadWriteSet)
                    return object;
                var message = new $root.rwset.NsPvtReadWriteSet();
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.collectionPvtRwset) {
                    if (!Array.isArray(object.collectionPvtRwset))
                        throw TypeError(".rwset.NsPvtReadWriteSet.collectionPvtRwset: array expected");
                    message.collectionPvtRwset = [];
                    for (var i = 0; i < object.collectionPvtRwset.length; ++i) {
                        if (typeof object.collectionPvtRwset[i] !== "object")
                            throw TypeError(".rwset.NsPvtReadWriteSet.collectionPvtRwset: object expected");
                        message.collectionPvtRwset[i] = $root.rwset.CollectionPvtReadWriteSet.fromObject(object.collectionPvtRwset[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a NsPvtReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.NsPvtReadWriteSet
             * @static
             * @param {rwset.NsPvtReadWriteSet} message NsPvtReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NsPvtReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.collectionPvtRwset = [];
                if (options.defaults)
                    object.namespace = "";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.collectionPvtRwset && message.collectionPvtRwset.length) {
                    object.collectionPvtRwset = [];
                    for (var j = 0; j < message.collectionPvtRwset.length; ++j)
                        object.collectionPvtRwset[j] = $root.rwset.CollectionPvtReadWriteSet.toObject(message.collectionPvtRwset[j], options);
                }
                return object;
            };
    
            /**
             * Converts this NsPvtReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.NsPvtReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NsPvtReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return NsPvtReadWriteSet;
        })();
    
        rwset.CollectionPvtReadWriteSet = (function() {
    
            /**
             * Properties of a CollectionPvtReadWriteSet.
             * @memberof rwset
             * @interface ICollectionPvtReadWriteSet
             * @property {string|null} [collectionName] CollectionPvtReadWriteSet collectionName
             * @property {Uint8Array|null} [rwset] CollectionPvtReadWriteSet rwset
             */
    
            /**
             * Constructs a new CollectionPvtReadWriteSet.
             * @memberof rwset
             * @classdesc Represents a CollectionPvtReadWriteSet.
             * @implements ICollectionPvtReadWriteSet
             * @constructor
             * @param {rwset.ICollectionPvtReadWriteSet=} [properties] Properties to set
             */
            function CollectionPvtReadWriteSet(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CollectionPvtReadWriteSet collectionName.
             * @member {string} collectionName
             * @memberof rwset.CollectionPvtReadWriteSet
             * @instance
             */
            CollectionPvtReadWriteSet.prototype.collectionName = "";
    
            /**
             * CollectionPvtReadWriteSet rwset.
             * @member {Uint8Array} rwset
             * @memberof rwset.CollectionPvtReadWriteSet
             * @instance
             */
            CollectionPvtReadWriteSet.prototype.rwset = $util.newBuffer([]);
    
            /**
             * Creates a new CollectionPvtReadWriteSet instance using the specified properties.
             * @function create
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {rwset.ICollectionPvtReadWriteSet=} [properties] Properties to set
             * @returns {rwset.CollectionPvtReadWriteSet} CollectionPvtReadWriteSet instance
             */
            CollectionPvtReadWriteSet.create = function create(properties) {
                return new CollectionPvtReadWriteSet(properties);
            };
    
            /**
             * Encodes the specified CollectionPvtReadWriteSet message. Does not implicitly {@link rwset.CollectionPvtReadWriteSet.verify|verify} messages.
             * @function encode
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {rwset.ICollectionPvtReadWriteSet} message CollectionPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionPvtReadWriteSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collectionName != null && message.hasOwnProperty("collectionName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collectionName);
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rwset);
                return writer;
            };
    
            /**
             * Encodes the specified CollectionPvtReadWriteSet message, length delimited. Does not implicitly {@link rwset.CollectionPvtReadWriteSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {rwset.ICollectionPvtReadWriteSet} message CollectionPvtReadWriteSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionPvtReadWriteSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CollectionPvtReadWriteSet message from the specified reader or buffer.
             * @function decode
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {rwset.CollectionPvtReadWriteSet} CollectionPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionPvtReadWriteSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.rwset.CollectionPvtReadWriteSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collectionName = reader.string();
                        break;
                    case 2:
                        message.rwset = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CollectionPvtReadWriteSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {rwset.CollectionPvtReadWriteSet} CollectionPvtReadWriteSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionPvtReadWriteSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CollectionPvtReadWriteSet message.
             * @function verify
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionPvtReadWriteSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collectionName != null && message.hasOwnProperty("collectionName"))
                    if (!$util.isString(message.collectionName))
                        return "collectionName: string expected";
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    if (!(message.rwset && typeof message.rwset.length === "number" || $util.isString(message.rwset)))
                        return "rwset: buffer expected";
                return null;
            };
    
            /**
             * Creates a CollectionPvtReadWriteSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {rwset.CollectionPvtReadWriteSet} CollectionPvtReadWriteSet
             */
            CollectionPvtReadWriteSet.fromObject = function fromObject(object) {
                if (object instanceof $root.rwset.CollectionPvtReadWriteSet)
                    return object;
                var message = new $root.rwset.CollectionPvtReadWriteSet();
                if (object.collectionName != null)
                    message.collectionName = String(object.collectionName);
                if (object.rwset != null)
                    if (typeof object.rwset === "string")
                        $util.base64.decode(object.rwset, message.rwset = $util.newBuffer($util.base64.length(object.rwset)), 0);
                    else if (object.rwset.length)
                        message.rwset = object.rwset;
                return message;
            };
    
            /**
             * Creates a plain object from a CollectionPvtReadWriteSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof rwset.CollectionPvtReadWriteSet
             * @static
             * @param {rwset.CollectionPvtReadWriteSet} message CollectionPvtReadWriteSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionPvtReadWriteSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collectionName = "";
                    if (options.bytes === String)
                        object.rwset = "";
                    else {
                        object.rwset = [];
                        if (options.bytes !== Array)
                            object.rwset = $util.newBuffer(object.rwset);
                    }
                }
                if (message.collectionName != null && message.hasOwnProperty("collectionName"))
                    object.collectionName = message.collectionName;
                if (message.rwset != null && message.hasOwnProperty("rwset"))
                    object.rwset = options.bytes === String ? $util.base64.encode(message.rwset, 0, message.rwset.length) : options.bytes === Array ? Array.prototype.slice.call(message.rwset) : message.rwset;
                return object;
            };
    
            /**
             * Converts this CollectionPvtReadWriteSet to JSON.
             * @function toJSON
             * @memberof rwset.CollectionPvtReadWriteSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionPvtReadWriteSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CollectionPvtReadWriteSet;
        })();
    
        return rwset;
    })();
    
    $root.lifecycle = (function() {
    
        /**
         * Namespace lifecycle.
         * @exports lifecycle
         * @namespace
         */
        var lifecycle = {};
    
        lifecycle.StateMetadata = (function() {
    
            /**
             * Properties of a StateMetadata.
             * @memberof lifecycle
             * @interface IStateMetadata
             * @property {string|null} [datatype] StateMetadata datatype
             * @property {Array.<string>|null} [fields] StateMetadata fields
             */
    
            /**
             * Constructs a new StateMetadata.
             * @memberof lifecycle
             * @classdesc Represents a StateMetadata.
             * @implements IStateMetadata
             * @constructor
             * @param {lifecycle.IStateMetadata=} [properties] Properties to set
             */
            function StateMetadata(properties) {
                this.fields = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateMetadata datatype.
             * @member {string} datatype
             * @memberof lifecycle.StateMetadata
             * @instance
             */
            StateMetadata.prototype.datatype = "";
    
            /**
             * StateMetadata fields.
             * @member {Array.<string>} fields
             * @memberof lifecycle.StateMetadata
             * @instance
             */
            StateMetadata.prototype.fields = $util.emptyArray;
    
            /**
             * Creates a new StateMetadata instance using the specified properties.
             * @function create
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {lifecycle.IStateMetadata=} [properties] Properties to set
             * @returns {lifecycle.StateMetadata} StateMetadata instance
             */
            StateMetadata.create = function create(properties) {
                return new StateMetadata(properties);
            };
    
            /**
             * Encodes the specified StateMetadata message. Does not implicitly {@link lifecycle.StateMetadata.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {lifecycle.IStateMetadata} message StateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.datatype != null && message.hasOwnProperty("datatype"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.datatype);
                if (message.fields != null && message.fields.length)
                    for (var i = 0; i < message.fields.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.fields[i]);
                return writer;
            };
    
            /**
             * Encodes the specified StateMetadata message, length delimited. Does not implicitly {@link lifecycle.StateMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {lifecycle.IStateMetadata} message StateMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.StateMetadata} StateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.StateMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.datatype = reader.string();
                        break;
                    case 2:
                        if (!(message.fields && message.fields.length))
                            message.fields = [];
                        message.fields.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.StateMetadata} StateMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateMetadata message.
             * @function verify
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.datatype != null && message.hasOwnProperty("datatype"))
                    if (!$util.isString(message.datatype))
                        return "datatype: string expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!Array.isArray(message.fields))
                        return "fields: array expected";
                    for (var i = 0; i < message.fields.length; ++i)
                        if (!$util.isString(message.fields[i]))
                            return "fields: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a StateMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.StateMetadata} StateMetadata
             */
            StateMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.StateMetadata)
                    return object;
                var message = new $root.lifecycle.StateMetadata();
                if (object.datatype != null)
                    message.datatype = String(object.datatype);
                if (object.fields) {
                    if (!Array.isArray(object.fields))
                        throw TypeError(".lifecycle.StateMetadata.fields: array expected");
                    message.fields = [];
                    for (var i = 0; i < object.fields.length; ++i)
                        message.fields[i] = String(object.fields[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StateMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.StateMetadata
             * @static
             * @param {lifecycle.StateMetadata} message StateMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.fields = [];
                if (options.defaults)
                    object.datatype = "";
                if (message.datatype != null && message.hasOwnProperty("datatype"))
                    object.datatype = message.datatype;
                if (message.fields && message.fields.length) {
                    object.fields = [];
                    for (var j = 0; j < message.fields.length; ++j)
                        object.fields[j] = message.fields[j];
                }
                return object;
            };
    
            /**
             * Converts this StateMetadata to JSON.
             * @function toJSON
             * @memberof lifecycle.StateMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateMetadata;
        })();
    
        lifecycle.StateData = (function() {
    
            /**
             * Properties of a StateData.
             * @memberof lifecycle
             * @interface IStateData
             * @property {number|Long|null} [Int64] StateData Int64
             * @property {Uint8Array|null} [Bytes] StateData Bytes
             * @property {string|null} [String] StateData String
             */
    
            /**
             * Constructs a new StateData.
             * @memberof lifecycle
             * @classdesc Represents a StateData.
             * @implements IStateData
             * @constructor
             * @param {lifecycle.IStateData=} [properties] Properties to set
             */
            function StateData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateData Int64.
             * @member {number|Long} Int64
             * @memberof lifecycle.StateData
             * @instance
             */
            StateData.prototype.Int64 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * StateData Bytes.
             * @member {Uint8Array} Bytes
             * @memberof lifecycle.StateData
             * @instance
             */
            StateData.prototype.Bytes = $util.newBuffer([]);
    
            /**
             * StateData String.
             * @member {string} String
             * @memberof lifecycle.StateData
             * @instance
             */
            StateData.prototype.String = "";
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * StateData Type.
             * @member {"Int64"|"Bytes"|"String"|undefined} Type
             * @memberof lifecycle.StateData
             * @instance
             */
            Object.defineProperty(StateData.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["Int64", "Bytes", "String"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new StateData instance using the specified properties.
             * @function create
             * @memberof lifecycle.StateData
             * @static
             * @param {lifecycle.IStateData=} [properties] Properties to set
             * @returns {lifecycle.StateData} StateData instance
             */
            StateData.create = function create(properties) {
                return new StateData(properties);
            };
    
            /**
             * Encodes the specified StateData message. Does not implicitly {@link lifecycle.StateData.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.StateData
             * @static
             * @param {lifecycle.IStateData} message StateData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Int64 != null && message.hasOwnProperty("Int64"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Int64);
                if (message.Bytes != null && message.hasOwnProperty("Bytes"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Bytes);
                if (message.String != null && message.hasOwnProperty("String"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.String);
                return writer;
            };
    
            /**
             * Encodes the specified StateData message, length delimited. Does not implicitly {@link lifecycle.StateData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.StateData
             * @static
             * @param {lifecycle.IStateData} message StateData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StateData message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.StateData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.StateData} StateData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.StateData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Int64 = reader.int64();
                        break;
                    case 2:
                        message.Bytes = reader.bytes();
                        break;
                    case 3:
                        message.String = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StateData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.StateData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.StateData} StateData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StateData message.
             * @function verify
             * @memberof lifecycle.StateData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StateData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.Int64 != null && message.hasOwnProperty("Int64")) {
                    properties.Type = 1;
                    if (!$util.isInteger(message.Int64) && !(message.Int64 && $util.isInteger(message.Int64.low) && $util.isInteger(message.Int64.high)))
                        return "Int64: integer|Long expected";
                }
                if (message.Bytes != null && message.hasOwnProperty("Bytes")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    if (!(message.Bytes && typeof message.Bytes.length === "number" || $util.isString(message.Bytes)))
                        return "Bytes: buffer expected";
                }
                if (message.String != null && message.hasOwnProperty("String")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    if (!$util.isString(message.String))
                        return "String: string expected";
                }
                return null;
            };
    
            /**
             * Creates a StateData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.StateData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.StateData} StateData
             */
            StateData.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.StateData)
                    return object;
                var message = new $root.lifecycle.StateData();
                if (object.Int64 != null)
                    if ($util.Long)
                        (message.Int64 = $util.Long.fromValue(object.Int64)).unsigned = false;
                    else if (typeof object.Int64 === "string")
                        message.Int64 = parseInt(object.Int64, 10);
                    else if (typeof object.Int64 === "number")
                        message.Int64 = object.Int64;
                    else if (typeof object.Int64 === "object")
                        message.Int64 = new $util.LongBits(object.Int64.low >>> 0, object.Int64.high >>> 0).toNumber();
                if (object.Bytes != null)
                    if (typeof object.Bytes === "string")
                        $util.base64.decode(object.Bytes, message.Bytes = $util.newBuffer($util.base64.length(object.Bytes)), 0);
                    else if (object.Bytes.length)
                        message.Bytes = object.Bytes;
                if (object.String != null)
                    message.String = String(object.String);
                return message;
            };
    
            /**
             * Creates a plain object from a StateData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.StateData
             * @static
             * @param {lifecycle.StateData} message StateData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StateData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.Int64 != null && message.hasOwnProperty("Int64")) {
                    if (typeof message.Int64 === "number")
                        object.Int64 = options.longs === String ? String(message.Int64) : message.Int64;
                    else
                        object.Int64 = options.longs === String ? $util.Long.prototype.toString.call(message.Int64) : options.longs === Number ? new $util.LongBits(message.Int64.low >>> 0, message.Int64.high >>> 0).toNumber() : message.Int64;
                    if (options.oneofs)
                        object.Type = "Int64";
                }
                if (message.Bytes != null && message.hasOwnProperty("Bytes")) {
                    object.Bytes = options.bytes === String ? $util.base64.encode(message.Bytes, 0, message.Bytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.Bytes) : message.Bytes;
                    if (options.oneofs)
                        object.Type = "Bytes";
                }
                if (message.String != null && message.hasOwnProperty("String")) {
                    object.String = message.String;
                    if (options.oneofs)
                        object.Type = "String";
                }
                return object;
            };
    
            /**
             * Converts this StateData to JSON.
             * @function toJSON
             * @memberof lifecycle.StateData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StateData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StateData;
        })();
    
        lifecycle.InstallChaincodeArgs = (function() {
    
            /**
             * Properties of an InstallChaincodeArgs.
             * @memberof lifecycle
             * @interface IInstallChaincodeArgs
             * @property {Uint8Array|null} [chaincodeInstallPackage] InstallChaincodeArgs chaincodeInstallPackage
             */
    
            /**
             * Constructs a new InstallChaincodeArgs.
             * @memberof lifecycle
             * @classdesc Represents an InstallChaincodeArgs.
             * @implements IInstallChaincodeArgs
             * @constructor
             * @param {lifecycle.IInstallChaincodeArgs=} [properties] Properties to set
             */
            function InstallChaincodeArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * InstallChaincodeArgs chaincodeInstallPackage.
             * @member {Uint8Array} chaincodeInstallPackage
             * @memberof lifecycle.InstallChaincodeArgs
             * @instance
             */
            InstallChaincodeArgs.prototype.chaincodeInstallPackage = $util.newBuffer([]);
    
            /**
             * Creates a new InstallChaincodeArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {lifecycle.IInstallChaincodeArgs=} [properties] Properties to set
             * @returns {lifecycle.InstallChaincodeArgs} InstallChaincodeArgs instance
             */
            InstallChaincodeArgs.create = function create(properties) {
                return new InstallChaincodeArgs(properties);
            };
    
            /**
             * Encodes the specified InstallChaincodeArgs message. Does not implicitly {@link lifecycle.InstallChaincodeArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {lifecycle.IInstallChaincodeArgs} message InstallChaincodeArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InstallChaincodeArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodeInstallPackage != null && message.hasOwnProperty("chaincodeInstallPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chaincodeInstallPackage);
                return writer;
            };
    
            /**
             * Encodes the specified InstallChaincodeArgs message, length delimited. Does not implicitly {@link lifecycle.InstallChaincodeArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {lifecycle.IInstallChaincodeArgs} message InstallChaincodeArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InstallChaincodeArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an InstallChaincodeArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.InstallChaincodeArgs} InstallChaincodeArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InstallChaincodeArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.InstallChaincodeArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincodeInstallPackage = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an InstallChaincodeArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.InstallChaincodeArgs} InstallChaincodeArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InstallChaincodeArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an InstallChaincodeArgs message.
             * @function verify
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InstallChaincodeArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodeInstallPackage != null && message.hasOwnProperty("chaincodeInstallPackage"))
                    if (!(message.chaincodeInstallPackage && typeof message.chaincodeInstallPackage.length === "number" || $util.isString(message.chaincodeInstallPackage)))
                        return "chaincodeInstallPackage: buffer expected";
                return null;
            };
    
            /**
             * Creates an InstallChaincodeArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.InstallChaincodeArgs} InstallChaincodeArgs
             */
            InstallChaincodeArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.InstallChaincodeArgs)
                    return object;
                var message = new $root.lifecycle.InstallChaincodeArgs();
                if (object.chaincodeInstallPackage != null)
                    if (typeof object.chaincodeInstallPackage === "string")
                        $util.base64.decode(object.chaincodeInstallPackage, message.chaincodeInstallPackage = $util.newBuffer($util.base64.length(object.chaincodeInstallPackage)), 0);
                    else if (object.chaincodeInstallPackage.length)
                        message.chaincodeInstallPackage = object.chaincodeInstallPackage;
                return message;
            };
    
            /**
             * Creates a plain object from an InstallChaincodeArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.InstallChaincodeArgs
             * @static
             * @param {lifecycle.InstallChaincodeArgs} message InstallChaincodeArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InstallChaincodeArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.chaincodeInstallPackage = "";
                    else {
                        object.chaincodeInstallPackage = [];
                        if (options.bytes !== Array)
                            object.chaincodeInstallPackage = $util.newBuffer(object.chaincodeInstallPackage);
                    }
                if (message.chaincodeInstallPackage != null && message.hasOwnProperty("chaincodeInstallPackage"))
                    object.chaincodeInstallPackage = options.bytes === String ? $util.base64.encode(message.chaincodeInstallPackage, 0, message.chaincodeInstallPackage.length) : options.bytes === Array ? Array.prototype.slice.call(message.chaincodeInstallPackage) : message.chaincodeInstallPackage;
                return object;
            };
    
            /**
             * Converts this InstallChaincodeArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.InstallChaincodeArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InstallChaincodeArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return InstallChaincodeArgs;
        })();
    
        lifecycle.InstallChaincodeResult = (function() {
    
            /**
             * Properties of an InstallChaincodeResult.
             * @memberof lifecycle
             * @interface IInstallChaincodeResult
             * @property {string|null} [packageId] InstallChaincodeResult packageId
             * @property {string|null} [label] InstallChaincodeResult label
             */
    
            /**
             * Constructs a new InstallChaincodeResult.
             * @memberof lifecycle
             * @classdesc Represents an InstallChaincodeResult.
             * @implements IInstallChaincodeResult
             * @constructor
             * @param {lifecycle.IInstallChaincodeResult=} [properties] Properties to set
             */
            function InstallChaincodeResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * InstallChaincodeResult packageId.
             * @member {string} packageId
             * @memberof lifecycle.InstallChaincodeResult
             * @instance
             */
            InstallChaincodeResult.prototype.packageId = "";
    
            /**
             * InstallChaincodeResult label.
             * @member {string} label
             * @memberof lifecycle.InstallChaincodeResult
             * @instance
             */
            InstallChaincodeResult.prototype.label = "";
    
            /**
             * Creates a new InstallChaincodeResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {lifecycle.IInstallChaincodeResult=} [properties] Properties to set
             * @returns {lifecycle.InstallChaincodeResult} InstallChaincodeResult instance
             */
            InstallChaincodeResult.create = function create(properties) {
                return new InstallChaincodeResult(properties);
            };
    
            /**
             * Encodes the specified InstallChaincodeResult message. Does not implicitly {@link lifecycle.InstallChaincodeResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {lifecycle.IInstallChaincodeResult} message InstallChaincodeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InstallChaincodeResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.packageId != null && message.hasOwnProperty("packageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.packageId);
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);
                return writer;
            };
    
            /**
             * Encodes the specified InstallChaincodeResult message, length delimited. Does not implicitly {@link lifecycle.InstallChaincodeResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {lifecycle.IInstallChaincodeResult} message InstallChaincodeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InstallChaincodeResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an InstallChaincodeResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.InstallChaincodeResult} InstallChaincodeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InstallChaincodeResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.InstallChaincodeResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.packageId = reader.string();
                        break;
                    case 2:
                        message.label = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an InstallChaincodeResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.InstallChaincodeResult} InstallChaincodeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InstallChaincodeResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an InstallChaincodeResult message.
             * @function verify
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InstallChaincodeResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.packageId != null && message.hasOwnProperty("packageId"))
                    if (!$util.isString(message.packageId))
                        return "packageId: string expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                return null;
            };
    
            /**
             * Creates an InstallChaincodeResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.InstallChaincodeResult} InstallChaincodeResult
             */
            InstallChaincodeResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.InstallChaincodeResult)
                    return object;
                var message = new $root.lifecycle.InstallChaincodeResult();
                if (object.packageId != null)
                    message.packageId = String(object.packageId);
                if (object.label != null)
                    message.label = String(object.label);
                return message;
            };
    
            /**
             * Creates a plain object from an InstallChaincodeResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.InstallChaincodeResult
             * @static
             * @param {lifecycle.InstallChaincodeResult} message InstallChaincodeResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InstallChaincodeResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.packageId = "";
                    object.label = "";
                }
                if (message.packageId != null && message.hasOwnProperty("packageId"))
                    object.packageId = message.packageId;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                return object;
            };
    
            /**
             * Converts this InstallChaincodeResult to JSON.
             * @function toJSON
             * @memberof lifecycle.InstallChaincodeResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InstallChaincodeResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return InstallChaincodeResult;
        })();
    
        lifecycle.QueryInstalledChaincodeArgs = (function() {
    
            /**
             * Properties of a QueryInstalledChaincodeArgs.
             * @memberof lifecycle
             * @interface IQueryInstalledChaincodeArgs
             * @property {string|null} [packageId] QueryInstalledChaincodeArgs packageId
             */
    
            /**
             * Constructs a new QueryInstalledChaincodeArgs.
             * @memberof lifecycle
             * @classdesc Represents a QueryInstalledChaincodeArgs.
             * @implements IQueryInstalledChaincodeArgs
             * @constructor
             * @param {lifecycle.IQueryInstalledChaincodeArgs=} [properties] Properties to set
             */
            function QueryInstalledChaincodeArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryInstalledChaincodeArgs packageId.
             * @member {string} packageId
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @instance
             */
            QueryInstalledChaincodeArgs.prototype.packageId = "";
    
            /**
             * Creates a new QueryInstalledChaincodeArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {lifecycle.IQueryInstalledChaincodeArgs=} [properties] Properties to set
             * @returns {lifecycle.QueryInstalledChaincodeArgs} QueryInstalledChaincodeArgs instance
             */
            QueryInstalledChaincodeArgs.create = function create(properties) {
                return new QueryInstalledChaincodeArgs(properties);
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodeArgs message. Does not implicitly {@link lifecycle.QueryInstalledChaincodeArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {lifecycle.IQueryInstalledChaincodeArgs} message QueryInstalledChaincodeArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodeArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.packageId != null && message.hasOwnProperty("packageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.packageId);
                return writer;
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodeArgs message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodeArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {lifecycle.IQueryInstalledChaincodeArgs} message QueryInstalledChaincodeArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodeArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryInstalledChaincodeArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryInstalledChaincodeArgs} QueryInstalledChaincodeArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodeArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodeArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.packageId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryInstalledChaincodeArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryInstalledChaincodeArgs} QueryInstalledChaincodeArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodeArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryInstalledChaincodeArgs message.
             * @function verify
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryInstalledChaincodeArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.packageId != null && message.hasOwnProperty("packageId"))
                    if (!$util.isString(message.packageId))
                        return "packageId: string expected";
                return null;
            };
    
            /**
             * Creates a QueryInstalledChaincodeArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryInstalledChaincodeArgs} QueryInstalledChaincodeArgs
             */
            QueryInstalledChaincodeArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryInstalledChaincodeArgs)
                    return object;
                var message = new $root.lifecycle.QueryInstalledChaincodeArgs();
                if (object.packageId != null)
                    message.packageId = String(object.packageId);
                return message;
            };
    
            /**
             * Creates a plain object from a QueryInstalledChaincodeArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @static
             * @param {lifecycle.QueryInstalledChaincodeArgs} message QueryInstalledChaincodeArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryInstalledChaincodeArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.packageId = "";
                if (message.packageId != null && message.hasOwnProperty("packageId"))
                    object.packageId = message.packageId;
                return object;
            };
    
            /**
             * Converts this QueryInstalledChaincodeArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryInstalledChaincodeArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryInstalledChaincodeArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryInstalledChaincodeArgs;
        })();
    
        lifecycle.QueryInstalledChaincodeResult = (function() {
    
            /**
             * Properties of a QueryInstalledChaincodeResult.
             * @memberof lifecycle
             * @interface IQueryInstalledChaincodeResult
             * @property {string|null} [packageId] QueryInstalledChaincodeResult packageId
             * @property {string|null} [label] QueryInstalledChaincodeResult label
             * @property {Object.<string,lifecycle.QueryInstalledChaincodeResult.IReferences>|null} [references] QueryInstalledChaincodeResult references
             */
    
            /**
             * Constructs a new QueryInstalledChaincodeResult.
             * @memberof lifecycle
             * @classdesc Represents a QueryInstalledChaincodeResult.
             * @implements IQueryInstalledChaincodeResult
             * @constructor
             * @param {lifecycle.IQueryInstalledChaincodeResult=} [properties] Properties to set
             */
            function QueryInstalledChaincodeResult(properties) {
                this.references = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryInstalledChaincodeResult packageId.
             * @member {string} packageId
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @instance
             */
            QueryInstalledChaincodeResult.prototype.packageId = "";
    
            /**
             * QueryInstalledChaincodeResult label.
             * @member {string} label
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @instance
             */
            QueryInstalledChaincodeResult.prototype.label = "";
    
            /**
             * QueryInstalledChaincodeResult references.
             * @member {Object.<string,lifecycle.QueryInstalledChaincodeResult.IReferences>} references
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @instance
             */
            QueryInstalledChaincodeResult.prototype.references = $util.emptyObject;
    
            /**
             * Creates a new QueryInstalledChaincodeResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {lifecycle.IQueryInstalledChaincodeResult=} [properties] Properties to set
             * @returns {lifecycle.QueryInstalledChaincodeResult} QueryInstalledChaincodeResult instance
             */
            QueryInstalledChaincodeResult.create = function create(properties) {
                return new QueryInstalledChaincodeResult(properties);
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodeResult message. Does not implicitly {@link lifecycle.QueryInstalledChaincodeResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {lifecycle.IQueryInstalledChaincodeResult} message QueryInstalledChaincodeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodeResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.packageId != null && message.hasOwnProperty("packageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.packageId);
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);
                if (message.references != null && message.hasOwnProperty("references"))
                    for (var keys = Object.keys(message.references), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.lifecycle.QueryInstalledChaincodeResult.References.encode(message.references[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodeResult message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodeResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {lifecycle.IQueryInstalledChaincodeResult} message QueryInstalledChaincodeResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodeResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryInstalledChaincodeResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryInstalledChaincodeResult} QueryInstalledChaincodeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodeResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodeResult(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.packageId = reader.string();
                        break;
                    case 2:
                        message.label = reader.string();
                        break;
                    case 3:
                        reader.skip().pos++;
                        if (message.references === $util.emptyObject)
                            message.references = {};
                        key = reader.string();
                        reader.pos++;
                        message.references[key] = $root.lifecycle.QueryInstalledChaincodeResult.References.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryInstalledChaincodeResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryInstalledChaincodeResult} QueryInstalledChaincodeResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodeResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryInstalledChaincodeResult message.
             * @function verify
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryInstalledChaincodeResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.packageId != null && message.hasOwnProperty("packageId"))
                    if (!$util.isString(message.packageId))
                        return "packageId: string expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.references != null && message.hasOwnProperty("references")) {
                    if (!$util.isObject(message.references))
                        return "references: object expected";
                    var key = Object.keys(message.references);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.lifecycle.QueryInstalledChaincodeResult.References.verify(message.references[key[i]]);
                        if (error)
                            return "references." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a QueryInstalledChaincodeResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryInstalledChaincodeResult} QueryInstalledChaincodeResult
             */
            QueryInstalledChaincodeResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryInstalledChaincodeResult)
                    return object;
                var message = new $root.lifecycle.QueryInstalledChaincodeResult();
                if (object.packageId != null)
                    message.packageId = String(object.packageId);
                if (object.label != null)
                    message.label = String(object.label);
                if (object.references) {
                    if (typeof object.references !== "object")
                        throw TypeError(".lifecycle.QueryInstalledChaincodeResult.references: object expected");
                    message.references = {};
                    for (var keys = Object.keys(object.references), i = 0; i < keys.length; ++i) {
                        if (typeof object.references[keys[i]] !== "object")
                            throw TypeError(".lifecycle.QueryInstalledChaincodeResult.references: object expected");
                        message.references[keys[i]] = $root.lifecycle.QueryInstalledChaincodeResult.References.fromObject(object.references[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryInstalledChaincodeResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @static
             * @param {lifecycle.QueryInstalledChaincodeResult} message QueryInstalledChaincodeResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryInstalledChaincodeResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.references = {};
                if (options.defaults) {
                    object.packageId = "";
                    object.label = "";
                }
                if (message.packageId != null && message.hasOwnProperty("packageId"))
                    object.packageId = message.packageId;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                var keys2;
                if (message.references && (keys2 = Object.keys(message.references)).length) {
                    object.references = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.references[keys2[j]] = $root.lifecycle.QueryInstalledChaincodeResult.References.toObject(message.references[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this QueryInstalledChaincodeResult to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryInstalledChaincodeResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryInstalledChaincodeResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            QueryInstalledChaincodeResult.References = (function() {
    
                /**
                 * Properties of a References.
                 * @memberof lifecycle.QueryInstalledChaincodeResult
                 * @interface IReferences
                 * @property {Array.<lifecycle.QueryInstalledChaincodeResult.IChaincode>|null} [chaincodes] References chaincodes
                 */
    
                /**
                 * Constructs a new References.
                 * @memberof lifecycle.QueryInstalledChaincodeResult
                 * @classdesc Represents a References.
                 * @implements IReferences
                 * @constructor
                 * @param {lifecycle.QueryInstalledChaincodeResult.IReferences=} [properties] Properties to set
                 */
                function References(properties) {
                    this.chaincodes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * References chaincodes.
                 * @member {Array.<lifecycle.QueryInstalledChaincodeResult.IChaincode>} chaincodes
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @instance
                 */
                References.prototype.chaincodes = $util.emptyArray;
    
                /**
                 * Creates a new References instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.IReferences=} [properties] Properties to set
                 * @returns {lifecycle.QueryInstalledChaincodeResult.References} References instance
                 */
                References.create = function create(properties) {
                    return new References(properties);
                };
    
                /**
                 * Encodes the specified References message. Does not implicitly {@link lifecycle.QueryInstalledChaincodeResult.References.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.IReferences} message References message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                References.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chaincodes != null && message.chaincodes.length)
                        for (var i = 0; i < message.chaincodes.length; ++i)
                            $root.lifecycle.QueryInstalledChaincodeResult.Chaincode.encode(message.chaincodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified References message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodeResult.References.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.IReferences} message References message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                References.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a References message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.QueryInstalledChaincodeResult.References} References
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                References.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodeResult.References();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.chaincodes && message.chaincodes.length))
                                message.chaincodes = [];
                            message.chaincodes.push($root.lifecycle.QueryInstalledChaincodeResult.Chaincode.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a References message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.QueryInstalledChaincodeResult.References} References
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                References.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a References message.
                 * @function verify
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                References.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.chaincodes != null && message.hasOwnProperty("chaincodes")) {
                        if (!Array.isArray(message.chaincodes))
                            return "chaincodes: array expected";
                        for (var i = 0; i < message.chaincodes.length; ++i) {
                            var error = $root.lifecycle.QueryInstalledChaincodeResult.Chaincode.verify(message.chaincodes[i]);
                            if (error)
                                return "chaincodes." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a References message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.QueryInstalledChaincodeResult.References} References
                 */
                References.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.QueryInstalledChaincodeResult.References)
                        return object;
                    var message = new $root.lifecycle.QueryInstalledChaincodeResult.References();
                    if (object.chaincodes) {
                        if (!Array.isArray(object.chaincodes))
                            throw TypeError(".lifecycle.QueryInstalledChaincodeResult.References.chaincodes: array expected");
                        message.chaincodes = [];
                        for (var i = 0; i < object.chaincodes.length; ++i) {
                            if (typeof object.chaincodes[i] !== "object")
                                throw TypeError(".lifecycle.QueryInstalledChaincodeResult.References.chaincodes: object expected");
                            message.chaincodes[i] = $root.lifecycle.QueryInstalledChaincodeResult.Chaincode.fromObject(object.chaincodes[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a References message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.References} message References
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                References.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.chaincodes = [];
                    if (message.chaincodes && message.chaincodes.length) {
                        object.chaincodes = [];
                        for (var j = 0; j < message.chaincodes.length; ++j)
                            object.chaincodes[j] = $root.lifecycle.QueryInstalledChaincodeResult.Chaincode.toObject(message.chaincodes[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this References to JSON.
                 * @function toJSON
                 * @memberof lifecycle.QueryInstalledChaincodeResult.References
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                References.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return References;
            })();
    
            QueryInstalledChaincodeResult.Chaincode = (function() {
    
                /**
                 * Properties of a Chaincode.
                 * @memberof lifecycle.QueryInstalledChaincodeResult
                 * @interface IChaincode
                 * @property {string|null} [name] Chaincode name
                 * @property {string|null} [version] Chaincode version
                 */
    
                /**
                 * Constructs a new Chaincode.
                 * @memberof lifecycle.QueryInstalledChaincodeResult
                 * @classdesc Represents a Chaincode.
                 * @implements IChaincode
                 * @constructor
                 * @param {lifecycle.QueryInstalledChaincodeResult.IChaincode=} [properties] Properties to set
                 */
                function Chaincode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Chaincode name.
                 * @member {string} name
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @instance
                 */
                Chaincode.prototype.name = "";
    
                /**
                 * Chaincode version.
                 * @member {string} version
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @instance
                 */
                Chaincode.prototype.version = "";
    
                /**
                 * Creates a new Chaincode instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.IChaincode=} [properties] Properties to set
                 * @returns {lifecycle.QueryInstalledChaincodeResult.Chaincode} Chaincode instance
                 */
                Chaincode.create = function create(properties) {
                    return new Chaincode(properties);
                };
    
                /**
                 * Encodes the specified Chaincode message. Does not implicitly {@link lifecycle.QueryInstalledChaincodeResult.Chaincode.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.IChaincode} message Chaincode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Chaincode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.version != null && message.hasOwnProperty("version"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                    return writer;
                };
    
                /**
                 * Encodes the specified Chaincode message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodeResult.Chaincode.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.IChaincode} message Chaincode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Chaincode.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Chaincode message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.QueryInstalledChaincodeResult.Chaincode} Chaincode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Chaincode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodeResult.Chaincode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.version = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Chaincode message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.QueryInstalledChaincodeResult.Chaincode} Chaincode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Chaincode.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Chaincode message.
                 * @function verify
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Chaincode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isString(message.version))
                            return "version: string expected";
                    return null;
                };
    
                /**
                 * Creates a Chaincode message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.QueryInstalledChaincodeResult.Chaincode} Chaincode
                 */
                Chaincode.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.QueryInstalledChaincodeResult.Chaincode)
                        return object;
                    var message = new $root.lifecycle.QueryInstalledChaincodeResult.Chaincode();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.version != null)
                        message.version = String(object.version);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Chaincode message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodeResult.Chaincode} message Chaincode
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Chaincode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.version = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    return object;
                };
    
                /**
                 * Converts this Chaincode to JSON.
                 * @function toJSON
                 * @memberof lifecycle.QueryInstalledChaincodeResult.Chaincode
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Chaincode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Chaincode;
            })();
    
            return QueryInstalledChaincodeResult;
        })();
    
        lifecycle.GetInstalledChaincodePackageArgs = (function() {
    
            /**
             * Properties of a GetInstalledChaincodePackageArgs.
             * @memberof lifecycle
             * @interface IGetInstalledChaincodePackageArgs
             * @property {string|null} [packageId] GetInstalledChaincodePackageArgs packageId
             */
    
            /**
             * Constructs a new GetInstalledChaincodePackageArgs.
             * @memberof lifecycle
             * @classdesc Represents a GetInstalledChaincodePackageArgs.
             * @implements IGetInstalledChaincodePackageArgs
             * @constructor
             * @param {lifecycle.IGetInstalledChaincodePackageArgs=} [properties] Properties to set
             */
            function GetInstalledChaincodePackageArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetInstalledChaincodePackageArgs packageId.
             * @member {string} packageId
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @instance
             */
            GetInstalledChaincodePackageArgs.prototype.packageId = "";
    
            /**
             * Creates a new GetInstalledChaincodePackageArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {lifecycle.IGetInstalledChaincodePackageArgs=} [properties] Properties to set
             * @returns {lifecycle.GetInstalledChaincodePackageArgs} GetInstalledChaincodePackageArgs instance
             */
            GetInstalledChaincodePackageArgs.create = function create(properties) {
                return new GetInstalledChaincodePackageArgs(properties);
            };
    
            /**
             * Encodes the specified GetInstalledChaincodePackageArgs message. Does not implicitly {@link lifecycle.GetInstalledChaincodePackageArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {lifecycle.IGetInstalledChaincodePackageArgs} message GetInstalledChaincodePackageArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInstalledChaincodePackageArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.packageId != null && message.hasOwnProperty("packageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.packageId);
                return writer;
            };
    
            /**
             * Encodes the specified GetInstalledChaincodePackageArgs message, length delimited. Does not implicitly {@link lifecycle.GetInstalledChaincodePackageArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {lifecycle.IGetInstalledChaincodePackageArgs} message GetInstalledChaincodePackageArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInstalledChaincodePackageArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetInstalledChaincodePackageArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.GetInstalledChaincodePackageArgs} GetInstalledChaincodePackageArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInstalledChaincodePackageArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.GetInstalledChaincodePackageArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.packageId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetInstalledChaincodePackageArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.GetInstalledChaincodePackageArgs} GetInstalledChaincodePackageArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInstalledChaincodePackageArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetInstalledChaincodePackageArgs message.
             * @function verify
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetInstalledChaincodePackageArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.packageId != null && message.hasOwnProperty("packageId"))
                    if (!$util.isString(message.packageId))
                        return "packageId: string expected";
                return null;
            };
    
            /**
             * Creates a GetInstalledChaincodePackageArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.GetInstalledChaincodePackageArgs} GetInstalledChaincodePackageArgs
             */
            GetInstalledChaincodePackageArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.GetInstalledChaincodePackageArgs)
                    return object;
                var message = new $root.lifecycle.GetInstalledChaincodePackageArgs();
                if (object.packageId != null)
                    message.packageId = String(object.packageId);
                return message;
            };
    
            /**
             * Creates a plain object from a GetInstalledChaincodePackageArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @static
             * @param {lifecycle.GetInstalledChaincodePackageArgs} message GetInstalledChaincodePackageArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetInstalledChaincodePackageArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.packageId = "";
                if (message.packageId != null && message.hasOwnProperty("packageId"))
                    object.packageId = message.packageId;
                return object;
            };
    
            /**
             * Converts this GetInstalledChaincodePackageArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.GetInstalledChaincodePackageArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetInstalledChaincodePackageArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetInstalledChaincodePackageArgs;
        })();
    
        lifecycle.GetInstalledChaincodePackageResult = (function() {
    
            /**
             * Properties of a GetInstalledChaincodePackageResult.
             * @memberof lifecycle
             * @interface IGetInstalledChaincodePackageResult
             * @property {Uint8Array|null} [chaincodeInstallPackage] GetInstalledChaincodePackageResult chaincodeInstallPackage
             */
    
            /**
             * Constructs a new GetInstalledChaincodePackageResult.
             * @memberof lifecycle
             * @classdesc Represents a GetInstalledChaincodePackageResult.
             * @implements IGetInstalledChaincodePackageResult
             * @constructor
             * @param {lifecycle.IGetInstalledChaincodePackageResult=} [properties] Properties to set
             */
            function GetInstalledChaincodePackageResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetInstalledChaincodePackageResult chaincodeInstallPackage.
             * @member {Uint8Array} chaincodeInstallPackage
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @instance
             */
            GetInstalledChaincodePackageResult.prototype.chaincodeInstallPackage = $util.newBuffer([]);
    
            /**
             * Creates a new GetInstalledChaincodePackageResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {lifecycle.IGetInstalledChaincodePackageResult=} [properties] Properties to set
             * @returns {lifecycle.GetInstalledChaincodePackageResult} GetInstalledChaincodePackageResult instance
             */
            GetInstalledChaincodePackageResult.create = function create(properties) {
                return new GetInstalledChaincodePackageResult(properties);
            };
    
            /**
             * Encodes the specified GetInstalledChaincodePackageResult message. Does not implicitly {@link lifecycle.GetInstalledChaincodePackageResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {lifecycle.IGetInstalledChaincodePackageResult} message GetInstalledChaincodePackageResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInstalledChaincodePackageResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodeInstallPackage != null && message.hasOwnProperty("chaincodeInstallPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chaincodeInstallPackage);
                return writer;
            };
    
            /**
             * Encodes the specified GetInstalledChaincodePackageResult message, length delimited. Does not implicitly {@link lifecycle.GetInstalledChaincodePackageResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {lifecycle.IGetInstalledChaincodePackageResult} message GetInstalledChaincodePackageResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInstalledChaincodePackageResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a GetInstalledChaincodePackageResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.GetInstalledChaincodePackageResult} GetInstalledChaincodePackageResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInstalledChaincodePackageResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.GetInstalledChaincodePackageResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.chaincodeInstallPackage = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a GetInstalledChaincodePackageResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.GetInstalledChaincodePackageResult} GetInstalledChaincodePackageResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInstalledChaincodePackageResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a GetInstalledChaincodePackageResult message.
             * @function verify
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetInstalledChaincodePackageResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodeInstallPackage != null && message.hasOwnProperty("chaincodeInstallPackage"))
                    if (!(message.chaincodeInstallPackage && typeof message.chaincodeInstallPackage.length === "number" || $util.isString(message.chaincodeInstallPackage)))
                        return "chaincodeInstallPackage: buffer expected";
                return null;
            };
    
            /**
             * Creates a GetInstalledChaincodePackageResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.GetInstalledChaincodePackageResult} GetInstalledChaincodePackageResult
             */
            GetInstalledChaincodePackageResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.GetInstalledChaincodePackageResult)
                    return object;
                var message = new $root.lifecycle.GetInstalledChaincodePackageResult();
                if (object.chaincodeInstallPackage != null)
                    if (typeof object.chaincodeInstallPackage === "string")
                        $util.base64.decode(object.chaincodeInstallPackage, message.chaincodeInstallPackage = $util.newBuffer($util.base64.length(object.chaincodeInstallPackage)), 0);
                    else if (object.chaincodeInstallPackage.length)
                        message.chaincodeInstallPackage = object.chaincodeInstallPackage;
                return message;
            };
    
            /**
             * Creates a plain object from a GetInstalledChaincodePackageResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @static
             * @param {lifecycle.GetInstalledChaincodePackageResult} message GetInstalledChaincodePackageResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetInstalledChaincodePackageResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.chaincodeInstallPackage = "";
                    else {
                        object.chaincodeInstallPackage = [];
                        if (options.bytes !== Array)
                            object.chaincodeInstallPackage = $util.newBuffer(object.chaincodeInstallPackage);
                    }
                if (message.chaincodeInstallPackage != null && message.hasOwnProperty("chaincodeInstallPackage"))
                    object.chaincodeInstallPackage = options.bytes === String ? $util.base64.encode(message.chaincodeInstallPackage, 0, message.chaincodeInstallPackage.length) : options.bytes === Array ? Array.prototype.slice.call(message.chaincodeInstallPackage) : message.chaincodeInstallPackage;
                return object;
            };
    
            /**
             * Converts this GetInstalledChaincodePackageResult to JSON.
             * @function toJSON
             * @memberof lifecycle.GetInstalledChaincodePackageResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetInstalledChaincodePackageResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return GetInstalledChaincodePackageResult;
        })();
    
        lifecycle.QueryInstalledChaincodesArgs = (function() {
    
            /**
             * Properties of a QueryInstalledChaincodesArgs.
             * @memberof lifecycle
             * @interface IQueryInstalledChaincodesArgs
             */
    
            /**
             * Constructs a new QueryInstalledChaincodesArgs.
             * @memberof lifecycle
             * @classdesc Represents a QueryInstalledChaincodesArgs.
             * @implements IQueryInstalledChaincodesArgs
             * @constructor
             * @param {lifecycle.IQueryInstalledChaincodesArgs=} [properties] Properties to set
             */
            function QueryInstalledChaincodesArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new QueryInstalledChaincodesArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {lifecycle.IQueryInstalledChaincodesArgs=} [properties] Properties to set
             * @returns {lifecycle.QueryInstalledChaincodesArgs} QueryInstalledChaincodesArgs instance
             */
            QueryInstalledChaincodesArgs.create = function create(properties) {
                return new QueryInstalledChaincodesArgs(properties);
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodesArgs message. Does not implicitly {@link lifecycle.QueryInstalledChaincodesArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {lifecycle.IQueryInstalledChaincodesArgs} message QueryInstalledChaincodesArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodesArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodesArgs message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodesArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {lifecycle.IQueryInstalledChaincodesArgs} message QueryInstalledChaincodesArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodesArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryInstalledChaincodesArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryInstalledChaincodesArgs} QueryInstalledChaincodesArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodesArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodesArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryInstalledChaincodesArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryInstalledChaincodesArgs} QueryInstalledChaincodesArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodesArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryInstalledChaincodesArgs message.
             * @function verify
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryInstalledChaincodesArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a QueryInstalledChaincodesArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryInstalledChaincodesArgs} QueryInstalledChaincodesArgs
             */
            QueryInstalledChaincodesArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryInstalledChaincodesArgs)
                    return object;
                return new $root.lifecycle.QueryInstalledChaincodesArgs();
            };
    
            /**
             * Creates a plain object from a QueryInstalledChaincodesArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @static
             * @param {lifecycle.QueryInstalledChaincodesArgs} message QueryInstalledChaincodesArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryInstalledChaincodesArgs.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this QueryInstalledChaincodesArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryInstalledChaincodesArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryInstalledChaincodesArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryInstalledChaincodesArgs;
        })();
    
        lifecycle.QueryInstalledChaincodesResult = (function() {
    
            /**
             * Properties of a QueryInstalledChaincodesResult.
             * @memberof lifecycle
             * @interface IQueryInstalledChaincodesResult
             * @property {Array.<lifecycle.QueryInstalledChaincodesResult.IInstalledChaincode>|null} [installedChaincodes] QueryInstalledChaincodesResult installedChaincodes
             */
    
            /**
             * Constructs a new QueryInstalledChaincodesResult.
             * @memberof lifecycle
             * @classdesc Represents a QueryInstalledChaincodesResult.
             * @implements IQueryInstalledChaincodesResult
             * @constructor
             * @param {lifecycle.IQueryInstalledChaincodesResult=} [properties] Properties to set
             */
            function QueryInstalledChaincodesResult(properties) {
                this.installedChaincodes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryInstalledChaincodesResult installedChaincodes.
             * @member {Array.<lifecycle.QueryInstalledChaincodesResult.IInstalledChaincode>} installedChaincodes
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @instance
             */
            QueryInstalledChaincodesResult.prototype.installedChaincodes = $util.emptyArray;
    
            /**
             * Creates a new QueryInstalledChaincodesResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {lifecycle.IQueryInstalledChaincodesResult=} [properties] Properties to set
             * @returns {lifecycle.QueryInstalledChaincodesResult} QueryInstalledChaincodesResult instance
             */
            QueryInstalledChaincodesResult.create = function create(properties) {
                return new QueryInstalledChaincodesResult(properties);
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodesResult message. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {lifecycle.IQueryInstalledChaincodesResult} message QueryInstalledChaincodesResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodesResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.installedChaincodes != null && message.installedChaincodes.length)
                    for (var i = 0; i < message.installedChaincodes.length; ++i)
                        $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.encode(message.installedChaincodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified QueryInstalledChaincodesResult message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {lifecycle.IQueryInstalledChaincodesResult} message QueryInstalledChaincodesResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryInstalledChaincodesResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryInstalledChaincodesResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryInstalledChaincodesResult} QueryInstalledChaincodesResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodesResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodesResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.installedChaincodes && message.installedChaincodes.length))
                            message.installedChaincodes = [];
                        message.installedChaincodes.push($root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryInstalledChaincodesResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryInstalledChaincodesResult} QueryInstalledChaincodesResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryInstalledChaincodesResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryInstalledChaincodesResult message.
             * @function verify
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryInstalledChaincodesResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.installedChaincodes != null && message.hasOwnProperty("installedChaincodes")) {
                    if (!Array.isArray(message.installedChaincodes))
                        return "installedChaincodes: array expected";
                    for (var i = 0; i < message.installedChaincodes.length; ++i) {
                        var error = $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.verify(message.installedChaincodes[i]);
                        if (error)
                            return "installedChaincodes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a QueryInstalledChaincodesResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryInstalledChaincodesResult} QueryInstalledChaincodesResult
             */
            QueryInstalledChaincodesResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryInstalledChaincodesResult)
                    return object;
                var message = new $root.lifecycle.QueryInstalledChaincodesResult();
                if (object.installedChaincodes) {
                    if (!Array.isArray(object.installedChaincodes))
                        throw TypeError(".lifecycle.QueryInstalledChaincodesResult.installedChaincodes: array expected");
                    message.installedChaincodes = [];
                    for (var i = 0; i < object.installedChaincodes.length; ++i) {
                        if (typeof object.installedChaincodes[i] !== "object")
                            throw TypeError(".lifecycle.QueryInstalledChaincodesResult.installedChaincodes: object expected");
                        message.installedChaincodes[i] = $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.fromObject(object.installedChaincodes[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryInstalledChaincodesResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @static
             * @param {lifecycle.QueryInstalledChaincodesResult} message QueryInstalledChaincodesResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryInstalledChaincodesResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.installedChaincodes = [];
                if (message.installedChaincodes && message.installedChaincodes.length) {
                    object.installedChaincodes = [];
                    for (var j = 0; j < message.installedChaincodes.length; ++j)
                        object.installedChaincodes[j] = $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.toObject(message.installedChaincodes[j], options);
                }
                return object;
            };
    
            /**
             * Converts this QueryInstalledChaincodesResult to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryInstalledChaincodesResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryInstalledChaincodesResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            QueryInstalledChaincodesResult.InstalledChaincode = (function() {
    
                /**
                 * Properties of an InstalledChaincode.
                 * @memberof lifecycle.QueryInstalledChaincodesResult
                 * @interface IInstalledChaincode
                 * @property {string|null} [packageId] InstalledChaincode packageId
                 * @property {string|null} [label] InstalledChaincode label
                 * @property {Object.<string,lifecycle.QueryInstalledChaincodesResult.IReferences>|null} [references] InstalledChaincode references
                 */
    
                /**
                 * Constructs a new InstalledChaincode.
                 * @memberof lifecycle.QueryInstalledChaincodesResult
                 * @classdesc Represents an InstalledChaincode.
                 * @implements IInstalledChaincode
                 * @constructor
                 * @param {lifecycle.QueryInstalledChaincodesResult.IInstalledChaincode=} [properties] Properties to set
                 */
                function InstalledChaincode(properties) {
                    this.references = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * InstalledChaincode packageId.
                 * @member {string} packageId
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @instance
                 */
                InstalledChaincode.prototype.packageId = "";
    
                /**
                 * InstalledChaincode label.
                 * @member {string} label
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @instance
                 */
                InstalledChaincode.prototype.label = "";
    
                /**
                 * InstalledChaincode references.
                 * @member {Object.<string,lifecycle.QueryInstalledChaincodesResult.IReferences>} references
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @instance
                 */
                InstalledChaincode.prototype.references = $util.emptyObject;
    
                /**
                 * Creates a new InstalledChaincode instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IInstalledChaincode=} [properties] Properties to set
                 * @returns {lifecycle.QueryInstalledChaincodesResult.InstalledChaincode} InstalledChaincode instance
                 */
                InstalledChaincode.create = function create(properties) {
                    return new InstalledChaincode(properties);
                };
    
                /**
                 * Encodes the specified InstalledChaincode message. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IInstalledChaincode} message InstalledChaincode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InstalledChaincode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.packageId != null && message.hasOwnProperty("packageId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.packageId);
                    if (message.label != null && message.hasOwnProperty("label"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);
                    if (message.references != null && message.hasOwnProperty("references"))
                        for (var keys = Object.keys(message.references), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.lifecycle.QueryInstalledChaincodesResult.References.encode(message.references[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Encodes the specified InstalledChaincode message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IInstalledChaincode} message InstalledChaincode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InstalledChaincode.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InstalledChaincode message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.QueryInstalledChaincodesResult.InstalledChaincode} InstalledChaincode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InstalledChaincode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.packageId = reader.string();
                            break;
                        case 2:
                            message.label = reader.string();
                            break;
                        case 3:
                            reader.skip().pos++;
                            if (message.references === $util.emptyObject)
                                message.references = {};
                            key = reader.string();
                            reader.pos++;
                            message.references[key] = $root.lifecycle.QueryInstalledChaincodesResult.References.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InstalledChaincode message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.QueryInstalledChaincodesResult.InstalledChaincode} InstalledChaincode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InstalledChaincode.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InstalledChaincode message.
                 * @function verify
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InstalledChaincode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.packageId != null && message.hasOwnProperty("packageId"))
                        if (!$util.isString(message.packageId))
                            return "packageId: string expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    if (message.references != null && message.hasOwnProperty("references")) {
                        if (!$util.isObject(message.references))
                            return "references: object expected";
                        var key = Object.keys(message.references);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.lifecycle.QueryInstalledChaincodesResult.References.verify(message.references[key[i]]);
                            if (error)
                                return "references." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an InstalledChaincode message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.QueryInstalledChaincodesResult.InstalledChaincode} InstalledChaincode
                 */
                InstalledChaincode.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode)
                        return object;
                    var message = new $root.lifecycle.QueryInstalledChaincodesResult.InstalledChaincode();
                    if (object.packageId != null)
                        message.packageId = String(object.packageId);
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.references) {
                        if (typeof object.references !== "object")
                            throw TypeError(".lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.references: object expected");
                        message.references = {};
                        for (var keys = Object.keys(object.references), i = 0; i < keys.length; ++i) {
                            if (typeof object.references[keys[i]] !== "object")
                                throw TypeError(".lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.references: object expected");
                            message.references[keys[i]] = $root.lifecycle.QueryInstalledChaincodesResult.References.fromObject(object.references[keys[i]]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InstalledChaincode message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.InstalledChaincode} message InstalledChaincode
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InstalledChaincode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.references = {};
                    if (options.defaults) {
                        object.packageId = "";
                        object.label = "";
                    }
                    if (message.packageId != null && message.hasOwnProperty("packageId"))
                        object.packageId = message.packageId;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    var keys2;
                    if (message.references && (keys2 = Object.keys(message.references)).length) {
                        object.references = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.references[keys2[j]] = $root.lifecycle.QueryInstalledChaincodesResult.References.toObject(message.references[keys2[j]], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this InstalledChaincode to JSON.
                 * @function toJSON
                 * @memberof lifecycle.QueryInstalledChaincodesResult.InstalledChaincode
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InstalledChaincode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InstalledChaincode;
            })();
    
            QueryInstalledChaincodesResult.References = (function() {
    
                /**
                 * Properties of a References.
                 * @memberof lifecycle.QueryInstalledChaincodesResult
                 * @interface IReferences
                 * @property {Array.<lifecycle.QueryInstalledChaincodesResult.IChaincode>|null} [chaincodes] References chaincodes
                 */
    
                /**
                 * Constructs a new References.
                 * @memberof lifecycle.QueryInstalledChaincodesResult
                 * @classdesc Represents a References.
                 * @implements IReferences
                 * @constructor
                 * @param {lifecycle.QueryInstalledChaincodesResult.IReferences=} [properties] Properties to set
                 */
                function References(properties) {
                    this.chaincodes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * References chaincodes.
                 * @member {Array.<lifecycle.QueryInstalledChaincodesResult.IChaincode>} chaincodes
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @instance
                 */
                References.prototype.chaincodes = $util.emptyArray;
    
                /**
                 * Creates a new References instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IReferences=} [properties] Properties to set
                 * @returns {lifecycle.QueryInstalledChaincodesResult.References} References instance
                 */
                References.create = function create(properties) {
                    return new References(properties);
                };
    
                /**
                 * Encodes the specified References message. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.References.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IReferences} message References message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                References.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chaincodes != null && message.chaincodes.length)
                        for (var i = 0; i < message.chaincodes.length; ++i)
                            $root.lifecycle.QueryInstalledChaincodesResult.Chaincode.encode(message.chaincodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified References message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.References.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IReferences} message References message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                References.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a References message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.QueryInstalledChaincodesResult.References} References
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                References.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodesResult.References();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.chaincodes && message.chaincodes.length))
                                message.chaincodes = [];
                            message.chaincodes.push($root.lifecycle.QueryInstalledChaincodesResult.Chaincode.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a References message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.QueryInstalledChaincodesResult.References} References
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                References.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a References message.
                 * @function verify
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                References.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.chaincodes != null && message.hasOwnProperty("chaincodes")) {
                        if (!Array.isArray(message.chaincodes))
                            return "chaincodes: array expected";
                        for (var i = 0; i < message.chaincodes.length; ++i) {
                            var error = $root.lifecycle.QueryInstalledChaincodesResult.Chaincode.verify(message.chaincodes[i]);
                            if (error)
                                return "chaincodes." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a References message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.QueryInstalledChaincodesResult.References} References
                 */
                References.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.QueryInstalledChaincodesResult.References)
                        return object;
                    var message = new $root.lifecycle.QueryInstalledChaincodesResult.References();
                    if (object.chaincodes) {
                        if (!Array.isArray(object.chaincodes))
                            throw TypeError(".lifecycle.QueryInstalledChaincodesResult.References.chaincodes: array expected");
                        message.chaincodes = [];
                        for (var i = 0; i < object.chaincodes.length; ++i) {
                            if (typeof object.chaincodes[i] !== "object")
                                throw TypeError(".lifecycle.QueryInstalledChaincodesResult.References.chaincodes: object expected");
                            message.chaincodes[i] = $root.lifecycle.QueryInstalledChaincodesResult.Chaincode.fromObject(object.chaincodes[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a References message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.References} message References
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                References.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.chaincodes = [];
                    if (message.chaincodes && message.chaincodes.length) {
                        object.chaincodes = [];
                        for (var j = 0; j < message.chaincodes.length; ++j)
                            object.chaincodes[j] = $root.lifecycle.QueryInstalledChaincodesResult.Chaincode.toObject(message.chaincodes[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this References to JSON.
                 * @function toJSON
                 * @memberof lifecycle.QueryInstalledChaincodesResult.References
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                References.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return References;
            })();
    
            QueryInstalledChaincodesResult.Chaincode = (function() {
    
                /**
                 * Properties of a Chaincode.
                 * @memberof lifecycle.QueryInstalledChaincodesResult
                 * @interface IChaincode
                 * @property {string|null} [name] Chaincode name
                 * @property {string|null} [version] Chaincode version
                 */
    
                /**
                 * Constructs a new Chaincode.
                 * @memberof lifecycle.QueryInstalledChaincodesResult
                 * @classdesc Represents a Chaincode.
                 * @implements IChaincode
                 * @constructor
                 * @param {lifecycle.QueryInstalledChaincodesResult.IChaincode=} [properties] Properties to set
                 */
                function Chaincode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Chaincode name.
                 * @member {string} name
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @instance
                 */
                Chaincode.prototype.name = "";
    
                /**
                 * Chaincode version.
                 * @member {string} version
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @instance
                 */
                Chaincode.prototype.version = "";
    
                /**
                 * Creates a new Chaincode instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IChaincode=} [properties] Properties to set
                 * @returns {lifecycle.QueryInstalledChaincodesResult.Chaincode} Chaincode instance
                 */
                Chaincode.create = function create(properties) {
                    return new Chaincode(properties);
                };
    
                /**
                 * Encodes the specified Chaincode message. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.Chaincode.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IChaincode} message Chaincode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Chaincode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.version != null && message.hasOwnProperty("version"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                    return writer;
                };
    
                /**
                 * Encodes the specified Chaincode message, length delimited. Does not implicitly {@link lifecycle.QueryInstalledChaincodesResult.Chaincode.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.IChaincode} message Chaincode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Chaincode.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Chaincode message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.QueryInstalledChaincodesResult.Chaincode} Chaincode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Chaincode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryInstalledChaincodesResult.Chaincode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.version = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Chaincode message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.QueryInstalledChaincodesResult.Chaincode} Chaincode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Chaincode.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Chaincode message.
                 * @function verify
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Chaincode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isString(message.version))
                            return "version: string expected";
                    return null;
                };
    
                /**
                 * Creates a Chaincode message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.QueryInstalledChaincodesResult.Chaincode} Chaincode
                 */
                Chaincode.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.QueryInstalledChaincodesResult.Chaincode)
                        return object;
                    var message = new $root.lifecycle.QueryInstalledChaincodesResult.Chaincode();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.version != null)
                        message.version = String(object.version);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Chaincode message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @static
                 * @param {lifecycle.QueryInstalledChaincodesResult.Chaincode} message Chaincode
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Chaincode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.version = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    return object;
                };
    
                /**
                 * Converts this Chaincode to JSON.
                 * @function toJSON
                 * @memberof lifecycle.QueryInstalledChaincodesResult.Chaincode
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Chaincode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Chaincode;
            })();
    
            return QueryInstalledChaincodesResult;
        })();
    
        lifecycle.ApproveChaincodeDefinitionForMyOrgArgs = (function() {
    
            /**
             * Properties of an ApproveChaincodeDefinitionForMyOrgArgs.
             * @memberof lifecycle
             * @interface IApproveChaincodeDefinitionForMyOrgArgs
             * @property {number|Long|null} [sequence] ApproveChaincodeDefinitionForMyOrgArgs sequence
             * @property {string|null} [name] ApproveChaincodeDefinitionForMyOrgArgs name
             * @property {string|null} [version] ApproveChaincodeDefinitionForMyOrgArgs version
             * @property {string|null} [endorsementPlugin] ApproveChaincodeDefinitionForMyOrgArgs endorsementPlugin
             * @property {string|null} [validationPlugin] ApproveChaincodeDefinitionForMyOrgArgs validationPlugin
             * @property {Uint8Array|null} [validationParameter] ApproveChaincodeDefinitionForMyOrgArgs validationParameter
             * @property {common.ICollectionConfigPackage|null} [collections] ApproveChaincodeDefinitionForMyOrgArgs collections
             * @property {boolean|null} [initRequired] ApproveChaincodeDefinitionForMyOrgArgs initRequired
             * @property {lifecycle.IChaincodeSource|null} [source] ApproveChaincodeDefinitionForMyOrgArgs source
             */
    
            /**
             * Constructs a new ApproveChaincodeDefinitionForMyOrgArgs.
             * @memberof lifecycle
             * @classdesc Represents an ApproveChaincodeDefinitionForMyOrgArgs.
             * @implements IApproveChaincodeDefinitionForMyOrgArgs
             * @constructor
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgArgs=} [properties] Properties to set
             */
            function ApproveChaincodeDefinitionForMyOrgArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs sequence.
             * @member {number|Long} sequence
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs name.
             * @member {string} name
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.name = "";
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs version.
             * @member {string} version
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.version = "";
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs endorsementPlugin.
             * @member {string} endorsementPlugin
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.endorsementPlugin = "";
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs validationPlugin.
             * @member {string} validationPlugin
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.validationPlugin = "";
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs validationParameter.
             * @member {Uint8Array} validationParameter
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.validationParameter = $util.newBuffer([]);
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs collections.
             * @member {common.ICollectionConfigPackage|null|undefined} collections
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.collections = null;
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs initRequired.
             * @member {boolean} initRequired
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.initRequired = false;
    
            /**
             * ApproveChaincodeDefinitionForMyOrgArgs source.
             * @member {lifecycle.IChaincodeSource|null|undefined} source
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.source = null;
    
            /**
             * Creates a new ApproveChaincodeDefinitionForMyOrgArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgArgs=} [properties] Properties to set
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgArgs} ApproveChaincodeDefinitionForMyOrgArgs instance
             */
            ApproveChaincodeDefinitionForMyOrgArgs.create = function create(properties) {
                return new ApproveChaincodeDefinitionForMyOrgArgs(properties);
            };
    
            /**
             * Encodes the specified ApproveChaincodeDefinitionForMyOrgArgs message. Does not implicitly {@link lifecycle.ApproveChaincodeDefinitionForMyOrgArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgArgs} message ApproveChaincodeDefinitionForMyOrgArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveChaincodeDefinitionForMyOrgArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.sequence);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.endorsementPlugin);
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.validationPlugin);
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.validationParameter);
                if (message.collections != null && message.hasOwnProperty("collections"))
                    $root.common.CollectionConfigPackage.encode(message.collections, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.initRequired);
                if (message.source != null && message.hasOwnProperty("source"))
                    $root.lifecycle.ChaincodeSource.encode(message.source, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ApproveChaincodeDefinitionForMyOrgArgs message, length delimited. Does not implicitly {@link lifecycle.ApproveChaincodeDefinitionForMyOrgArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgArgs} message ApproveChaincodeDefinitionForMyOrgArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveChaincodeDefinitionForMyOrgArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ApproveChaincodeDefinitionForMyOrgArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgArgs} ApproveChaincodeDefinitionForMyOrgArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveChaincodeDefinitionForMyOrgArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ApproveChaincodeDefinitionForMyOrgArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sequence = reader.int64();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.version = reader.string();
                        break;
                    case 4:
                        message.endorsementPlugin = reader.string();
                        break;
                    case 5:
                        message.validationPlugin = reader.string();
                        break;
                    case 6:
                        message.validationParameter = reader.bytes();
                        break;
                    case 7:
                        message.collections = $root.common.CollectionConfigPackage.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.initRequired = reader.bool();
                        break;
                    case 9:
                        message.source = $root.lifecycle.ChaincodeSource.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ApproveChaincodeDefinitionForMyOrgArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgArgs} ApproveChaincodeDefinitionForMyOrgArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveChaincodeDefinitionForMyOrgArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ApproveChaincodeDefinitionForMyOrgArgs message.
             * @function verify
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApproveChaincodeDefinitionForMyOrgArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    if (!$util.isString(message.endorsementPlugin))
                        return "endorsementPlugin: string expected";
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    if (!$util.isString(message.validationPlugin))
                        return "validationPlugin: string expected";
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    if (!(message.validationParameter && typeof message.validationParameter.length === "number" || $util.isString(message.validationParameter)))
                        return "validationParameter: buffer expected";
                if (message.collections != null && message.hasOwnProperty("collections")) {
                    var error = $root.common.CollectionConfigPackage.verify(message.collections);
                    if (error)
                        return "collections." + error;
                }
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    if (typeof message.initRequired !== "boolean")
                        return "initRequired: boolean expected";
                if (message.source != null && message.hasOwnProperty("source")) {
                    var error = $root.lifecycle.ChaincodeSource.verify(message.source);
                    if (error)
                        return "source." + error;
                }
                return null;
            };
    
            /**
             * Creates an ApproveChaincodeDefinitionForMyOrgArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgArgs} ApproveChaincodeDefinitionForMyOrgArgs
             */
            ApproveChaincodeDefinitionForMyOrgArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.ApproveChaincodeDefinitionForMyOrgArgs)
                    return object;
                var message = new $root.lifecycle.ApproveChaincodeDefinitionForMyOrgArgs();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.endorsementPlugin != null)
                    message.endorsementPlugin = String(object.endorsementPlugin);
                if (object.validationPlugin != null)
                    message.validationPlugin = String(object.validationPlugin);
                if (object.validationParameter != null)
                    if (typeof object.validationParameter === "string")
                        $util.base64.decode(object.validationParameter, message.validationParameter = $util.newBuffer($util.base64.length(object.validationParameter)), 0);
                    else if (object.validationParameter.length)
                        message.validationParameter = object.validationParameter;
                if (object.collections != null) {
                    if (typeof object.collections !== "object")
                        throw TypeError(".lifecycle.ApproveChaincodeDefinitionForMyOrgArgs.collections: object expected");
                    message.collections = $root.common.CollectionConfigPackage.fromObject(object.collections);
                }
                if (object.initRequired != null)
                    message.initRequired = Boolean(object.initRequired);
                if (object.source != null) {
                    if (typeof object.source !== "object")
                        throw TypeError(".lifecycle.ApproveChaincodeDefinitionForMyOrgArgs.source: object expected");
                    message.source = $root.lifecycle.ChaincodeSource.fromObject(object.source);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an ApproveChaincodeDefinitionForMyOrgArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @static
             * @param {lifecycle.ApproveChaincodeDefinitionForMyOrgArgs} message ApproveChaincodeDefinitionForMyOrgArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ApproveChaincodeDefinitionForMyOrgArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                    object.name = "";
                    object.version = "";
                    object.endorsementPlugin = "";
                    object.validationPlugin = "";
                    if (options.bytes === String)
                        object.validationParameter = "";
                    else {
                        object.validationParameter = [];
                        if (options.bytes !== Array)
                            object.validationParameter = $util.newBuffer(object.validationParameter);
                    }
                    object.collections = null;
                    object.initRequired = false;
                    object.source = null;
                }
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    object.endorsementPlugin = message.endorsementPlugin;
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    object.validationPlugin = message.validationPlugin;
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    object.validationParameter = options.bytes === String ? $util.base64.encode(message.validationParameter, 0, message.validationParameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.validationParameter) : message.validationParameter;
                if (message.collections != null && message.hasOwnProperty("collections"))
                    object.collections = $root.common.CollectionConfigPackage.toObject(message.collections, options);
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    object.initRequired = message.initRequired;
                if (message.source != null && message.hasOwnProperty("source"))
                    object.source = $root.lifecycle.ChaincodeSource.toObject(message.source, options);
                return object;
            };
    
            /**
             * Converts this ApproveChaincodeDefinitionForMyOrgArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ApproveChaincodeDefinitionForMyOrgArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ApproveChaincodeDefinitionForMyOrgArgs;
        })();
    
        lifecycle.ChaincodeSource = (function() {
    
            /**
             * Properties of a ChaincodeSource.
             * @memberof lifecycle
             * @interface IChaincodeSource
             * @property {lifecycle.ChaincodeSource.IUnavailable|null} [unavailable] ChaincodeSource unavailable
             * @property {lifecycle.ChaincodeSource.ILocal|null} [localPackage] ChaincodeSource localPackage
             */
    
            /**
             * Constructs a new ChaincodeSource.
             * @memberof lifecycle
             * @classdesc Represents a ChaincodeSource.
             * @implements IChaincodeSource
             * @constructor
             * @param {lifecycle.IChaincodeSource=} [properties] Properties to set
             */
            function ChaincodeSource(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeSource unavailable.
             * @member {lifecycle.ChaincodeSource.IUnavailable|null|undefined} unavailable
             * @memberof lifecycle.ChaincodeSource
             * @instance
             */
            ChaincodeSource.prototype.unavailable = null;
    
            /**
             * ChaincodeSource localPackage.
             * @member {lifecycle.ChaincodeSource.ILocal|null|undefined} localPackage
             * @memberof lifecycle.ChaincodeSource
             * @instance
             */
            ChaincodeSource.prototype.localPackage = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * ChaincodeSource Type.
             * @member {"unavailable"|"localPackage"|undefined} Type
             * @memberof lifecycle.ChaincodeSource
             * @instance
             */
            Object.defineProperty(ChaincodeSource.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["unavailable", "localPackage"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new ChaincodeSource instance using the specified properties.
             * @function create
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {lifecycle.IChaincodeSource=} [properties] Properties to set
             * @returns {lifecycle.ChaincodeSource} ChaincodeSource instance
             */
            ChaincodeSource.create = function create(properties) {
                return new ChaincodeSource(properties);
            };
    
            /**
             * Encodes the specified ChaincodeSource message. Does not implicitly {@link lifecycle.ChaincodeSource.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {lifecycle.IChaincodeSource} message ChaincodeSource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeSource.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.unavailable != null && message.hasOwnProperty("unavailable"))
                    $root.lifecycle.ChaincodeSource.Unavailable.encode(message.unavailable, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.localPackage != null && message.hasOwnProperty("localPackage"))
                    $root.lifecycle.ChaincodeSource.Local.encode(message.localPackage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeSource message, length delimited. Does not implicitly {@link lifecycle.ChaincodeSource.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {lifecycle.IChaincodeSource} message ChaincodeSource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeSource.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeSource message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.ChaincodeSource} ChaincodeSource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeSource.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ChaincodeSource();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.unavailable = $root.lifecycle.ChaincodeSource.Unavailable.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.localPackage = $root.lifecycle.ChaincodeSource.Local.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeSource message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.ChaincodeSource} ChaincodeSource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeSource.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeSource message.
             * @function verify
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeSource.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.unavailable != null && message.hasOwnProperty("unavailable")) {
                    properties.Type = 1;
                    {
                        var error = $root.lifecycle.ChaincodeSource.Unavailable.verify(message.unavailable);
                        if (error)
                            return "unavailable." + error;
                    }
                }
                if (message.localPackage != null && message.hasOwnProperty("localPackage")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.lifecycle.ChaincodeSource.Local.verify(message.localPackage);
                        if (error)
                            return "localPackage." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a ChaincodeSource message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.ChaincodeSource} ChaincodeSource
             */
            ChaincodeSource.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.ChaincodeSource)
                    return object;
                var message = new $root.lifecycle.ChaincodeSource();
                if (object.unavailable != null) {
                    if (typeof object.unavailable !== "object")
                        throw TypeError(".lifecycle.ChaincodeSource.unavailable: object expected");
                    message.unavailable = $root.lifecycle.ChaincodeSource.Unavailable.fromObject(object.unavailable);
                }
                if (object.localPackage != null) {
                    if (typeof object.localPackage !== "object")
                        throw TypeError(".lifecycle.ChaincodeSource.localPackage: object expected");
                    message.localPackage = $root.lifecycle.ChaincodeSource.Local.fromObject(object.localPackage);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeSource message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.ChaincodeSource
             * @static
             * @param {lifecycle.ChaincodeSource} message ChaincodeSource
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeSource.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.unavailable != null && message.hasOwnProperty("unavailable")) {
                    object.unavailable = $root.lifecycle.ChaincodeSource.Unavailable.toObject(message.unavailable, options);
                    if (options.oneofs)
                        object.Type = "unavailable";
                }
                if (message.localPackage != null && message.hasOwnProperty("localPackage")) {
                    object.localPackage = $root.lifecycle.ChaincodeSource.Local.toObject(message.localPackage, options);
                    if (options.oneofs)
                        object.Type = "localPackage";
                }
                return object;
            };
    
            /**
             * Converts this ChaincodeSource to JSON.
             * @function toJSON
             * @memberof lifecycle.ChaincodeSource
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeSource.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            ChaincodeSource.Unavailable = (function() {
    
                /**
                 * Properties of an Unavailable.
                 * @memberof lifecycle.ChaincodeSource
                 * @interface IUnavailable
                 */
    
                /**
                 * Constructs a new Unavailable.
                 * @memberof lifecycle.ChaincodeSource
                 * @classdesc Represents an Unavailable.
                 * @implements IUnavailable
                 * @constructor
                 * @param {lifecycle.ChaincodeSource.IUnavailable=} [properties] Properties to set
                 */
                function Unavailable(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new Unavailable instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {lifecycle.ChaincodeSource.IUnavailable=} [properties] Properties to set
                 * @returns {lifecycle.ChaincodeSource.Unavailable} Unavailable instance
                 */
                Unavailable.create = function create(properties) {
                    return new Unavailable(properties);
                };
    
                /**
                 * Encodes the specified Unavailable message. Does not implicitly {@link lifecycle.ChaincodeSource.Unavailable.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {lifecycle.ChaincodeSource.IUnavailable} message Unavailable message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Unavailable.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified Unavailable message, length delimited. Does not implicitly {@link lifecycle.ChaincodeSource.Unavailable.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {lifecycle.ChaincodeSource.IUnavailable} message Unavailable message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Unavailable.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Unavailable message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.ChaincodeSource.Unavailable} Unavailable
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Unavailable.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ChaincodeSource.Unavailable();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Unavailable message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.ChaincodeSource.Unavailable} Unavailable
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Unavailable.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Unavailable message.
                 * @function verify
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Unavailable.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an Unavailable message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.ChaincodeSource.Unavailable} Unavailable
                 */
                Unavailable.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.ChaincodeSource.Unavailable)
                        return object;
                    return new $root.lifecycle.ChaincodeSource.Unavailable();
                };
    
                /**
                 * Creates a plain object from an Unavailable message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @static
                 * @param {lifecycle.ChaincodeSource.Unavailable} message Unavailable
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Unavailable.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this Unavailable to JSON.
                 * @function toJSON
                 * @memberof lifecycle.ChaincodeSource.Unavailable
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Unavailable.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Unavailable;
            })();
    
            ChaincodeSource.Local = (function() {
    
                /**
                 * Properties of a Local.
                 * @memberof lifecycle.ChaincodeSource
                 * @interface ILocal
                 * @property {string|null} [packageId] Local packageId
                 */
    
                /**
                 * Constructs a new Local.
                 * @memberof lifecycle.ChaincodeSource
                 * @classdesc Represents a Local.
                 * @implements ILocal
                 * @constructor
                 * @param {lifecycle.ChaincodeSource.ILocal=} [properties] Properties to set
                 */
                function Local(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Local packageId.
                 * @member {string} packageId
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @instance
                 */
                Local.prototype.packageId = "";
    
                /**
                 * Creates a new Local instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {lifecycle.ChaincodeSource.ILocal=} [properties] Properties to set
                 * @returns {lifecycle.ChaincodeSource.Local} Local instance
                 */
                Local.create = function create(properties) {
                    return new Local(properties);
                };
    
                /**
                 * Encodes the specified Local message. Does not implicitly {@link lifecycle.ChaincodeSource.Local.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {lifecycle.ChaincodeSource.ILocal} message Local message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Local.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.packageId != null && message.hasOwnProperty("packageId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.packageId);
                    return writer;
                };
    
                /**
                 * Encodes the specified Local message, length delimited. Does not implicitly {@link lifecycle.ChaincodeSource.Local.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {lifecycle.ChaincodeSource.ILocal} message Local message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Local.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Local message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.ChaincodeSource.Local} Local
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Local.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ChaincodeSource.Local();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.packageId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Local message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.ChaincodeSource.Local} Local
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Local.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Local message.
                 * @function verify
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Local.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.packageId != null && message.hasOwnProperty("packageId"))
                        if (!$util.isString(message.packageId))
                            return "packageId: string expected";
                    return null;
                };
    
                /**
                 * Creates a Local message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.ChaincodeSource.Local} Local
                 */
                Local.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.ChaincodeSource.Local)
                        return object;
                    var message = new $root.lifecycle.ChaincodeSource.Local();
                    if (object.packageId != null)
                        message.packageId = String(object.packageId);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Local message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @static
                 * @param {lifecycle.ChaincodeSource.Local} message Local
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Local.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.packageId = "";
                    if (message.packageId != null && message.hasOwnProperty("packageId"))
                        object.packageId = message.packageId;
                    return object;
                };
    
                /**
                 * Converts this Local to JSON.
                 * @function toJSON
                 * @memberof lifecycle.ChaincodeSource.Local
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Local.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Local;
            })();
    
            return ChaincodeSource;
        })();
    
        lifecycle.ApproveChaincodeDefinitionForMyOrgResult = (function() {
    
            /**
             * Properties of an ApproveChaincodeDefinitionForMyOrgResult.
             * @memberof lifecycle
             * @interface IApproveChaincodeDefinitionForMyOrgResult
             */
    
            /**
             * Constructs a new ApproveChaincodeDefinitionForMyOrgResult.
             * @memberof lifecycle
             * @classdesc Represents an ApproveChaincodeDefinitionForMyOrgResult.
             * @implements IApproveChaincodeDefinitionForMyOrgResult
             * @constructor
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgResult=} [properties] Properties to set
             */
            function ApproveChaincodeDefinitionForMyOrgResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ApproveChaincodeDefinitionForMyOrgResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgResult=} [properties] Properties to set
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgResult} ApproveChaincodeDefinitionForMyOrgResult instance
             */
            ApproveChaincodeDefinitionForMyOrgResult.create = function create(properties) {
                return new ApproveChaincodeDefinitionForMyOrgResult(properties);
            };
    
            /**
             * Encodes the specified ApproveChaincodeDefinitionForMyOrgResult message. Does not implicitly {@link lifecycle.ApproveChaincodeDefinitionForMyOrgResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgResult} message ApproveChaincodeDefinitionForMyOrgResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveChaincodeDefinitionForMyOrgResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified ApproveChaincodeDefinitionForMyOrgResult message, length delimited. Does not implicitly {@link lifecycle.ApproveChaincodeDefinitionForMyOrgResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {lifecycle.IApproveChaincodeDefinitionForMyOrgResult} message ApproveChaincodeDefinitionForMyOrgResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ApproveChaincodeDefinitionForMyOrgResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ApproveChaincodeDefinitionForMyOrgResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgResult} ApproveChaincodeDefinitionForMyOrgResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveChaincodeDefinitionForMyOrgResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ApproveChaincodeDefinitionForMyOrgResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ApproveChaincodeDefinitionForMyOrgResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgResult} ApproveChaincodeDefinitionForMyOrgResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ApproveChaincodeDefinitionForMyOrgResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ApproveChaincodeDefinitionForMyOrgResult message.
             * @function verify
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ApproveChaincodeDefinitionForMyOrgResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates an ApproveChaincodeDefinitionForMyOrgResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.ApproveChaincodeDefinitionForMyOrgResult} ApproveChaincodeDefinitionForMyOrgResult
             */
            ApproveChaincodeDefinitionForMyOrgResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.ApproveChaincodeDefinitionForMyOrgResult)
                    return object;
                return new $root.lifecycle.ApproveChaincodeDefinitionForMyOrgResult();
            };
    
            /**
             * Creates a plain object from an ApproveChaincodeDefinitionForMyOrgResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @static
             * @param {lifecycle.ApproveChaincodeDefinitionForMyOrgResult} message ApproveChaincodeDefinitionForMyOrgResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ApproveChaincodeDefinitionForMyOrgResult.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this ApproveChaincodeDefinitionForMyOrgResult to JSON.
             * @function toJSON
             * @memberof lifecycle.ApproveChaincodeDefinitionForMyOrgResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ApproveChaincodeDefinitionForMyOrgResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ApproveChaincodeDefinitionForMyOrgResult;
        })();
    
        lifecycle.CommitChaincodeDefinitionArgs = (function() {
    
            /**
             * Properties of a CommitChaincodeDefinitionArgs.
             * @memberof lifecycle
             * @interface ICommitChaincodeDefinitionArgs
             * @property {number|Long|null} [sequence] CommitChaincodeDefinitionArgs sequence
             * @property {string|null} [name] CommitChaincodeDefinitionArgs name
             * @property {string|null} [version] CommitChaincodeDefinitionArgs version
             * @property {string|null} [endorsementPlugin] CommitChaincodeDefinitionArgs endorsementPlugin
             * @property {string|null} [validationPlugin] CommitChaincodeDefinitionArgs validationPlugin
             * @property {Uint8Array|null} [validationParameter] CommitChaincodeDefinitionArgs validationParameter
             * @property {common.ICollectionConfigPackage|null} [collections] CommitChaincodeDefinitionArgs collections
             * @property {boolean|null} [initRequired] CommitChaincodeDefinitionArgs initRequired
             */
    
            /**
             * Constructs a new CommitChaincodeDefinitionArgs.
             * @memberof lifecycle
             * @classdesc Represents a CommitChaincodeDefinitionArgs.
             * @implements ICommitChaincodeDefinitionArgs
             * @constructor
             * @param {lifecycle.ICommitChaincodeDefinitionArgs=} [properties] Properties to set
             */
            function CommitChaincodeDefinitionArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CommitChaincodeDefinitionArgs sequence.
             * @member {number|Long} sequence
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * CommitChaincodeDefinitionArgs name.
             * @member {string} name
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.name = "";
    
            /**
             * CommitChaincodeDefinitionArgs version.
             * @member {string} version
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.version = "";
    
            /**
             * CommitChaincodeDefinitionArgs endorsementPlugin.
             * @member {string} endorsementPlugin
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.endorsementPlugin = "";
    
            /**
             * CommitChaincodeDefinitionArgs validationPlugin.
             * @member {string} validationPlugin
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.validationPlugin = "";
    
            /**
             * CommitChaincodeDefinitionArgs validationParameter.
             * @member {Uint8Array} validationParameter
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.validationParameter = $util.newBuffer([]);
    
            /**
             * CommitChaincodeDefinitionArgs collections.
             * @member {common.ICollectionConfigPackage|null|undefined} collections
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.collections = null;
    
            /**
             * CommitChaincodeDefinitionArgs initRequired.
             * @member {boolean} initRequired
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             */
            CommitChaincodeDefinitionArgs.prototype.initRequired = false;
    
            /**
             * Creates a new CommitChaincodeDefinitionArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.ICommitChaincodeDefinitionArgs=} [properties] Properties to set
             * @returns {lifecycle.CommitChaincodeDefinitionArgs} CommitChaincodeDefinitionArgs instance
             */
            CommitChaincodeDefinitionArgs.create = function create(properties) {
                return new CommitChaincodeDefinitionArgs(properties);
            };
    
            /**
             * Encodes the specified CommitChaincodeDefinitionArgs message. Does not implicitly {@link lifecycle.CommitChaincodeDefinitionArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.ICommitChaincodeDefinitionArgs} message CommitChaincodeDefinitionArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitChaincodeDefinitionArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.sequence);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.endorsementPlugin);
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.validationPlugin);
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.validationParameter);
                if (message.collections != null && message.hasOwnProperty("collections"))
                    $root.common.CollectionConfigPackage.encode(message.collections, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.initRequired);
                return writer;
            };
    
            /**
             * Encodes the specified CommitChaincodeDefinitionArgs message, length delimited. Does not implicitly {@link lifecycle.CommitChaincodeDefinitionArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.ICommitChaincodeDefinitionArgs} message CommitChaincodeDefinitionArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitChaincodeDefinitionArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CommitChaincodeDefinitionArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.CommitChaincodeDefinitionArgs} CommitChaincodeDefinitionArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitChaincodeDefinitionArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.CommitChaincodeDefinitionArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sequence = reader.int64();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.version = reader.string();
                        break;
                    case 4:
                        message.endorsementPlugin = reader.string();
                        break;
                    case 5:
                        message.validationPlugin = reader.string();
                        break;
                    case 6:
                        message.validationParameter = reader.bytes();
                        break;
                    case 7:
                        message.collections = $root.common.CollectionConfigPackage.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.initRequired = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CommitChaincodeDefinitionArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.CommitChaincodeDefinitionArgs} CommitChaincodeDefinitionArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitChaincodeDefinitionArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CommitChaincodeDefinitionArgs message.
             * @function verify
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommitChaincodeDefinitionArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    if (!$util.isString(message.endorsementPlugin))
                        return "endorsementPlugin: string expected";
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    if (!$util.isString(message.validationPlugin))
                        return "validationPlugin: string expected";
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    if (!(message.validationParameter && typeof message.validationParameter.length === "number" || $util.isString(message.validationParameter)))
                        return "validationParameter: buffer expected";
                if (message.collections != null && message.hasOwnProperty("collections")) {
                    var error = $root.common.CollectionConfigPackage.verify(message.collections);
                    if (error)
                        return "collections." + error;
                }
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    if (typeof message.initRequired !== "boolean")
                        return "initRequired: boolean expected";
                return null;
            };
    
            /**
             * Creates a CommitChaincodeDefinitionArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.CommitChaincodeDefinitionArgs} CommitChaincodeDefinitionArgs
             */
            CommitChaincodeDefinitionArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.CommitChaincodeDefinitionArgs)
                    return object;
                var message = new $root.lifecycle.CommitChaincodeDefinitionArgs();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.endorsementPlugin != null)
                    message.endorsementPlugin = String(object.endorsementPlugin);
                if (object.validationPlugin != null)
                    message.validationPlugin = String(object.validationPlugin);
                if (object.validationParameter != null)
                    if (typeof object.validationParameter === "string")
                        $util.base64.decode(object.validationParameter, message.validationParameter = $util.newBuffer($util.base64.length(object.validationParameter)), 0);
                    else if (object.validationParameter.length)
                        message.validationParameter = object.validationParameter;
                if (object.collections != null) {
                    if (typeof object.collections !== "object")
                        throw TypeError(".lifecycle.CommitChaincodeDefinitionArgs.collections: object expected");
                    message.collections = $root.common.CollectionConfigPackage.fromObject(object.collections);
                }
                if (object.initRequired != null)
                    message.initRequired = Boolean(object.initRequired);
                return message;
            };
    
            /**
             * Creates a plain object from a CommitChaincodeDefinitionArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.CommitChaincodeDefinitionArgs} message CommitChaincodeDefinitionArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommitChaincodeDefinitionArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                    object.name = "";
                    object.version = "";
                    object.endorsementPlugin = "";
                    object.validationPlugin = "";
                    if (options.bytes === String)
                        object.validationParameter = "";
                    else {
                        object.validationParameter = [];
                        if (options.bytes !== Array)
                            object.validationParameter = $util.newBuffer(object.validationParameter);
                    }
                    object.collections = null;
                    object.initRequired = false;
                }
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    object.endorsementPlugin = message.endorsementPlugin;
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    object.validationPlugin = message.validationPlugin;
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    object.validationParameter = options.bytes === String ? $util.base64.encode(message.validationParameter, 0, message.validationParameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.validationParameter) : message.validationParameter;
                if (message.collections != null && message.hasOwnProperty("collections"))
                    object.collections = $root.common.CollectionConfigPackage.toObject(message.collections, options);
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    object.initRequired = message.initRequired;
                return object;
            };
    
            /**
             * Converts this CommitChaincodeDefinitionArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.CommitChaincodeDefinitionArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommitChaincodeDefinitionArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CommitChaincodeDefinitionArgs;
        })();
    
        lifecycle.CommitChaincodeDefinitionResult = (function() {
    
            /**
             * Properties of a CommitChaincodeDefinitionResult.
             * @memberof lifecycle
             * @interface ICommitChaincodeDefinitionResult
             */
    
            /**
             * Constructs a new CommitChaincodeDefinitionResult.
             * @memberof lifecycle
             * @classdesc Represents a CommitChaincodeDefinitionResult.
             * @implements ICommitChaincodeDefinitionResult
             * @constructor
             * @param {lifecycle.ICommitChaincodeDefinitionResult=} [properties] Properties to set
             */
            function CommitChaincodeDefinitionResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new CommitChaincodeDefinitionResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {lifecycle.ICommitChaincodeDefinitionResult=} [properties] Properties to set
             * @returns {lifecycle.CommitChaincodeDefinitionResult} CommitChaincodeDefinitionResult instance
             */
            CommitChaincodeDefinitionResult.create = function create(properties) {
                return new CommitChaincodeDefinitionResult(properties);
            };
    
            /**
             * Encodes the specified CommitChaincodeDefinitionResult message. Does not implicitly {@link lifecycle.CommitChaincodeDefinitionResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {lifecycle.ICommitChaincodeDefinitionResult} message CommitChaincodeDefinitionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitChaincodeDefinitionResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified CommitChaincodeDefinitionResult message, length delimited. Does not implicitly {@link lifecycle.CommitChaincodeDefinitionResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {lifecycle.ICommitChaincodeDefinitionResult} message CommitChaincodeDefinitionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitChaincodeDefinitionResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CommitChaincodeDefinitionResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.CommitChaincodeDefinitionResult} CommitChaincodeDefinitionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitChaincodeDefinitionResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.CommitChaincodeDefinitionResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CommitChaincodeDefinitionResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.CommitChaincodeDefinitionResult} CommitChaincodeDefinitionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitChaincodeDefinitionResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CommitChaincodeDefinitionResult message.
             * @function verify
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommitChaincodeDefinitionResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a CommitChaincodeDefinitionResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.CommitChaincodeDefinitionResult} CommitChaincodeDefinitionResult
             */
            CommitChaincodeDefinitionResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.CommitChaincodeDefinitionResult)
                    return object;
                return new $root.lifecycle.CommitChaincodeDefinitionResult();
            };
    
            /**
             * Creates a plain object from a CommitChaincodeDefinitionResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @static
             * @param {lifecycle.CommitChaincodeDefinitionResult} message CommitChaincodeDefinitionResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommitChaincodeDefinitionResult.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this CommitChaincodeDefinitionResult to JSON.
             * @function toJSON
             * @memberof lifecycle.CommitChaincodeDefinitionResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommitChaincodeDefinitionResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CommitChaincodeDefinitionResult;
        })();
    
        lifecycle.CheckCommitReadinessArgs = (function() {
    
            /**
             * Properties of a CheckCommitReadinessArgs.
             * @memberof lifecycle
             * @interface ICheckCommitReadinessArgs
             * @property {number|Long|null} [sequence] CheckCommitReadinessArgs sequence
             * @property {string|null} [name] CheckCommitReadinessArgs name
             * @property {string|null} [version] CheckCommitReadinessArgs version
             * @property {string|null} [endorsementPlugin] CheckCommitReadinessArgs endorsementPlugin
             * @property {string|null} [validationPlugin] CheckCommitReadinessArgs validationPlugin
             * @property {Uint8Array|null} [validationParameter] CheckCommitReadinessArgs validationParameter
             * @property {common.ICollectionConfigPackage|null} [collections] CheckCommitReadinessArgs collections
             * @property {boolean|null} [initRequired] CheckCommitReadinessArgs initRequired
             */
    
            /**
             * Constructs a new CheckCommitReadinessArgs.
             * @memberof lifecycle
             * @classdesc Represents a CheckCommitReadinessArgs.
             * @implements ICheckCommitReadinessArgs
             * @constructor
             * @param {lifecycle.ICheckCommitReadinessArgs=} [properties] Properties to set
             */
            function CheckCommitReadinessArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CheckCommitReadinessArgs sequence.
             * @member {number|Long} sequence
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * CheckCommitReadinessArgs name.
             * @member {string} name
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.name = "";
    
            /**
             * CheckCommitReadinessArgs version.
             * @member {string} version
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.version = "";
    
            /**
             * CheckCommitReadinessArgs endorsementPlugin.
             * @member {string} endorsementPlugin
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.endorsementPlugin = "";
    
            /**
             * CheckCommitReadinessArgs validationPlugin.
             * @member {string} validationPlugin
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.validationPlugin = "";
    
            /**
             * CheckCommitReadinessArgs validationParameter.
             * @member {Uint8Array} validationParameter
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.validationParameter = $util.newBuffer([]);
    
            /**
             * CheckCommitReadinessArgs collections.
             * @member {common.ICollectionConfigPackage|null|undefined} collections
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.collections = null;
    
            /**
             * CheckCommitReadinessArgs initRequired.
             * @member {boolean} initRequired
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             */
            CheckCommitReadinessArgs.prototype.initRequired = false;
    
            /**
             * Creates a new CheckCommitReadinessArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {lifecycle.ICheckCommitReadinessArgs=} [properties] Properties to set
             * @returns {lifecycle.CheckCommitReadinessArgs} CheckCommitReadinessArgs instance
             */
            CheckCommitReadinessArgs.create = function create(properties) {
                return new CheckCommitReadinessArgs(properties);
            };
    
            /**
             * Encodes the specified CheckCommitReadinessArgs message. Does not implicitly {@link lifecycle.CheckCommitReadinessArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {lifecycle.ICheckCommitReadinessArgs} message CheckCommitReadinessArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckCommitReadinessArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.sequence);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.endorsementPlugin);
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.validationPlugin);
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.validationParameter);
                if (message.collections != null && message.hasOwnProperty("collections"))
                    $root.common.CollectionConfigPackage.encode(message.collections, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.initRequired);
                return writer;
            };
    
            /**
             * Encodes the specified CheckCommitReadinessArgs message, length delimited. Does not implicitly {@link lifecycle.CheckCommitReadinessArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {lifecycle.ICheckCommitReadinessArgs} message CheckCommitReadinessArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckCommitReadinessArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CheckCommitReadinessArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.CheckCommitReadinessArgs} CheckCommitReadinessArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckCommitReadinessArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.CheckCommitReadinessArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sequence = reader.int64();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.version = reader.string();
                        break;
                    case 4:
                        message.endorsementPlugin = reader.string();
                        break;
                    case 5:
                        message.validationPlugin = reader.string();
                        break;
                    case 6:
                        message.validationParameter = reader.bytes();
                        break;
                    case 7:
                        message.collections = $root.common.CollectionConfigPackage.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.initRequired = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CheckCommitReadinessArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.CheckCommitReadinessArgs} CheckCommitReadinessArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckCommitReadinessArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CheckCommitReadinessArgs message.
             * @function verify
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CheckCommitReadinessArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    if (!$util.isString(message.endorsementPlugin))
                        return "endorsementPlugin: string expected";
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    if (!$util.isString(message.validationPlugin))
                        return "validationPlugin: string expected";
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    if (!(message.validationParameter && typeof message.validationParameter.length === "number" || $util.isString(message.validationParameter)))
                        return "validationParameter: buffer expected";
                if (message.collections != null && message.hasOwnProperty("collections")) {
                    var error = $root.common.CollectionConfigPackage.verify(message.collections);
                    if (error)
                        return "collections." + error;
                }
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    if (typeof message.initRequired !== "boolean")
                        return "initRequired: boolean expected";
                return null;
            };
    
            /**
             * Creates a CheckCommitReadinessArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.CheckCommitReadinessArgs} CheckCommitReadinessArgs
             */
            CheckCommitReadinessArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.CheckCommitReadinessArgs)
                    return object;
                var message = new $root.lifecycle.CheckCommitReadinessArgs();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.endorsementPlugin != null)
                    message.endorsementPlugin = String(object.endorsementPlugin);
                if (object.validationPlugin != null)
                    message.validationPlugin = String(object.validationPlugin);
                if (object.validationParameter != null)
                    if (typeof object.validationParameter === "string")
                        $util.base64.decode(object.validationParameter, message.validationParameter = $util.newBuffer($util.base64.length(object.validationParameter)), 0);
                    else if (object.validationParameter.length)
                        message.validationParameter = object.validationParameter;
                if (object.collections != null) {
                    if (typeof object.collections !== "object")
                        throw TypeError(".lifecycle.CheckCommitReadinessArgs.collections: object expected");
                    message.collections = $root.common.CollectionConfigPackage.fromObject(object.collections);
                }
                if (object.initRequired != null)
                    message.initRequired = Boolean(object.initRequired);
                return message;
            };
    
            /**
             * Creates a plain object from a CheckCommitReadinessArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @static
             * @param {lifecycle.CheckCommitReadinessArgs} message CheckCommitReadinessArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CheckCommitReadinessArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                    object.name = "";
                    object.version = "";
                    object.endorsementPlugin = "";
                    object.validationPlugin = "";
                    if (options.bytes === String)
                        object.validationParameter = "";
                    else {
                        object.validationParameter = [];
                        if (options.bytes !== Array)
                            object.validationParameter = $util.newBuffer(object.validationParameter);
                    }
                    object.collections = null;
                    object.initRequired = false;
                }
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    object.endorsementPlugin = message.endorsementPlugin;
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    object.validationPlugin = message.validationPlugin;
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    object.validationParameter = options.bytes === String ? $util.base64.encode(message.validationParameter, 0, message.validationParameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.validationParameter) : message.validationParameter;
                if (message.collections != null && message.hasOwnProperty("collections"))
                    object.collections = $root.common.CollectionConfigPackage.toObject(message.collections, options);
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    object.initRequired = message.initRequired;
                return object;
            };
    
            /**
             * Converts this CheckCommitReadinessArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.CheckCommitReadinessArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CheckCommitReadinessArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CheckCommitReadinessArgs;
        })();
    
        lifecycle.CheckCommitReadinessResult = (function() {
    
            /**
             * Properties of a CheckCommitReadinessResult.
             * @memberof lifecycle
             * @interface ICheckCommitReadinessResult
             * @property {Object.<string,boolean>|null} [approvals] CheckCommitReadinessResult approvals
             */
    
            /**
             * Constructs a new CheckCommitReadinessResult.
             * @memberof lifecycle
             * @classdesc Represents a CheckCommitReadinessResult.
             * @implements ICheckCommitReadinessResult
             * @constructor
             * @param {lifecycle.ICheckCommitReadinessResult=} [properties] Properties to set
             */
            function CheckCommitReadinessResult(properties) {
                this.approvals = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CheckCommitReadinessResult approvals.
             * @member {Object.<string,boolean>} approvals
             * @memberof lifecycle.CheckCommitReadinessResult
             * @instance
             */
            CheckCommitReadinessResult.prototype.approvals = $util.emptyObject;
    
            /**
             * Creates a new CheckCommitReadinessResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {lifecycle.ICheckCommitReadinessResult=} [properties] Properties to set
             * @returns {lifecycle.CheckCommitReadinessResult} CheckCommitReadinessResult instance
             */
            CheckCommitReadinessResult.create = function create(properties) {
                return new CheckCommitReadinessResult(properties);
            };
    
            /**
             * Encodes the specified CheckCommitReadinessResult message. Does not implicitly {@link lifecycle.CheckCommitReadinessResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {lifecycle.ICheckCommitReadinessResult} message CheckCommitReadinessResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckCommitReadinessResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.approvals != null && message.hasOwnProperty("approvals"))
                    for (var keys = Object.keys(message.approvals), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).bool(message.approvals[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CheckCommitReadinessResult message, length delimited. Does not implicitly {@link lifecycle.CheckCommitReadinessResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {lifecycle.ICheckCommitReadinessResult} message CheckCommitReadinessResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckCommitReadinessResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CheckCommitReadinessResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.CheckCommitReadinessResult} CheckCommitReadinessResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckCommitReadinessResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.CheckCommitReadinessResult(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.approvals === $util.emptyObject)
                            message.approvals = {};
                        key = reader.string();
                        reader.pos++;
                        message.approvals[key] = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CheckCommitReadinessResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.CheckCommitReadinessResult} CheckCommitReadinessResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckCommitReadinessResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CheckCommitReadinessResult message.
             * @function verify
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CheckCommitReadinessResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.approvals != null && message.hasOwnProperty("approvals")) {
                    if (!$util.isObject(message.approvals))
                        return "approvals: object expected";
                    var key = Object.keys(message.approvals);
                    for (var i = 0; i < key.length; ++i)
                        if (typeof message.approvals[key[i]] !== "boolean")
                            return "approvals: boolean{k:string} expected";
                }
                return null;
            };
    
            /**
             * Creates a CheckCommitReadinessResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.CheckCommitReadinessResult} CheckCommitReadinessResult
             */
            CheckCommitReadinessResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.CheckCommitReadinessResult)
                    return object;
                var message = new $root.lifecycle.CheckCommitReadinessResult();
                if (object.approvals) {
                    if (typeof object.approvals !== "object")
                        throw TypeError(".lifecycle.CheckCommitReadinessResult.approvals: object expected");
                    message.approvals = {};
                    for (var keys = Object.keys(object.approvals), i = 0; i < keys.length; ++i)
                        message.approvals[keys[i]] = Boolean(object.approvals[keys[i]]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CheckCommitReadinessResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.CheckCommitReadinessResult
             * @static
             * @param {lifecycle.CheckCommitReadinessResult} message CheckCommitReadinessResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CheckCommitReadinessResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.approvals = {};
                var keys2;
                if (message.approvals && (keys2 = Object.keys(message.approvals)).length) {
                    object.approvals = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.approvals[keys2[j]] = message.approvals[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this CheckCommitReadinessResult to JSON.
             * @function toJSON
             * @memberof lifecycle.CheckCommitReadinessResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CheckCommitReadinessResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CheckCommitReadinessResult;
        })();
    
        lifecycle.QueryChaincodeDefinitionArgs = (function() {
    
            /**
             * Properties of a QueryChaincodeDefinitionArgs.
             * @memberof lifecycle
             * @interface IQueryChaincodeDefinitionArgs
             * @property {string|null} [name] QueryChaincodeDefinitionArgs name
             */
    
            /**
             * Constructs a new QueryChaincodeDefinitionArgs.
             * @memberof lifecycle
             * @classdesc Represents a QueryChaincodeDefinitionArgs.
             * @implements IQueryChaincodeDefinitionArgs
             * @constructor
             * @param {lifecycle.IQueryChaincodeDefinitionArgs=} [properties] Properties to set
             */
            function QueryChaincodeDefinitionArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryChaincodeDefinitionArgs name.
             * @member {string} name
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @instance
             */
            QueryChaincodeDefinitionArgs.prototype.name = "";
    
            /**
             * Creates a new QueryChaincodeDefinitionArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionArgs=} [properties] Properties to set
             * @returns {lifecycle.QueryChaincodeDefinitionArgs} QueryChaincodeDefinitionArgs instance
             */
            QueryChaincodeDefinitionArgs.create = function create(properties) {
                return new QueryChaincodeDefinitionArgs(properties);
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionArgs message. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionArgs} message QueryChaincodeDefinitionArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionArgs message, length delimited. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionArgs} message QueryChaincodeDefinitionArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryChaincodeDefinitionArgs} QueryChaincodeDefinitionArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryChaincodeDefinitionArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryChaincodeDefinitionArgs} QueryChaincodeDefinitionArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryChaincodeDefinitionArgs message.
             * @function verify
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryChaincodeDefinitionArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };
    
            /**
             * Creates a QueryChaincodeDefinitionArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryChaincodeDefinitionArgs} QueryChaincodeDefinitionArgs
             */
            QueryChaincodeDefinitionArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryChaincodeDefinitionArgs)
                    return object;
                var message = new $root.lifecycle.QueryChaincodeDefinitionArgs();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };
    
            /**
             * Creates a plain object from a QueryChaincodeDefinitionArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @static
             * @param {lifecycle.QueryChaincodeDefinitionArgs} message QueryChaincodeDefinitionArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryChaincodeDefinitionArgs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };
    
            /**
             * Converts this QueryChaincodeDefinitionArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryChaincodeDefinitionArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryChaincodeDefinitionArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryChaincodeDefinitionArgs;
        })();
    
        lifecycle.QueryChaincodeDefinitionResult = (function() {
    
            /**
             * Properties of a QueryChaincodeDefinitionResult.
             * @memberof lifecycle
             * @interface IQueryChaincodeDefinitionResult
             * @property {number|Long|null} [sequence] QueryChaincodeDefinitionResult sequence
             * @property {string|null} [version] QueryChaincodeDefinitionResult version
             * @property {string|null} [endorsementPlugin] QueryChaincodeDefinitionResult endorsementPlugin
             * @property {string|null} [validationPlugin] QueryChaincodeDefinitionResult validationPlugin
             * @property {Uint8Array|null} [validationParameter] QueryChaincodeDefinitionResult validationParameter
             * @property {common.ICollectionConfigPackage|null} [collections] QueryChaincodeDefinitionResult collections
             * @property {boolean|null} [initRequired] QueryChaincodeDefinitionResult initRequired
             * @property {Object.<string,boolean>|null} [approvals] QueryChaincodeDefinitionResult approvals
             */
    
            /**
             * Constructs a new QueryChaincodeDefinitionResult.
             * @memberof lifecycle
             * @classdesc Represents a QueryChaincodeDefinitionResult.
             * @implements IQueryChaincodeDefinitionResult
             * @constructor
             * @param {lifecycle.IQueryChaincodeDefinitionResult=} [properties] Properties to set
             */
            function QueryChaincodeDefinitionResult(properties) {
                this.approvals = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryChaincodeDefinitionResult sequence.
             * @member {number|Long} sequence
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * QueryChaincodeDefinitionResult version.
             * @member {string} version
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.version = "";
    
            /**
             * QueryChaincodeDefinitionResult endorsementPlugin.
             * @member {string} endorsementPlugin
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.endorsementPlugin = "";
    
            /**
             * QueryChaincodeDefinitionResult validationPlugin.
             * @member {string} validationPlugin
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.validationPlugin = "";
    
            /**
             * QueryChaincodeDefinitionResult validationParameter.
             * @member {Uint8Array} validationParameter
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.validationParameter = $util.newBuffer([]);
    
            /**
             * QueryChaincodeDefinitionResult collections.
             * @member {common.ICollectionConfigPackage|null|undefined} collections
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.collections = null;
    
            /**
             * QueryChaincodeDefinitionResult initRequired.
             * @member {boolean} initRequired
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.initRequired = false;
    
            /**
             * QueryChaincodeDefinitionResult approvals.
             * @member {Object.<string,boolean>} approvals
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             */
            QueryChaincodeDefinitionResult.prototype.approvals = $util.emptyObject;
    
            /**
             * Creates a new QueryChaincodeDefinitionResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionResult=} [properties] Properties to set
             * @returns {lifecycle.QueryChaincodeDefinitionResult} QueryChaincodeDefinitionResult instance
             */
            QueryChaincodeDefinitionResult.create = function create(properties) {
                return new QueryChaincodeDefinitionResult(properties);
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionResult message. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionResult} message QueryChaincodeDefinitionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.sequence);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.endorsementPlugin);
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.validationPlugin);
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.validationParameter);
                if (message.collections != null && message.hasOwnProperty("collections"))
                    $root.common.CollectionConfigPackage.encode(message.collections, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.initRequired);
                if (message.approvals != null && message.hasOwnProperty("approvals"))
                    for (var keys = Object.keys(message.approvals), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).bool(message.approvals[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionResult message, length delimited. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionResult} message QueryChaincodeDefinitionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryChaincodeDefinitionResult} QueryChaincodeDefinitionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryChaincodeDefinitionResult(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sequence = reader.int64();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    case 3:
                        message.endorsementPlugin = reader.string();
                        break;
                    case 4:
                        message.validationPlugin = reader.string();
                        break;
                    case 5:
                        message.validationParameter = reader.bytes();
                        break;
                    case 6:
                        message.collections = $root.common.CollectionConfigPackage.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.initRequired = reader.bool();
                        break;
                    case 8:
                        reader.skip().pos++;
                        if (message.approvals === $util.emptyObject)
                            message.approvals = {};
                        key = reader.string();
                        reader.pos++;
                        message.approvals[key] = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryChaincodeDefinitionResult} QueryChaincodeDefinitionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryChaincodeDefinitionResult message.
             * @function verify
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryChaincodeDefinitionResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                        return "sequence: integer|Long expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    if (!$util.isString(message.endorsementPlugin))
                        return "endorsementPlugin: string expected";
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    if (!$util.isString(message.validationPlugin))
                        return "validationPlugin: string expected";
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    if (!(message.validationParameter && typeof message.validationParameter.length === "number" || $util.isString(message.validationParameter)))
                        return "validationParameter: buffer expected";
                if (message.collections != null && message.hasOwnProperty("collections")) {
                    var error = $root.common.CollectionConfigPackage.verify(message.collections);
                    if (error)
                        return "collections." + error;
                }
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    if (typeof message.initRequired !== "boolean")
                        return "initRequired: boolean expected";
                if (message.approvals != null && message.hasOwnProperty("approvals")) {
                    if (!$util.isObject(message.approvals))
                        return "approvals: object expected";
                    var key = Object.keys(message.approvals);
                    for (var i = 0; i < key.length; ++i)
                        if (typeof message.approvals[key[i]] !== "boolean")
                            return "approvals: boolean{k:string} expected";
                }
                return null;
            };
    
            /**
             * Creates a QueryChaincodeDefinitionResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryChaincodeDefinitionResult} QueryChaincodeDefinitionResult
             */
            QueryChaincodeDefinitionResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryChaincodeDefinitionResult)
                    return object;
                var message = new $root.lifecycle.QueryChaincodeDefinitionResult();
                if (object.sequence != null)
                    if ($util.Long)
                        (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                    else if (typeof object.sequence === "string")
                        message.sequence = parseInt(object.sequence, 10);
                    else if (typeof object.sequence === "number")
                        message.sequence = object.sequence;
                    else if (typeof object.sequence === "object")
                        message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                if (object.version != null)
                    message.version = String(object.version);
                if (object.endorsementPlugin != null)
                    message.endorsementPlugin = String(object.endorsementPlugin);
                if (object.validationPlugin != null)
                    message.validationPlugin = String(object.validationPlugin);
                if (object.validationParameter != null)
                    if (typeof object.validationParameter === "string")
                        $util.base64.decode(object.validationParameter, message.validationParameter = $util.newBuffer($util.base64.length(object.validationParameter)), 0);
                    else if (object.validationParameter.length)
                        message.validationParameter = object.validationParameter;
                if (object.collections != null) {
                    if (typeof object.collections !== "object")
                        throw TypeError(".lifecycle.QueryChaincodeDefinitionResult.collections: object expected");
                    message.collections = $root.common.CollectionConfigPackage.fromObject(object.collections);
                }
                if (object.initRequired != null)
                    message.initRequired = Boolean(object.initRequired);
                if (object.approvals) {
                    if (typeof object.approvals !== "object")
                        throw TypeError(".lifecycle.QueryChaincodeDefinitionResult.approvals: object expected");
                    message.approvals = {};
                    for (var keys = Object.keys(object.approvals), i = 0; i < keys.length; ++i)
                        message.approvals[keys[i]] = Boolean(object.approvals[keys[i]]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryChaincodeDefinitionResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @static
             * @param {lifecycle.QueryChaincodeDefinitionResult} message QueryChaincodeDefinitionResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryChaincodeDefinitionResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.approvals = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.sequence = options.longs === String ? "0" : 0;
                    object.version = "";
                    object.endorsementPlugin = "";
                    object.validationPlugin = "";
                    if (options.bytes === String)
                        object.validationParameter = "";
                    else {
                        object.validationParameter = [];
                        if (options.bytes !== Array)
                            object.validationParameter = $util.newBuffer(object.validationParameter);
                    }
                    object.collections = null;
                    object.initRequired = false;
                }
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (typeof message.sequence === "number")
                        object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                    else
                        object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    object.endorsementPlugin = message.endorsementPlugin;
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    object.validationPlugin = message.validationPlugin;
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    object.validationParameter = options.bytes === String ? $util.base64.encode(message.validationParameter, 0, message.validationParameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.validationParameter) : message.validationParameter;
                if (message.collections != null && message.hasOwnProperty("collections"))
                    object.collections = $root.common.CollectionConfigPackage.toObject(message.collections, options);
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    object.initRequired = message.initRequired;
                var keys2;
                if (message.approvals && (keys2 = Object.keys(message.approvals)).length) {
                    object.approvals = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.approvals[keys2[j]] = message.approvals[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this QueryChaincodeDefinitionResult to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryChaincodeDefinitionResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryChaincodeDefinitionResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryChaincodeDefinitionResult;
        })();
    
        lifecycle.QueryChaincodeDefinitionsArgs = (function() {
    
            /**
             * Properties of a QueryChaincodeDefinitionsArgs.
             * @memberof lifecycle
             * @interface IQueryChaincodeDefinitionsArgs
             */
    
            /**
             * Constructs a new QueryChaincodeDefinitionsArgs.
             * @memberof lifecycle
             * @classdesc Represents a QueryChaincodeDefinitionsArgs.
             * @implements IQueryChaincodeDefinitionsArgs
             * @constructor
             * @param {lifecycle.IQueryChaincodeDefinitionsArgs=} [properties] Properties to set
             */
            function QueryChaincodeDefinitionsArgs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new QueryChaincodeDefinitionsArgs instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionsArgs=} [properties] Properties to set
             * @returns {lifecycle.QueryChaincodeDefinitionsArgs} QueryChaincodeDefinitionsArgs instance
             */
            QueryChaincodeDefinitionsArgs.create = function create(properties) {
                return new QueryChaincodeDefinitionsArgs(properties);
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionsArgs message. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionsArgs.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionsArgs} message QueryChaincodeDefinitionsArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionsArgs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionsArgs message, length delimited. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionsArgs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionsArgs} message QueryChaincodeDefinitionsArgs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionsArgs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionsArgs message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryChaincodeDefinitionsArgs} QueryChaincodeDefinitionsArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionsArgs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryChaincodeDefinitionsArgs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionsArgs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryChaincodeDefinitionsArgs} QueryChaincodeDefinitionsArgs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionsArgs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryChaincodeDefinitionsArgs message.
             * @function verify
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryChaincodeDefinitionsArgs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a QueryChaincodeDefinitionsArgs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryChaincodeDefinitionsArgs} QueryChaincodeDefinitionsArgs
             */
            QueryChaincodeDefinitionsArgs.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryChaincodeDefinitionsArgs)
                    return object;
                return new $root.lifecycle.QueryChaincodeDefinitionsArgs();
            };
    
            /**
             * Creates a plain object from a QueryChaincodeDefinitionsArgs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @static
             * @param {lifecycle.QueryChaincodeDefinitionsArgs} message QueryChaincodeDefinitionsArgs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryChaincodeDefinitionsArgs.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this QueryChaincodeDefinitionsArgs to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryChaincodeDefinitionsArgs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryChaincodeDefinitionsArgs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryChaincodeDefinitionsArgs;
        })();
    
        lifecycle.QueryChaincodeDefinitionsResult = (function() {
    
            /**
             * Properties of a QueryChaincodeDefinitionsResult.
             * @memberof lifecycle
             * @interface IQueryChaincodeDefinitionsResult
             * @property {Array.<lifecycle.QueryChaincodeDefinitionsResult.IChaincodeDefinition>|null} [chaincodeDefinitions] QueryChaincodeDefinitionsResult chaincodeDefinitions
             */
    
            /**
             * Constructs a new QueryChaincodeDefinitionsResult.
             * @memberof lifecycle
             * @classdesc Represents a QueryChaincodeDefinitionsResult.
             * @implements IQueryChaincodeDefinitionsResult
             * @constructor
             * @param {lifecycle.IQueryChaincodeDefinitionsResult=} [properties] Properties to set
             */
            function QueryChaincodeDefinitionsResult(properties) {
                this.chaincodeDefinitions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryChaincodeDefinitionsResult chaincodeDefinitions.
             * @member {Array.<lifecycle.QueryChaincodeDefinitionsResult.IChaincodeDefinition>} chaincodeDefinitions
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @instance
             */
            QueryChaincodeDefinitionsResult.prototype.chaincodeDefinitions = $util.emptyArray;
    
            /**
             * Creates a new QueryChaincodeDefinitionsResult instance using the specified properties.
             * @function create
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionsResult=} [properties] Properties to set
             * @returns {lifecycle.QueryChaincodeDefinitionsResult} QueryChaincodeDefinitionsResult instance
             */
            QueryChaincodeDefinitionsResult.create = function create(properties) {
                return new QueryChaincodeDefinitionsResult(properties);
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionsResult message. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionsResult.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionsResult} message QueryChaincodeDefinitionsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionsResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chaincodeDefinitions != null && message.chaincodeDefinitions.length)
                    for (var i = 0; i < message.chaincodeDefinitions.length; ++i)
                        $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.encode(message.chaincodeDefinitions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified QueryChaincodeDefinitionsResult message, length delimited. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionsResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {lifecycle.IQueryChaincodeDefinitionsResult} message QueryChaincodeDefinitionsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryChaincodeDefinitionsResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionsResult message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.QueryChaincodeDefinitionsResult} QueryChaincodeDefinitionsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionsResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryChaincodeDefinitionsResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.chaincodeDefinitions && message.chaincodeDefinitions.length))
                            message.chaincodeDefinitions = [];
                        message.chaincodeDefinitions.push($root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryChaincodeDefinitionsResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.QueryChaincodeDefinitionsResult} QueryChaincodeDefinitionsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryChaincodeDefinitionsResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryChaincodeDefinitionsResult message.
             * @function verify
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryChaincodeDefinitionsResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chaincodeDefinitions != null && message.hasOwnProperty("chaincodeDefinitions")) {
                    if (!Array.isArray(message.chaincodeDefinitions))
                        return "chaincodeDefinitions: array expected";
                    for (var i = 0; i < message.chaincodeDefinitions.length; ++i) {
                        var error = $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.verify(message.chaincodeDefinitions[i]);
                        if (error)
                            return "chaincodeDefinitions." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a QueryChaincodeDefinitionsResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.QueryChaincodeDefinitionsResult} QueryChaincodeDefinitionsResult
             */
            QueryChaincodeDefinitionsResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.QueryChaincodeDefinitionsResult)
                    return object;
                var message = new $root.lifecycle.QueryChaincodeDefinitionsResult();
                if (object.chaincodeDefinitions) {
                    if (!Array.isArray(object.chaincodeDefinitions))
                        throw TypeError(".lifecycle.QueryChaincodeDefinitionsResult.chaincodeDefinitions: array expected");
                    message.chaincodeDefinitions = [];
                    for (var i = 0; i < object.chaincodeDefinitions.length; ++i) {
                        if (typeof object.chaincodeDefinitions[i] !== "object")
                            throw TypeError(".lifecycle.QueryChaincodeDefinitionsResult.chaincodeDefinitions: object expected");
                        message.chaincodeDefinitions[i] = $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.fromObject(object.chaincodeDefinitions[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryChaincodeDefinitionsResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @static
             * @param {lifecycle.QueryChaincodeDefinitionsResult} message QueryChaincodeDefinitionsResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryChaincodeDefinitionsResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.chaincodeDefinitions = [];
                if (message.chaincodeDefinitions && message.chaincodeDefinitions.length) {
                    object.chaincodeDefinitions = [];
                    for (var j = 0; j < message.chaincodeDefinitions.length; ++j)
                        object.chaincodeDefinitions[j] = $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.toObject(message.chaincodeDefinitions[j], options);
                }
                return object;
            };
    
            /**
             * Converts this QueryChaincodeDefinitionsResult to JSON.
             * @function toJSON
             * @memberof lifecycle.QueryChaincodeDefinitionsResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryChaincodeDefinitionsResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            QueryChaincodeDefinitionsResult.ChaincodeDefinition = (function() {
    
                /**
                 * Properties of a ChaincodeDefinition.
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult
                 * @interface IChaincodeDefinition
                 * @property {string|null} [name] ChaincodeDefinition name
                 * @property {number|Long|null} [sequence] ChaincodeDefinition sequence
                 * @property {string|null} [version] ChaincodeDefinition version
                 * @property {string|null} [endorsementPlugin] ChaincodeDefinition endorsementPlugin
                 * @property {string|null} [validationPlugin] ChaincodeDefinition validationPlugin
                 * @property {Uint8Array|null} [validationParameter] ChaincodeDefinition validationParameter
                 * @property {common.ICollectionConfigPackage|null} [collections] ChaincodeDefinition collections
                 * @property {boolean|null} [initRequired] ChaincodeDefinition initRequired
                 */
    
                /**
                 * Constructs a new ChaincodeDefinition.
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult
                 * @classdesc Represents a ChaincodeDefinition.
                 * @implements IChaincodeDefinition
                 * @constructor
                 * @param {lifecycle.QueryChaincodeDefinitionsResult.IChaincodeDefinition=} [properties] Properties to set
                 */
                function ChaincodeDefinition(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ChaincodeDefinition name.
                 * @member {string} name
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.name = "";
    
                /**
                 * ChaincodeDefinition sequence.
                 * @member {number|Long} sequence
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * ChaincodeDefinition version.
                 * @member {string} version
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.version = "";
    
                /**
                 * ChaincodeDefinition endorsementPlugin.
                 * @member {string} endorsementPlugin
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.endorsementPlugin = "";
    
                /**
                 * ChaincodeDefinition validationPlugin.
                 * @member {string} validationPlugin
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.validationPlugin = "";
    
                /**
                 * ChaincodeDefinition validationParameter.
                 * @member {Uint8Array} validationParameter
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.validationParameter = $util.newBuffer([]);
    
                /**
                 * ChaincodeDefinition collections.
                 * @member {common.ICollectionConfigPackage|null|undefined} collections
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.collections = null;
    
                /**
                 * ChaincodeDefinition initRequired.
                 * @member {boolean} initRequired
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 */
                ChaincodeDefinition.prototype.initRequired = false;
    
                /**
                 * Creates a new ChaincodeDefinition instance using the specified properties.
                 * @function create
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {lifecycle.QueryChaincodeDefinitionsResult.IChaincodeDefinition=} [properties] Properties to set
                 * @returns {lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition} ChaincodeDefinition instance
                 */
                ChaincodeDefinition.create = function create(properties) {
                    return new ChaincodeDefinition(properties);
                };
    
                /**
                 * Encodes the specified ChaincodeDefinition message. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.verify|verify} messages.
                 * @function encode
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {lifecycle.QueryChaincodeDefinitionsResult.IChaincodeDefinition} message ChaincodeDefinition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChaincodeDefinition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.sequence != null && message.hasOwnProperty("sequence"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sequence);
                    if (message.version != null && message.hasOwnProperty("version"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.version);
                    if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.endorsementPlugin);
                    if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.validationPlugin);
                    if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.validationParameter);
                    if (message.collections != null && message.hasOwnProperty("collections"))
                        $root.common.CollectionConfigPackage.encode(message.collections, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.initRequired);
                    return writer;
                };
    
                /**
                 * Encodes the specified ChaincodeDefinition message, length delimited. Does not implicitly {@link lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {lifecycle.QueryChaincodeDefinitionsResult.IChaincodeDefinition} message ChaincodeDefinition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChaincodeDefinition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ChaincodeDefinition message from the specified reader or buffer.
                 * @function decode
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition} ChaincodeDefinition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChaincodeDefinition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.sequence = reader.int64();
                            break;
                        case 3:
                            message.version = reader.string();
                            break;
                        case 4:
                            message.endorsementPlugin = reader.string();
                            break;
                        case 5:
                            message.validationPlugin = reader.string();
                            break;
                        case 6:
                            message.validationParameter = reader.bytes();
                            break;
                        case 7:
                            message.collections = $root.common.CollectionConfigPackage.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.initRequired = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ChaincodeDefinition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition} ChaincodeDefinition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChaincodeDefinition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ChaincodeDefinition message.
                 * @function verify
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChaincodeDefinition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.sequence != null && message.hasOwnProperty("sequence"))
                        if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                            return "sequence: integer|Long expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isString(message.version))
                            return "version: string expected";
                    if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                        if (!$util.isString(message.endorsementPlugin))
                            return "endorsementPlugin: string expected";
                    if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                        if (!$util.isString(message.validationPlugin))
                            return "validationPlugin: string expected";
                    if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                        if (!(message.validationParameter && typeof message.validationParameter.length === "number" || $util.isString(message.validationParameter)))
                            return "validationParameter: buffer expected";
                    if (message.collections != null && message.hasOwnProperty("collections")) {
                        var error = $root.common.CollectionConfigPackage.verify(message.collections);
                        if (error)
                            return "collections." + error;
                    }
                    if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                        if (typeof message.initRequired !== "boolean")
                            return "initRequired: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a ChaincodeDefinition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition} ChaincodeDefinition
                 */
                ChaincodeDefinition.fromObject = function fromObject(object) {
                    if (object instanceof $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition)
                        return object;
                    var message = new $root.lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.sequence != null)
                        if ($util.Long)
                            (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                        else if (typeof object.sequence === "string")
                            message.sequence = parseInt(object.sequence, 10);
                        else if (typeof object.sequence === "number")
                            message.sequence = object.sequence;
                        else if (typeof object.sequence === "object")
                            message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
                    if (object.version != null)
                        message.version = String(object.version);
                    if (object.endorsementPlugin != null)
                        message.endorsementPlugin = String(object.endorsementPlugin);
                    if (object.validationPlugin != null)
                        message.validationPlugin = String(object.validationPlugin);
                    if (object.validationParameter != null)
                        if (typeof object.validationParameter === "string")
                            $util.base64.decode(object.validationParameter, message.validationParameter = $util.newBuffer($util.base64.length(object.validationParameter)), 0);
                        else if (object.validationParameter.length)
                            message.validationParameter = object.validationParameter;
                    if (object.collections != null) {
                        if (typeof object.collections !== "object")
                            throw TypeError(".lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition.collections: object expected");
                        message.collections = $root.common.CollectionConfigPackage.fromObject(object.collections);
                    }
                    if (object.initRequired != null)
                        message.initRequired = Boolean(object.initRequired);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ChaincodeDefinition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @static
                 * @param {lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition} message ChaincodeDefinition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChaincodeDefinition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.sequence = options.longs === String ? "0" : 0;
                        object.version = "";
                        object.endorsementPlugin = "";
                        object.validationPlugin = "";
                        if (options.bytes === String)
                            object.validationParameter = "";
                        else {
                            object.validationParameter = [];
                            if (options.bytes !== Array)
                                object.validationParameter = $util.newBuffer(object.validationParameter);
                        }
                        object.collections = null;
                        object.initRequired = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.sequence != null && message.hasOwnProperty("sequence"))
                        if (typeof message.sequence === "number")
                            object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                        else
                            object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                        object.endorsementPlugin = message.endorsementPlugin;
                    if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                        object.validationPlugin = message.validationPlugin;
                    if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                        object.validationParameter = options.bytes === String ? $util.base64.encode(message.validationParameter, 0, message.validationParameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.validationParameter) : message.validationParameter;
                    if (message.collections != null && message.hasOwnProperty("collections"))
                        object.collections = $root.common.CollectionConfigPackage.toObject(message.collections, options);
                    if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                        object.initRequired = message.initRequired;
                    return object;
                };
    
                /**
                 * Converts this ChaincodeDefinition to JSON.
                 * @function toJSON
                 * @memberof lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChaincodeDefinition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ChaincodeDefinition;
            })();
    
            return QueryChaincodeDefinitionsResult;
        })();
    
        lifecycle.ChaincodeEndorsementInfo = (function() {
    
            /**
             * Properties of a ChaincodeEndorsementInfo.
             * @memberof lifecycle
             * @interface IChaincodeEndorsementInfo
             * @property {string|null} [version] ChaincodeEndorsementInfo version
             * @property {boolean|null} [initRequired] ChaincodeEndorsementInfo initRequired
             * @property {string|null} [endorsementPlugin] ChaincodeEndorsementInfo endorsementPlugin
             */
    
            /**
             * Constructs a new ChaincodeEndorsementInfo.
             * @memberof lifecycle
             * @classdesc Represents a ChaincodeEndorsementInfo.
             * @implements IChaincodeEndorsementInfo
             * @constructor
             * @param {lifecycle.IChaincodeEndorsementInfo=} [properties] Properties to set
             */
            function ChaincodeEndorsementInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeEndorsementInfo version.
             * @member {string} version
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @instance
             */
            ChaincodeEndorsementInfo.prototype.version = "";
    
            /**
             * ChaincodeEndorsementInfo initRequired.
             * @member {boolean} initRequired
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @instance
             */
            ChaincodeEndorsementInfo.prototype.initRequired = false;
    
            /**
             * ChaincodeEndorsementInfo endorsementPlugin.
             * @member {string} endorsementPlugin
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @instance
             */
            ChaincodeEndorsementInfo.prototype.endorsementPlugin = "";
    
            /**
             * Creates a new ChaincodeEndorsementInfo instance using the specified properties.
             * @function create
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {lifecycle.IChaincodeEndorsementInfo=} [properties] Properties to set
             * @returns {lifecycle.ChaincodeEndorsementInfo} ChaincodeEndorsementInfo instance
             */
            ChaincodeEndorsementInfo.create = function create(properties) {
                return new ChaincodeEndorsementInfo(properties);
            };
    
            /**
             * Encodes the specified ChaincodeEndorsementInfo message. Does not implicitly {@link lifecycle.ChaincodeEndorsementInfo.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {lifecycle.IChaincodeEndorsementInfo} message ChaincodeEndorsementInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEndorsementInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.initRequired);
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.endorsementPlugin);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeEndorsementInfo message, length delimited. Does not implicitly {@link lifecycle.ChaincodeEndorsementInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {lifecycle.IChaincodeEndorsementInfo} message ChaincodeEndorsementInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeEndorsementInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeEndorsementInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.ChaincodeEndorsementInfo} ChaincodeEndorsementInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEndorsementInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ChaincodeEndorsementInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.version = reader.string();
                        break;
                    case 2:
                        message.initRequired = reader.bool();
                        break;
                    case 3:
                        message.endorsementPlugin = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeEndorsementInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.ChaincodeEndorsementInfo} ChaincodeEndorsementInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeEndorsementInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeEndorsementInfo message.
             * @function verify
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeEndorsementInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    if (typeof message.initRequired !== "boolean")
                        return "initRequired: boolean expected";
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    if (!$util.isString(message.endorsementPlugin))
                        return "endorsementPlugin: string expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeEndorsementInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.ChaincodeEndorsementInfo} ChaincodeEndorsementInfo
             */
            ChaincodeEndorsementInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.ChaincodeEndorsementInfo)
                    return object;
                var message = new $root.lifecycle.ChaincodeEndorsementInfo();
                if (object.version != null)
                    message.version = String(object.version);
                if (object.initRequired != null)
                    message.initRequired = Boolean(object.initRequired);
                if (object.endorsementPlugin != null)
                    message.endorsementPlugin = String(object.endorsementPlugin);
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeEndorsementInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @static
             * @param {lifecycle.ChaincodeEndorsementInfo} message ChaincodeEndorsementInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeEndorsementInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.version = "";
                    object.initRequired = false;
                    object.endorsementPlugin = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.initRequired != null && message.hasOwnProperty("initRequired"))
                    object.initRequired = message.initRequired;
                if (message.endorsementPlugin != null && message.hasOwnProperty("endorsementPlugin"))
                    object.endorsementPlugin = message.endorsementPlugin;
                return object;
            };
    
            /**
             * Converts this ChaincodeEndorsementInfo to JSON.
             * @function toJSON
             * @memberof lifecycle.ChaincodeEndorsementInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeEndorsementInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeEndorsementInfo;
        })();
    
        lifecycle.ChaincodeValidationInfo = (function() {
    
            /**
             * Properties of a ChaincodeValidationInfo.
             * @memberof lifecycle
             * @interface IChaincodeValidationInfo
             * @property {string|null} [validationPlugin] ChaincodeValidationInfo validationPlugin
             * @property {Uint8Array|null} [validationParameter] ChaincodeValidationInfo validationParameter
             */
    
            /**
             * Constructs a new ChaincodeValidationInfo.
             * @memberof lifecycle
             * @classdesc Represents a ChaincodeValidationInfo.
             * @implements IChaincodeValidationInfo
             * @constructor
             * @param {lifecycle.IChaincodeValidationInfo=} [properties] Properties to set
             */
            function ChaincodeValidationInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChaincodeValidationInfo validationPlugin.
             * @member {string} validationPlugin
             * @memberof lifecycle.ChaincodeValidationInfo
             * @instance
             */
            ChaincodeValidationInfo.prototype.validationPlugin = "";
    
            /**
             * ChaincodeValidationInfo validationParameter.
             * @member {Uint8Array} validationParameter
             * @memberof lifecycle.ChaincodeValidationInfo
             * @instance
             */
            ChaincodeValidationInfo.prototype.validationParameter = $util.newBuffer([]);
    
            /**
             * Creates a new ChaincodeValidationInfo instance using the specified properties.
             * @function create
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {lifecycle.IChaincodeValidationInfo=} [properties] Properties to set
             * @returns {lifecycle.ChaincodeValidationInfo} ChaincodeValidationInfo instance
             */
            ChaincodeValidationInfo.create = function create(properties) {
                return new ChaincodeValidationInfo(properties);
            };
    
            /**
             * Encodes the specified ChaincodeValidationInfo message. Does not implicitly {@link lifecycle.ChaincodeValidationInfo.verify|verify} messages.
             * @function encode
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {lifecycle.IChaincodeValidationInfo} message ChaincodeValidationInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeValidationInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.validationPlugin);
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.validationParameter);
                return writer;
            };
    
            /**
             * Encodes the specified ChaincodeValidationInfo message, length delimited. Does not implicitly {@link lifecycle.ChaincodeValidationInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {lifecycle.IChaincodeValidationInfo} message ChaincodeValidationInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChaincodeValidationInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChaincodeValidationInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lifecycle.ChaincodeValidationInfo} ChaincodeValidationInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeValidationInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lifecycle.ChaincodeValidationInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.validationPlugin = reader.string();
                        break;
                    case 2:
                        message.validationParameter = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChaincodeValidationInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lifecycle.ChaincodeValidationInfo} ChaincodeValidationInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChaincodeValidationInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChaincodeValidationInfo message.
             * @function verify
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChaincodeValidationInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    if (!$util.isString(message.validationPlugin))
                        return "validationPlugin: string expected";
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    if (!(message.validationParameter && typeof message.validationParameter.length === "number" || $util.isString(message.validationParameter)))
                        return "validationParameter: buffer expected";
                return null;
            };
    
            /**
             * Creates a ChaincodeValidationInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lifecycle.ChaincodeValidationInfo} ChaincodeValidationInfo
             */
            ChaincodeValidationInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lifecycle.ChaincodeValidationInfo)
                    return object;
                var message = new $root.lifecycle.ChaincodeValidationInfo();
                if (object.validationPlugin != null)
                    message.validationPlugin = String(object.validationPlugin);
                if (object.validationParameter != null)
                    if (typeof object.validationParameter === "string")
                        $util.base64.decode(object.validationParameter, message.validationParameter = $util.newBuffer($util.base64.length(object.validationParameter)), 0);
                    else if (object.validationParameter.length)
                        message.validationParameter = object.validationParameter;
                return message;
            };
    
            /**
             * Creates a plain object from a ChaincodeValidationInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lifecycle.ChaincodeValidationInfo
             * @static
             * @param {lifecycle.ChaincodeValidationInfo} message ChaincodeValidationInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChaincodeValidationInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.validationPlugin = "";
                    if (options.bytes === String)
                        object.validationParameter = "";
                    else {
                        object.validationParameter = [];
                        if (options.bytes !== Array)
                            object.validationParameter = $util.newBuffer(object.validationParameter);
                    }
                }
                if (message.validationPlugin != null && message.hasOwnProperty("validationPlugin"))
                    object.validationPlugin = message.validationPlugin;
                if (message.validationParameter != null && message.hasOwnProperty("validationParameter"))
                    object.validationParameter = options.bytes === String ? $util.base64.encode(message.validationParameter, 0, message.validationParameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.validationParameter) : message.validationParameter;
                return object;
            };
    
            /**
             * Converts this ChaincodeValidationInfo to JSON.
             * @function toJSON
             * @memberof lifecycle.ChaincodeValidationInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChaincodeValidationInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChaincodeValidationInfo;
        })();
    
        return lifecycle;
    })();
    
    $root.kvrwset = (function() {
    
        /**
         * Namespace kvrwset.
         * @exports kvrwset
         * @namespace
         */
        var kvrwset = {};
    
        kvrwset.KVRWSet = (function() {
    
            /**
             * Properties of a KVRWSet.
             * @memberof kvrwset
             * @interface IKVRWSet
             * @property {Array.<kvrwset.IKVRead>|null} [reads] KVRWSet reads
             * @property {Array.<kvrwset.IRangeQueryInfo>|null} [rangeQueriesInfo] KVRWSet rangeQueriesInfo
             * @property {Array.<kvrwset.IKVWrite>|null} [writes] KVRWSet writes
             * @property {Array.<kvrwset.IKVMetadataWrite>|null} [metadataWrites] KVRWSet metadataWrites
             */
    
            /**
             * Constructs a new KVRWSet.
             * @memberof kvrwset
             * @classdesc Represents a KVRWSet.
             * @implements IKVRWSet
             * @constructor
             * @param {kvrwset.IKVRWSet=} [properties] Properties to set
             */
            function KVRWSet(properties) {
                this.reads = [];
                this.rangeQueriesInfo = [];
                this.writes = [];
                this.metadataWrites = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVRWSet reads.
             * @member {Array.<kvrwset.IKVRead>} reads
             * @memberof kvrwset.KVRWSet
             * @instance
             */
            KVRWSet.prototype.reads = $util.emptyArray;
    
            /**
             * KVRWSet rangeQueriesInfo.
             * @member {Array.<kvrwset.IRangeQueryInfo>} rangeQueriesInfo
             * @memberof kvrwset.KVRWSet
             * @instance
             */
            KVRWSet.prototype.rangeQueriesInfo = $util.emptyArray;
    
            /**
             * KVRWSet writes.
             * @member {Array.<kvrwset.IKVWrite>} writes
             * @memberof kvrwset.KVRWSet
             * @instance
             */
            KVRWSet.prototype.writes = $util.emptyArray;
    
            /**
             * KVRWSet metadataWrites.
             * @member {Array.<kvrwset.IKVMetadataWrite>} metadataWrites
             * @memberof kvrwset.KVRWSet
             * @instance
             */
            KVRWSet.prototype.metadataWrites = $util.emptyArray;
    
            /**
             * Creates a new KVRWSet instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {kvrwset.IKVRWSet=} [properties] Properties to set
             * @returns {kvrwset.KVRWSet} KVRWSet instance
             */
            KVRWSet.create = function create(properties) {
                return new KVRWSet(properties);
            };
    
            /**
             * Encodes the specified KVRWSet message. Does not implicitly {@link kvrwset.KVRWSet.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {kvrwset.IKVRWSet} message KVRWSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVRWSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.reads != null && message.reads.length)
                    for (var i = 0; i < message.reads.length; ++i)
                        $root.kvrwset.KVRead.encode(message.reads[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.rangeQueriesInfo != null && message.rangeQueriesInfo.length)
                    for (var i = 0; i < message.rangeQueriesInfo.length; ++i)
                        $root.kvrwset.RangeQueryInfo.encode(message.rangeQueriesInfo[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.writes != null && message.writes.length)
                    for (var i = 0; i < message.writes.length; ++i)
                        $root.kvrwset.KVWrite.encode(message.writes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.metadataWrites != null && message.metadataWrites.length)
                    for (var i = 0; i < message.metadataWrites.length; ++i)
                        $root.kvrwset.KVMetadataWrite.encode(message.metadataWrites[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVRWSet message, length delimited. Does not implicitly {@link kvrwset.KVRWSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {kvrwset.IKVRWSet} message KVRWSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVRWSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVRWSet message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVRWSet} KVRWSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVRWSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVRWSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.reads && message.reads.length))
                            message.reads = [];
                        message.reads.push($root.kvrwset.KVRead.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.rangeQueriesInfo && message.rangeQueriesInfo.length))
                            message.rangeQueriesInfo = [];
                        message.rangeQueriesInfo.push($root.kvrwset.RangeQueryInfo.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.writes && message.writes.length))
                            message.writes = [];
                        message.writes.push($root.kvrwset.KVWrite.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.metadataWrites && message.metadataWrites.length))
                            message.metadataWrites = [];
                        message.metadataWrites.push($root.kvrwset.KVMetadataWrite.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVRWSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVRWSet} KVRWSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVRWSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVRWSet message.
             * @function verify
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVRWSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.reads != null && message.hasOwnProperty("reads")) {
                    if (!Array.isArray(message.reads))
                        return "reads: array expected";
                    for (var i = 0; i < message.reads.length; ++i) {
                        var error = $root.kvrwset.KVRead.verify(message.reads[i]);
                        if (error)
                            return "reads." + error;
                    }
                }
                if (message.rangeQueriesInfo != null && message.hasOwnProperty("rangeQueriesInfo")) {
                    if (!Array.isArray(message.rangeQueriesInfo))
                        return "rangeQueriesInfo: array expected";
                    for (var i = 0; i < message.rangeQueriesInfo.length; ++i) {
                        var error = $root.kvrwset.RangeQueryInfo.verify(message.rangeQueriesInfo[i]);
                        if (error)
                            return "rangeQueriesInfo." + error;
                    }
                }
                if (message.writes != null && message.hasOwnProperty("writes")) {
                    if (!Array.isArray(message.writes))
                        return "writes: array expected";
                    for (var i = 0; i < message.writes.length; ++i) {
                        var error = $root.kvrwset.KVWrite.verify(message.writes[i]);
                        if (error)
                            return "writes." + error;
                    }
                }
                if (message.metadataWrites != null && message.hasOwnProperty("metadataWrites")) {
                    if (!Array.isArray(message.metadataWrites))
                        return "metadataWrites: array expected";
                    for (var i = 0; i < message.metadataWrites.length; ++i) {
                        var error = $root.kvrwset.KVMetadataWrite.verify(message.metadataWrites[i]);
                        if (error)
                            return "metadataWrites." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a KVRWSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVRWSet} KVRWSet
             */
            KVRWSet.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVRWSet)
                    return object;
                var message = new $root.kvrwset.KVRWSet();
                if (object.reads) {
                    if (!Array.isArray(object.reads))
                        throw TypeError(".kvrwset.KVRWSet.reads: array expected");
                    message.reads = [];
                    for (var i = 0; i < object.reads.length; ++i) {
                        if (typeof object.reads[i] !== "object")
                            throw TypeError(".kvrwset.KVRWSet.reads: object expected");
                        message.reads[i] = $root.kvrwset.KVRead.fromObject(object.reads[i]);
                    }
                }
                if (object.rangeQueriesInfo) {
                    if (!Array.isArray(object.rangeQueriesInfo))
                        throw TypeError(".kvrwset.KVRWSet.rangeQueriesInfo: array expected");
                    message.rangeQueriesInfo = [];
                    for (var i = 0; i < object.rangeQueriesInfo.length; ++i) {
                        if (typeof object.rangeQueriesInfo[i] !== "object")
                            throw TypeError(".kvrwset.KVRWSet.rangeQueriesInfo: object expected");
                        message.rangeQueriesInfo[i] = $root.kvrwset.RangeQueryInfo.fromObject(object.rangeQueriesInfo[i]);
                    }
                }
                if (object.writes) {
                    if (!Array.isArray(object.writes))
                        throw TypeError(".kvrwset.KVRWSet.writes: array expected");
                    message.writes = [];
                    for (var i = 0; i < object.writes.length; ++i) {
                        if (typeof object.writes[i] !== "object")
                            throw TypeError(".kvrwset.KVRWSet.writes: object expected");
                        message.writes[i] = $root.kvrwset.KVWrite.fromObject(object.writes[i]);
                    }
                }
                if (object.metadataWrites) {
                    if (!Array.isArray(object.metadataWrites))
                        throw TypeError(".kvrwset.KVRWSet.metadataWrites: array expected");
                    message.metadataWrites = [];
                    for (var i = 0; i < object.metadataWrites.length; ++i) {
                        if (typeof object.metadataWrites[i] !== "object")
                            throw TypeError(".kvrwset.KVRWSet.metadataWrites: object expected");
                        message.metadataWrites[i] = $root.kvrwset.KVMetadataWrite.fromObject(object.metadataWrites[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVRWSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVRWSet
             * @static
             * @param {kvrwset.KVRWSet} message KVRWSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVRWSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.reads = [];
                    object.rangeQueriesInfo = [];
                    object.writes = [];
                    object.metadataWrites = [];
                }
                if (message.reads && message.reads.length) {
                    object.reads = [];
                    for (var j = 0; j < message.reads.length; ++j)
                        object.reads[j] = $root.kvrwset.KVRead.toObject(message.reads[j], options);
                }
                if (message.rangeQueriesInfo && message.rangeQueriesInfo.length) {
                    object.rangeQueriesInfo = [];
                    for (var j = 0; j < message.rangeQueriesInfo.length; ++j)
                        object.rangeQueriesInfo[j] = $root.kvrwset.RangeQueryInfo.toObject(message.rangeQueriesInfo[j], options);
                }
                if (message.writes && message.writes.length) {
                    object.writes = [];
                    for (var j = 0; j < message.writes.length; ++j)
                        object.writes[j] = $root.kvrwset.KVWrite.toObject(message.writes[j], options);
                }
                if (message.metadataWrites && message.metadataWrites.length) {
                    object.metadataWrites = [];
                    for (var j = 0; j < message.metadataWrites.length; ++j)
                        object.metadataWrites[j] = $root.kvrwset.KVMetadataWrite.toObject(message.metadataWrites[j], options);
                }
                return object;
            };
    
            /**
             * Converts this KVRWSet to JSON.
             * @function toJSON
             * @memberof kvrwset.KVRWSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVRWSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVRWSet;
        })();
    
        kvrwset.HashedRWSet = (function() {
    
            /**
             * Properties of a HashedRWSet.
             * @memberof kvrwset
             * @interface IHashedRWSet
             * @property {Array.<kvrwset.IKVReadHash>|null} [hashedReads] HashedRWSet hashedReads
             * @property {Array.<kvrwset.IKVWriteHash>|null} [hashedWrites] HashedRWSet hashedWrites
             * @property {Array.<kvrwset.IKVMetadataWriteHash>|null} [metadataWrites] HashedRWSet metadataWrites
             */
    
            /**
             * Constructs a new HashedRWSet.
             * @memberof kvrwset
             * @classdesc Represents a HashedRWSet.
             * @implements IHashedRWSet
             * @constructor
             * @param {kvrwset.IHashedRWSet=} [properties] Properties to set
             */
            function HashedRWSet(properties) {
                this.hashedReads = [];
                this.hashedWrites = [];
                this.metadataWrites = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * HashedRWSet hashedReads.
             * @member {Array.<kvrwset.IKVReadHash>} hashedReads
             * @memberof kvrwset.HashedRWSet
             * @instance
             */
            HashedRWSet.prototype.hashedReads = $util.emptyArray;
    
            /**
             * HashedRWSet hashedWrites.
             * @member {Array.<kvrwset.IKVWriteHash>} hashedWrites
             * @memberof kvrwset.HashedRWSet
             * @instance
             */
            HashedRWSet.prototype.hashedWrites = $util.emptyArray;
    
            /**
             * HashedRWSet metadataWrites.
             * @member {Array.<kvrwset.IKVMetadataWriteHash>} metadataWrites
             * @memberof kvrwset.HashedRWSet
             * @instance
             */
            HashedRWSet.prototype.metadataWrites = $util.emptyArray;
    
            /**
             * Creates a new HashedRWSet instance using the specified properties.
             * @function create
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {kvrwset.IHashedRWSet=} [properties] Properties to set
             * @returns {kvrwset.HashedRWSet} HashedRWSet instance
             */
            HashedRWSet.create = function create(properties) {
                return new HashedRWSet(properties);
            };
    
            /**
             * Encodes the specified HashedRWSet message. Does not implicitly {@link kvrwset.HashedRWSet.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {kvrwset.IHashedRWSet} message HashedRWSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HashedRWSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hashedReads != null && message.hashedReads.length)
                    for (var i = 0; i < message.hashedReads.length; ++i)
                        $root.kvrwset.KVReadHash.encode(message.hashedReads[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.hashedWrites != null && message.hashedWrites.length)
                    for (var i = 0; i < message.hashedWrites.length; ++i)
                        $root.kvrwset.KVWriteHash.encode(message.hashedWrites[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.metadataWrites != null && message.metadataWrites.length)
                    for (var i = 0; i < message.metadataWrites.length; ++i)
                        $root.kvrwset.KVMetadataWriteHash.encode(message.metadataWrites[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified HashedRWSet message, length delimited. Does not implicitly {@link kvrwset.HashedRWSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {kvrwset.IHashedRWSet} message HashedRWSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HashedRWSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a HashedRWSet message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.HashedRWSet} HashedRWSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HashedRWSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.HashedRWSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.hashedReads && message.hashedReads.length))
                            message.hashedReads = [];
                        message.hashedReads.push($root.kvrwset.KVReadHash.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.hashedWrites && message.hashedWrites.length))
                            message.hashedWrites = [];
                        message.hashedWrites.push($root.kvrwset.KVWriteHash.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.metadataWrites && message.metadataWrites.length))
                            message.metadataWrites = [];
                        message.metadataWrites.push($root.kvrwset.KVMetadataWriteHash.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a HashedRWSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.HashedRWSet} HashedRWSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HashedRWSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a HashedRWSet message.
             * @function verify
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HashedRWSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hashedReads != null && message.hasOwnProperty("hashedReads")) {
                    if (!Array.isArray(message.hashedReads))
                        return "hashedReads: array expected";
                    for (var i = 0; i < message.hashedReads.length; ++i) {
                        var error = $root.kvrwset.KVReadHash.verify(message.hashedReads[i]);
                        if (error)
                            return "hashedReads." + error;
                    }
                }
                if (message.hashedWrites != null && message.hasOwnProperty("hashedWrites")) {
                    if (!Array.isArray(message.hashedWrites))
                        return "hashedWrites: array expected";
                    for (var i = 0; i < message.hashedWrites.length; ++i) {
                        var error = $root.kvrwset.KVWriteHash.verify(message.hashedWrites[i]);
                        if (error)
                            return "hashedWrites." + error;
                    }
                }
                if (message.metadataWrites != null && message.hasOwnProperty("metadataWrites")) {
                    if (!Array.isArray(message.metadataWrites))
                        return "metadataWrites: array expected";
                    for (var i = 0; i < message.metadataWrites.length; ++i) {
                        var error = $root.kvrwset.KVMetadataWriteHash.verify(message.metadataWrites[i]);
                        if (error)
                            return "metadataWrites." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a HashedRWSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.HashedRWSet} HashedRWSet
             */
            HashedRWSet.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.HashedRWSet)
                    return object;
                var message = new $root.kvrwset.HashedRWSet();
                if (object.hashedReads) {
                    if (!Array.isArray(object.hashedReads))
                        throw TypeError(".kvrwset.HashedRWSet.hashedReads: array expected");
                    message.hashedReads = [];
                    for (var i = 0; i < object.hashedReads.length; ++i) {
                        if (typeof object.hashedReads[i] !== "object")
                            throw TypeError(".kvrwset.HashedRWSet.hashedReads: object expected");
                        message.hashedReads[i] = $root.kvrwset.KVReadHash.fromObject(object.hashedReads[i]);
                    }
                }
                if (object.hashedWrites) {
                    if (!Array.isArray(object.hashedWrites))
                        throw TypeError(".kvrwset.HashedRWSet.hashedWrites: array expected");
                    message.hashedWrites = [];
                    for (var i = 0; i < object.hashedWrites.length; ++i) {
                        if (typeof object.hashedWrites[i] !== "object")
                            throw TypeError(".kvrwset.HashedRWSet.hashedWrites: object expected");
                        message.hashedWrites[i] = $root.kvrwset.KVWriteHash.fromObject(object.hashedWrites[i]);
                    }
                }
                if (object.metadataWrites) {
                    if (!Array.isArray(object.metadataWrites))
                        throw TypeError(".kvrwset.HashedRWSet.metadataWrites: array expected");
                    message.metadataWrites = [];
                    for (var i = 0; i < object.metadataWrites.length; ++i) {
                        if (typeof object.metadataWrites[i] !== "object")
                            throw TypeError(".kvrwset.HashedRWSet.metadataWrites: object expected");
                        message.metadataWrites[i] = $root.kvrwset.KVMetadataWriteHash.fromObject(object.metadataWrites[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a HashedRWSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.HashedRWSet
             * @static
             * @param {kvrwset.HashedRWSet} message HashedRWSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HashedRWSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.hashedReads = [];
                    object.hashedWrites = [];
                    object.metadataWrites = [];
                }
                if (message.hashedReads && message.hashedReads.length) {
                    object.hashedReads = [];
                    for (var j = 0; j < message.hashedReads.length; ++j)
                        object.hashedReads[j] = $root.kvrwset.KVReadHash.toObject(message.hashedReads[j], options);
                }
                if (message.hashedWrites && message.hashedWrites.length) {
                    object.hashedWrites = [];
                    for (var j = 0; j < message.hashedWrites.length; ++j)
                        object.hashedWrites[j] = $root.kvrwset.KVWriteHash.toObject(message.hashedWrites[j], options);
                }
                if (message.metadataWrites && message.metadataWrites.length) {
                    object.metadataWrites = [];
                    for (var j = 0; j < message.metadataWrites.length; ++j)
                        object.metadataWrites[j] = $root.kvrwset.KVMetadataWriteHash.toObject(message.metadataWrites[j], options);
                }
                return object;
            };
    
            /**
             * Converts this HashedRWSet to JSON.
             * @function toJSON
             * @memberof kvrwset.HashedRWSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HashedRWSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return HashedRWSet;
        })();
    
        kvrwset.KVRead = (function() {
    
            /**
             * Properties of a KVRead.
             * @memberof kvrwset
             * @interface IKVRead
             * @property {string|null} [key] KVRead key
             * @property {kvrwset.IVersion|null} [version] KVRead version
             */
    
            /**
             * Constructs a new KVRead.
             * @memberof kvrwset
             * @classdesc Represents a KVRead.
             * @implements IKVRead
             * @constructor
             * @param {kvrwset.IKVRead=} [properties] Properties to set
             */
            function KVRead(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVRead key.
             * @member {string} key
             * @memberof kvrwset.KVRead
             * @instance
             */
            KVRead.prototype.key = "";
    
            /**
             * KVRead version.
             * @member {kvrwset.IVersion|null|undefined} version
             * @memberof kvrwset.KVRead
             * @instance
             */
            KVRead.prototype.version = null;
    
            /**
             * Creates a new KVRead instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVRead
             * @static
             * @param {kvrwset.IKVRead=} [properties] Properties to set
             * @returns {kvrwset.KVRead} KVRead instance
             */
            KVRead.create = function create(properties) {
                return new KVRead(properties);
            };
    
            /**
             * Encodes the specified KVRead message. Does not implicitly {@link kvrwset.KVRead.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVRead
             * @static
             * @param {kvrwset.IKVRead} message KVRead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVRead.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.version != null && message.hasOwnProperty("version"))
                    $root.kvrwset.Version.encode(message.version, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVRead message, length delimited. Does not implicitly {@link kvrwset.KVRead.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVRead
             * @static
             * @param {kvrwset.IKVRead} message KVRead message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVRead.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVRead message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVRead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVRead} KVRead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVRead.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVRead();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.version = $root.kvrwset.Version.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVRead message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVRead
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVRead} KVRead
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVRead.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVRead message.
             * @function verify
             * @memberof kvrwset.KVRead
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVRead.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.version != null && message.hasOwnProperty("version")) {
                    var error = $root.kvrwset.Version.verify(message.version);
                    if (error)
                        return "version." + error;
                }
                return null;
            };
    
            /**
             * Creates a KVRead message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVRead
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVRead} KVRead
             */
            KVRead.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVRead)
                    return object;
                var message = new $root.kvrwset.KVRead();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.version != null) {
                    if (typeof object.version !== "object")
                        throw TypeError(".kvrwset.KVRead.version: object expected");
                    message.version = $root.kvrwset.Version.fromObject(object.version);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVRead message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVRead
             * @static
             * @param {kvrwset.KVRead} message KVRead
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVRead.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.version = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = $root.kvrwset.Version.toObject(message.version, options);
                return object;
            };
    
            /**
             * Converts this KVRead to JSON.
             * @function toJSON
             * @memberof kvrwset.KVRead
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVRead.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVRead;
        })();
    
        kvrwset.KVWrite = (function() {
    
            /**
             * Properties of a KVWrite.
             * @memberof kvrwset
             * @interface IKVWrite
             * @property {string|null} [key] KVWrite key
             * @property {boolean|null} [isDelete] KVWrite isDelete
             * @property {Uint8Array|null} [value] KVWrite value
             */
    
            /**
             * Constructs a new KVWrite.
             * @memberof kvrwset
             * @classdesc Represents a KVWrite.
             * @implements IKVWrite
             * @constructor
             * @param {kvrwset.IKVWrite=} [properties] Properties to set
             */
            function KVWrite(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVWrite key.
             * @member {string} key
             * @memberof kvrwset.KVWrite
             * @instance
             */
            KVWrite.prototype.key = "";
    
            /**
             * KVWrite isDelete.
             * @member {boolean} isDelete
             * @memberof kvrwset.KVWrite
             * @instance
             */
            KVWrite.prototype.isDelete = false;
    
            /**
             * KVWrite value.
             * @member {Uint8Array} value
             * @memberof kvrwset.KVWrite
             * @instance
             */
            KVWrite.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new KVWrite instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVWrite
             * @static
             * @param {kvrwset.IKVWrite=} [properties] Properties to set
             * @returns {kvrwset.KVWrite} KVWrite instance
             */
            KVWrite.create = function create(properties) {
                return new KVWrite(properties);
            };
    
            /**
             * Encodes the specified KVWrite message. Does not implicitly {@link kvrwset.KVWrite.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVWrite
             * @static
             * @param {kvrwset.IKVWrite} message KVWrite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVWrite.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isDelete);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified KVWrite message, length delimited. Does not implicitly {@link kvrwset.KVWrite.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVWrite
             * @static
             * @param {kvrwset.IKVWrite} message KVWrite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVWrite.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVWrite message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVWrite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVWrite} KVWrite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVWrite.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVWrite();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.isDelete = reader.bool();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVWrite message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVWrite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVWrite} KVWrite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVWrite.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVWrite message.
             * @function verify
             * @memberof kvrwset.KVWrite
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVWrite.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                    if (typeof message.isDelete !== "boolean")
                        return "isDelete: boolean expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a KVWrite message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVWrite
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVWrite} KVWrite
             */
            KVWrite.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVWrite)
                    return object;
                var message = new $root.kvrwset.KVWrite();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.isDelete != null)
                    message.isDelete = Boolean(object.isDelete);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a KVWrite message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVWrite
             * @static
             * @param {kvrwset.KVWrite} message KVWrite
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVWrite.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.isDelete = false;
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                    object.isDelete = message.isDelete;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this KVWrite to JSON.
             * @function toJSON
             * @memberof kvrwset.KVWrite
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVWrite.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVWrite;
        })();
    
        kvrwset.KVMetadataWrite = (function() {
    
            /**
             * Properties of a KVMetadataWrite.
             * @memberof kvrwset
             * @interface IKVMetadataWrite
             * @property {string|null} [key] KVMetadataWrite key
             * @property {Array.<kvrwset.IKVMetadataEntry>|null} [entries] KVMetadataWrite entries
             */
    
            /**
             * Constructs a new KVMetadataWrite.
             * @memberof kvrwset
             * @classdesc Represents a KVMetadataWrite.
             * @implements IKVMetadataWrite
             * @constructor
             * @param {kvrwset.IKVMetadataWrite=} [properties] Properties to set
             */
            function KVMetadataWrite(properties) {
                this.entries = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVMetadataWrite key.
             * @member {string} key
             * @memberof kvrwset.KVMetadataWrite
             * @instance
             */
            KVMetadataWrite.prototype.key = "";
    
            /**
             * KVMetadataWrite entries.
             * @member {Array.<kvrwset.IKVMetadataEntry>} entries
             * @memberof kvrwset.KVMetadataWrite
             * @instance
             */
            KVMetadataWrite.prototype.entries = $util.emptyArray;
    
            /**
             * Creates a new KVMetadataWrite instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {kvrwset.IKVMetadataWrite=} [properties] Properties to set
             * @returns {kvrwset.KVMetadataWrite} KVMetadataWrite instance
             */
            KVMetadataWrite.create = function create(properties) {
                return new KVMetadataWrite(properties);
            };
    
            /**
             * Encodes the specified KVMetadataWrite message. Does not implicitly {@link kvrwset.KVMetadataWrite.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {kvrwset.IKVMetadataWrite} message KVMetadataWrite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataWrite.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.entries != null && message.entries.length)
                    for (var i = 0; i < message.entries.length; ++i)
                        $root.kvrwset.KVMetadataEntry.encode(message.entries[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVMetadataWrite message, length delimited. Does not implicitly {@link kvrwset.KVMetadataWrite.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {kvrwset.IKVMetadataWrite} message KVMetadataWrite message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataWrite.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVMetadataWrite message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVMetadataWrite} KVMetadataWrite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataWrite.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVMetadataWrite();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        if (!(message.entries && message.entries.length))
                            message.entries = [];
                        message.entries.push($root.kvrwset.KVMetadataEntry.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVMetadataWrite message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVMetadataWrite} KVMetadataWrite
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataWrite.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVMetadataWrite message.
             * @function verify
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVMetadataWrite.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.entries != null && message.hasOwnProperty("entries")) {
                    if (!Array.isArray(message.entries))
                        return "entries: array expected";
                    for (var i = 0; i < message.entries.length; ++i) {
                        var error = $root.kvrwset.KVMetadataEntry.verify(message.entries[i]);
                        if (error)
                            return "entries." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a KVMetadataWrite message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVMetadataWrite} KVMetadataWrite
             */
            KVMetadataWrite.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVMetadataWrite)
                    return object;
                var message = new $root.kvrwset.KVMetadataWrite();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.entries) {
                    if (!Array.isArray(object.entries))
                        throw TypeError(".kvrwset.KVMetadataWrite.entries: array expected");
                    message.entries = [];
                    for (var i = 0; i < object.entries.length; ++i) {
                        if (typeof object.entries[i] !== "object")
                            throw TypeError(".kvrwset.KVMetadataWrite.entries: object expected");
                        message.entries[i] = $root.kvrwset.KVMetadataEntry.fromObject(object.entries[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVMetadataWrite message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVMetadataWrite
             * @static
             * @param {kvrwset.KVMetadataWrite} message KVMetadataWrite
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVMetadataWrite.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.entries = [];
                if (options.defaults)
                    object.key = "";
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.entries && message.entries.length) {
                    object.entries = [];
                    for (var j = 0; j < message.entries.length; ++j)
                        object.entries[j] = $root.kvrwset.KVMetadataEntry.toObject(message.entries[j], options);
                }
                return object;
            };
    
            /**
             * Converts this KVMetadataWrite to JSON.
             * @function toJSON
             * @memberof kvrwset.KVMetadataWrite
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVMetadataWrite.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVMetadataWrite;
        })();
    
        kvrwset.KVReadHash = (function() {
    
            /**
             * Properties of a KVReadHash.
             * @memberof kvrwset
             * @interface IKVReadHash
             * @property {Uint8Array|null} [keyHash] KVReadHash keyHash
             * @property {kvrwset.IVersion|null} [version] KVReadHash version
             */
    
            /**
             * Constructs a new KVReadHash.
             * @memberof kvrwset
             * @classdesc Represents a KVReadHash.
             * @implements IKVReadHash
             * @constructor
             * @param {kvrwset.IKVReadHash=} [properties] Properties to set
             */
            function KVReadHash(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVReadHash keyHash.
             * @member {Uint8Array} keyHash
             * @memberof kvrwset.KVReadHash
             * @instance
             */
            KVReadHash.prototype.keyHash = $util.newBuffer([]);
    
            /**
             * KVReadHash version.
             * @member {kvrwset.IVersion|null|undefined} version
             * @memberof kvrwset.KVReadHash
             * @instance
             */
            KVReadHash.prototype.version = null;
    
            /**
             * Creates a new KVReadHash instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {kvrwset.IKVReadHash=} [properties] Properties to set
             * @returns {kvrwset.KVReadHash} KVReadHash instance
             */
            KVReadHash.create = function create(properties) {
                return new KVReadHash(properties);
            };
    
            /**
             * Encodes the specified KVReadHash message. Does not implicitly {@link kvrwset.KVReadHash.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {kvrwset.IKVReadHash} message KVReadHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVReadHash.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keyHash != null && message.hasOwnProperty("keyHash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keyHash);
                if (message.version != null && message.hasOwnProperty("version"))
                    $root.kvrwset.Version.encode(message.version, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVReadHash message, length delimited. Does not implicitly {@link kvrwset.KVReadHash.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {kvrwset.IKVReadHash} message KVReadHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVReadHash.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVReadHash message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVReadHash} KVReadHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVReadHash.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVReadHash();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.keyHash = reader.bytes();
                        break;
                    case 2:
                        message.version = $root.kvrwset.Version.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVReadHash message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVReadHash} KVReadHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVReadHash.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVReadHash message.
             * @function verify
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVReadHash.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keyHash != null && message.hasOwnProperty("keyHash"))
                    if (!(message.keyHash && typeof message.keyHash.length === "number" || $util.isString(message.keyHash)))
                        return "keyHash: buffer expected";
                if (message.version != null && message.hasOwnProperty("version")) {
                    var error = $root.kvrwset.Version.verify(message.version);
                    if (error)
                        return "version." + error;
                }
                return null;
            };
    
            /**
             * Creates a KVReadHash message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVReadHash} KVReadHash
             */
            KVReadHash.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVReadHash)
                    return object;
                var message = new $root.kvrwset.KVReadHash();
                if (object.keyHash != null)
                    if (typeof object.keyHash === "string")
                        $util.base64.decode(object.keyHash, message.keyHash = $util.newBuffer($util.base64.length(object.keyHash)), 0);
                    else if (object.keyHash.length)
                        message.keyHash = object.keyHash;
                if (object.version != null) {
                    if (typeof object.version !== "object")
                        throw TypeError(".kvrwset.KVReadHash.version: object expected");
                    message.version = $root.kvrwset.Version.fromObject(object.version);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVReadHash message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVReadHash
             * @static
             * @param {kvrwset.KVReadHash} message KVReadHash
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVReadHash.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.keyHash = "";
                    else {
                        object.keyHash = [];
                        if (options.bytes !== Array)
                            object.keyHash = $util.newBuffer(object.keyHash);
                    }
                    object.version = null;
                }
                if (message.keyHash != null && message.hasOwnProperty("keyHash"))
                    object.keyHash = options.bytes === String ? $util.base64.encode(message.keyHash, 0, message.keyHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.keyHash) : message.keyHash;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = $root.kvrwset.Version.toObject(message.version, options);
                return object;
            };
    
            /**
             * Converts this KVReadHash to JSON.
             * @function toJSON
             * @memberof kvrwset.KVReadHash
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVReadHash.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVReadHash;
        })();
    
        kvrwset.KVWriteHash = (function() {
    
            /**
             * Properties of a KVWriteHash.
             * @memberof kvrwset
             * @interface IKVWriteHash
             * @property {Uint8Array|null} [keyHash] KVWriteHash keyHash
             * @property {boolean|null} [isDelete] KVWriteHash isDelete
             * @property {Uint8Array|null} [valueHash] KVWriteHash valueHash
             */
    
            /**
             * Constructs a new KVWriteHash.
             * @memberof kvrwset
             * @classdesc Represents a KVWriteHash.
             * @implements IKVWriteHash
             * @constructor
             * @param {kvrwset.IKVWriteHash=} [properties] Properties to set
             */
            function KVWriteHash(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVWriteHash keyHash.
             * @member {Uint8Array} keyHash
             * @memberof kvrwset.KVWriteHash
             * @instance
             */
            KVWriteHash.prototype.keyHash = $util.newBuffer([]);
    
            /**
             * KVWriteHash isDelete.
             * @member {boolean} isDelete
             * @memberof kvrwset.KVWriteHash
             * @instance
             */
            KVWriteHash.prototype.isDelete = false;
    
            /**
             * KVWriteHash valueHash.
             * @member {Uint8Array} valueHash
             * @memberof kvrwset.KVWriteHash
             * @instance
             */
            KVWriteHash.prototype.valueHash = $util.newBuffer([]);
    
            /**
             * Creates a new KVWriteHash instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {kvrwset.IKVWriteHash=} [properties] Properties to set
             * @returns {kvrwset.KVWriteHash} KVWriteHash instance
             */
            KVWriteHash.create = function create(properties) {
                return new KVWriteHash(properties);
            };
    
            /**
             * Encodes the specified KVWriteHash message. Does not implicitly {@link kvrwset.KVWriteHash.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {kvrwset.IKVWriteHash} message KVWriteHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVWriteHash.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keyHash != null && message.hasOwnProperty("keyHash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keyHash);
                if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isDelete);
                if (message.valueHash != null && message.hasOwnProperty("valueHash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.valueHash);
                return writer;
            };
    
            /**
             * Encodes the specified KVWriteHash message, length delimited. Does not implicitly {@link kvrwset.KVWriteHash.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {kvrwset.IKVWriteHash} message KVWriteHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVWriteHash.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVWriteHash message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVWriteHash} KVWriteHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVWriteHash.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVWriteHash();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.keyHash = reader.bytes();
                        break;
                    case 2:
                        message.isDelete = reader.bool();
                        break;
                    case 3:
                        message.valueHash = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVWriteHash message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVWriteHash} KVWriteHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVWriteHash.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVWriteHash message.
             * @function verify
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVWriteHash.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keyHash != null && message.hasOwnProperty("keyHash"))
                    if (!(message.keyHash && typeof message.keyHash.length === "number" || $util.isString(message.keyHash)))
                        return "keyHash: buffer expected";
                if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                    if (typeof message.isDelete !== "boolean")
                        return "isDelete: boolean expected";
                if (message.valueHash != null && message.hasOwnProperty("valueHash"))
                    if (!(message.valueHash && typeof message.valueHash.length === "number" || $util.isString(message.valueHash)))
                        return "valueHash: buffer expected";
                return null;
            };
    
            /**
             * Creates a KVWriteHash message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVWriteHash} KVWriteHash
             */
            KVWriteHash.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVWriteHash)
                    return object;
                var message = new $root.kvrwset.KVWriteHash();
                if (object.keyHash != null)
                    if (typeof object.keyHash === "string")
                        $util.base64.decode(object.keyHash, message.keyHash = $util.newBuffer($util.base64.length(object.keyHash)), 0);
                    else if (object.keyHash.length)
                        message.keyHash = object.keyHash;
                if (object.isDelete != null)
                    message.isDelete = Boolean(object.isDelete);
                if (object.valueHash != null)
                    if (typeof object.valueHash === "string")
                        $util.base64.decode(object.valueHash, message.valueHash = $util.newBuffer($util.base64.length(object.valueHash)), 0);
                    else if (object.valueHash.length)
                        message.valueHash = object.valueHash;
                return message;
            };
    
            /**
             * Creates a plain object from a KVWriteHash message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVWriteHash
             * @static
             * @param {kvrwset.KVWriteHash} message KVWriteHash
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVWriteHash.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.keyHash = "";
                    else {
                        object.keyHash = [];
                        if (options.bytes !== Array)
                            object.keyHash = $util.newBuffer(object.keyHash);
                    }
                    object.isDelete = false;
                    if (options.bytes === String)
                        object.valueHash = "";
                    else {
                        object.valueHash = [];
                        if (options.bytes !== Array)
                            object.valueHash = $util.newBuffer(object.valueHash);
                    }
                }
                if (message.keyHash != null && message.hasOwnProperty("keyHash"))
                    object.keyHash = options.bytes === String ? $util.base64.encode(message.keyHash, 0, message.keyHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.keyHash) : message.keyHash;
                if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                    object.isDelete = message.isDelete;
                if (message.valueHash != null && message.hasOwnProperty("valueHash"))
                    object.valueHash = options.bytes === String ? $util.base64.encode(message.valueHash, 0, message.valueHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.valueHash) : message.valueHash;
                return object;
            };
    
            /**
             * Converts this KVWriteHash to JSON.
             * @function toJSON
             * @memberof kvrwset.KVWriteHash
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVWriteHash.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVWriteHash;
        })();
    
        kvrwset.KVMetadataWriteHash = (function() {
    
            /**
             * Properties of a KVMetadataWriteHash.
             * @memberof kvrwset
             * @interface IKVMetadataWriteHash
             * @property {Uint8Array|null} [keyHash] KVMetadataWriteHash keyHash
             * @property {Array.<kvrwset.IKVMetadataEntry>|null} [entries] KVMetadataWriteHash entries
             */
    
            /**
             * Constructs a new KVMetadataWriteHash.
             * @memberof kvrwset
             * @classdesc Represents a KVMetadataWriteHash.
             * @implements IKVMetadataWriteHash
             * @constructor
             * @param {kvrwset.IKVMetadataWriteHash=} [properties] Properties to set
             */
            function KVMetadataWriteHash(properties) {
                this.entries = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVMetadataWriteHash keyHash.
             * @member {Uint8Array} keyHash
             * @memberof kvrwset.KVMetadataWriteHash
             * @instance
             */
            KVMetadataWriteHash.prototype.keyHash = $util.newBuffer([]);
    
            /**
             * KVMetadataWriteHash entries.
             * @member {Array.<kvrwset.IKVMetadataEntry>} entries
             * @memberof kvrwset.KVMetadataWriteHash
             * @instance
             */
            KVMetadataWriteHash.prototype.entries = $util.emptyArray;
    
            /**
             * Creates a new KVMetadataWriteHash instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {kvrwset.IKVMetadataWriteHash=} [properties] Properties to set
             * @returns {kvrwset.KVMetadataWriteHash} KVMetadataWriteHash instance
             */
            KVMetadataWriteHash.create = function create(properties) {
                return new KVMetadataWriteHash(properties);
            };
    
            /**
             * Encodes the specified KVMetadataWriteHash message. Does not implicitly {@link kvrwset.KVMetadataWriteHash.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {kvrwset.IKVMetadataWriteHash} message KVMetadataWriteHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataWriteHash.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keyHash != null && message.hasOwnProperty("keyHash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.keyHash);
                if (message.entries != null && message.entries.length)
                    for (var i = 0; i < message.entries.length; ++i)
                        $root.kvrwset.KVMetadataEntry.encode(message.entries[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KVMetadataWriteHash message, length delimited. Does not implicitly {@link kvrwset.KVMetadataWriteHash.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {kvrwset.IKVMetadataWriteHash} message KVMetadataWriteHash message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataWriteHash.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVMetadataWriteHash message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVMetadataWriteHash} KVMetadataWriteHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataWriteHash.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVMetadataWriteHash();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.keyHash = reader.bytes();
                        break;
                    case 2:
                        if (!(message.entries && message.entries.length))
                            message.entries = [];
                        message.entries.push($root.kvrwset.KVMetadataEntry.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVMetadataWriteHash message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVMetadataWriteHash} KVMetadataWriteHash
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataWriteHash.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVMetadataWriteHash message.
             * @function verify
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVMetadataWriteHash.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keyHash != null && message.hasOwnProperty("keyHash"))
                    if (!(message.keyHash && typeof message.keyHash.length === "number" || $util.isString(message.keyHash)))
                        return "keyHash: buffer expected";
                if (message.entries != null && message.hasOwnProperty("entries")) {
                    if (!Array.isArray(message.entries))
                        return "entries: array expected";
                    for (var i = 0; i < message.entries.length; ++i) {
                        var error = $root.kvrwset.KVMetadataEntry.verify(message.entries[i]);
                        if (error)
                            return "entries." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a KVMetadataWriteHash message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVMetadataWriteHash} KVMetadataWriteHash
             */
            KVMetadataWriteHash.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVMetadataWriteHash)
                    return object;
                var message = new $root.kvrwset.KVMetadataWriteHash();
                if (object.keyHash != null)
                    if (typeof object.keyHash === "string")
                        $util.base64.decode(object.keyHash, message.keyHash = $util.newBuffer($util.base64.length(object.keyHash)), 0);
                    else if (object.keyHash.length)
                        message.keyHash = object.keyHash;
                if (object.entries) {
                    if (!Array.isArray(object.entries))
                        throw TypeError(".kvrwset.KVMetadataWriteHash.entries: array expected");
                    message.entries = [];
                    for (var i = 0; i < object.entries.length; ++i) {
                        if (typeof object.entries[i] !== "object")
                            throw TypeError(".kvrwset.KVMetadataWriteHash.entries: object expected");
                        message.entries[i] = $root.kvrwset.KVMetadataEntry.fromObject(object.entries[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KVMetadataWriteHash message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVMetadataWriteHash
             * @static
             * @param {kvrwset.KVMetadataWriteHash} message KVMetadataWriteHash
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVMetadataWriteHash.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.entries = [];
                if (options.defaults)
                    if (options.bytes === String)
                        object.keyHash = "";
                    else {
                        object.keyHash = [];
                        if (options.bytes !== Array)
                            object.keyHash = $util.newBuffer(object.keyHash);
                    }
                if (message.keyHash != null && message.hasOwnProperty("keyHash"))
                    object.keyHash = options.bytes === String ? $util.base64.encode(message.keyHash, 0, message.keyHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.keyHash) : message.keyHash;
                if (message.entries && message.entries.length) {
                    object.entries = [];
                    for (var j = 0; j < message.entries.length; ++j)
                        object.entries[j] = $root.kvrwset.KVMetadataEntry.toObject(message.entries[j], options);
                }
                return object;
            };
    
            /**
             * Converts this KVMetadataWriteHash to JSON.
             * @function toJSON
             * @memberof kvrwset.KVMetadataWriteHash
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVMetadataWriteHash.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVMetadataWriteHash;
        })();
    
        kvrwset.KVMetadataEntry = (function() {
    
            /**
             * Properties of a KVMetadataEntry.
             * @memberof kvrwset
             * @interface IKVMetadataEntry
             * @property {string|null} [name] KVMetadataEntry name
             * @property {Uint8Array|null} [value] KVMetadataEntry value
             */
    
            /**
             * Constructs a new KVMetadataEntry.
             * @memberof kvrwset
             * @classdesc Represents a KVMetadataEntry.
             * @implements IKVMetadataEntry
             * @constructor
             * @param {kvrwset.IKVMetadataEntry=} [properties] Properties to set
             */
            function KVMetadataEntry(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KVMetadataEntry name.
             * @member {string} name
             * @memberof kvrwset.KVMetadataEntry
             * @instance
             */
            KVMetadataEntry.prototype.name = "";
    
            /**
             * KVMetadataEntry value.
             * @member {Uint8Array} value
             * @memberof kvrwset.KVMetadataEntry
             * @instance
             */
            KVMetadataEntry.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new KVMetadataEntry instance using the specified properties.
             * @function create
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {kvrwset.IKVMetadataEntry=} [properties] Properties to set
             * @returns {kvrwset.KVMetadataEntry} KVMetadataEntry instance
             */
            KVMetadataEntry.create = function create(properties) {
                return new KVMetadataEntry(properties);
            };
    
            /**
             * Encodes the specified KVMetadataEntry message. Does not implicitly {@link kvrwset.KVMetadataEntry.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {kvrwset.IKVMetadataEntry} message KVMetadataEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified KVMetadataEntry message, length delimited. Does not implicitly {@link kvrwset.KVMetadataEntry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {kvrwset.IKVMetadataEntry} message KVMetadataEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KVMetadataEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KVMetadataEntry message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.KVMetadataEntry} KVMetadataEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.KVMetadataEntry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KVMetadataEntry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.KVMetadataEntry} KVMetadataEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KVMetadataEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KVMetadataEntry message.
             * @function verify
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KVMetadataEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a KVMetadataEntry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.KVMetadataEntry} KVMetadataEntry
             */
            KVMetadataEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.KVMetadataEntry)
                    return object;
                var message = new $root.kvrwset.KVMetadataEntry();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a KVMetadataEntry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.KVMetadataEntry
             * @static
             * @param {kvrwset.KVMetadataEntry} message KVMetadataEntry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KVMetadataEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this KVMetadataEntry to JSON.
             * @function toJSON
             * @memberof kvrwset.KVMetadataEntry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KVMetadataEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KVMetadataEntry;
        })();
    
        kvrwset.Version = (function() {
    
            /**
             * Properties of a Version.
             * @memberof kvrwset
             * @interface IVersion
             * @property {number|Long|null} [blockNum] Version blockNum
             * @property {number|Long|null} [txNum] Version txNum
             */
    
            /**
             * Constructs a new Version.
             * @memberof kvrwset
             * @classdesc Represents a Version.
             * @implements IVersion
             * @constructor
             * @param {kvrwset.IVersion=} [properties] Properties to set
             */
            function Version(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Version blockNum.
             * @member {number|Long} blockNum
             * @memberof kvrwset.Version
             * @instance
             */
            Version.prototype.blockNum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Version txNum.
             * @member {number|Long} txNum
             * @memberof kvrwset.Version
             * @instance
             */
            Version.prototype.txNum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new Version instance using the specified properties.
             * @function create
             * @memberof kvrwset.Version
             * @static
             * @param {kvrwset.IVersion=} [properties] Properties to set
             * @returns {kvrwset.Version} Version instance
             */
            Version.create = function create(properties) {
                return new Version(properties);
            };
    
            /**
             * Encodes the specified Version message. Does not implicitly {@link kvrwset.Version.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.Version
             * @static
             * @param {kvrwset.IVersion} message Version message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Version.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.blockNum != null && message.hasOwnProperty("blockNum"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.blockNum);
                if (message.txNum != null && message.hasOwnProperty("txNum"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.txNum);
                return writer;
            };
    
            /**
             * Encodes the specified Version message, length delimited. Does not implicitly {@link kvrwset.Version.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.Version
             * @static
             * @param {kvrwset.IVersion} message Version message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Version.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Version message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.Version
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.Version} Version
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Version.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.Version();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.blockNum = reader.uint64();
                        break;
                    case 2:
                        message.txNum = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Version message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.Version
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.Version} Version
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Version.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Version message.
             * @function verify
             * @memberof kvrwset.Version
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Version.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.blockNum != null && message.hasOwnProperty("blockNum"))
                    if (!$util.isInteger(message.blockNum) && !(message.blockNum && $util.isInteger(message.blockNum.low) && $util.isInteger(message.blockNum.high)))
                        return "blockNum: integer|Long expected";
                if (message.txNum != null && message.hasOwnProperty("txNum"))
                    if (!$util.isInteger(message.txNum) && !(message.txNum && $util.isInteger(message.txNum.low) && $util.isInteger(message.txNum.high)))
                        return "txNum: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a Version message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.Version
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.Version} Version
             */
            Version.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.Version)
                    return object;
                var message = new $root.kvrwset.Version();
                if (object.blockNum != null)
                    if ($util.Long)
                        (message.blockNum = $util.Long.fromValue(object.blockNum)).unsigned = true;
                    else if (typeof object.blockNum === "string")
                        message.blockNum = parseInt(object.blockNum, 10);
                    else if (typeof object.blockNum === "number")
                        message.blockNum = object.blockNum;
                    else if (typeof object.blockNum === "object")
                        message.blockNum = new $util.LongBits(object.blockNum.low >>> 0, object.blockNum.high >>> 0).toNumber(true);
                if (object.txNum != null)
                    if ($util.Long)
                        (message.txNum = $util.Long.fromValue(object.txNum)).unsigned = true;
                    else if (typeof object.txNum === "string")
                        message.txNum = parseInt(object.txNum, 10);
                    else if (typeof object.txNum === "number")
                        message.txNum = object.txNum;
                    else if (typeof object.txNum === "object")
                        message.txNum = new $util.LongBits(object.txNum.low >>> 0, object.txNum.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a Version message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.Version
             * @static
             * @param {kvrwset.Version} message Version
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Version.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.blockNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.blockNum = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.txNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.txNum = options.longs === String ? "0" : 0;
                }
                if (message.blockNum != null && message.hasOwnProperty("blockNum"))
                    if (typeof message.blockNum === "number")
                        object.blockNum = options.longs === String ? String(message.blockNum) : message.blockNum;
                    else
                        object.blockNum = options.longs === String ? $util.Long.prototype.toString.call(message.blockNum) : options.longs === Number ? new $util.LongBits(message.blockNum.low >>> 0, message.blockNum.high >>> 0).toNumber(true) : message.blockNum;
                if (message.txNum != null && message.hasOwnProperty("txNum"))
                    if (typeof message.txNum === "number")
                        object.txNum = options.longs === String ? String(message.txNum) : message.txNum;
                    else
                        object.txNum = options.longs === String ? $util.Long.prototype.toString.call(message.txNum) : options.longs === Number ? new $util.LongBits(message.txNum.low >>> 0, message.txNum.high >>> 0).toNumber(true) : message.txNum;
                return object;
            };
    
            /**
             * Converts this Version to JSON.
             * @function toJSON
             * @memberof kvrwset.Version
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Version.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Version;
        })();
    
        kvrwset.RangeQueryInfo = (function() {
    
            /**
             * Properties of a RangeQueryInfo.
             * @memberof kvrwset
             * @interface IRangeQueryInfo
             * @property {string|null} [startKey] RangeQueryInfo startKey
             * @property {string|null} [endKey] RangeQueryInfo endKey
             * @property {boolean|null} [itrExhausted] RangeQueryInfo itrExhausted
             * @property {kvrwset.IQueryReads|null} [rawReads] RangeQueryInfo rawReads
             * @property {kvrwset.IQueryReadsMerkleSummary|null} [readsMerkleHashes] RangeQueryInfo readsMerkleHashes
             */
    
            /**
             * Constructs a new RangeQueryInfo.
             * @memberof kvrwset
             * @classdesc Represents a RangeQueryInfo.
             * @implements IRangeQueryInfo
             * @constructor
             * @param {kvrwset.IRangeQueryInfo=} [properties] Properties to set
             */
            function RangeQueryInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RangeQueryInfo startKey.
             * @member {string} startKey
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.startKey = "";
    
            /**
             * RangeQueryInfo endKey.
             * @member {string} endKey
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.endKey = "";
    
            /**
             * RangeQueryInfo itrExhausted.
             * @member {boolean} itrExhausted
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.itrExhausted = false;
    
            /**
             * RangeQueryInfo rawReads.
             * @member {kvrwset.IQueryReads|null|undefined} rawReads
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.rawReads = null;
    
            /**
             * RangeQueryInfo readsMerkleHashes.
             * @member {kvrwset.IQueryReadsMerkleSummary|null|undefined} readsMerkleHashes
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            RangeQueryInfo.prototype.readsMerkleHashes = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * RangeQueryInfo readsInfo.
             * @member {"rawReads"|"readsMerkleHashes"|undefined} readsInfo
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             */
            Object.defineProperty(RangeQueryInfo.prototype, "readsInfo", {
                get: $util.oneOfGetter($oneOfFields = ["rawReads", "readsMerkleHashes"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new RangeQueryInfo instance using the specified properties.
             * @function create
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {kvrwset.IRangeQueryInfo=} [properties] Properties to set
             * @returns {kvrwset.RangeQueryInfo} RangeQueryInfo instance
             */
            RangeQueryInfo.create = function create(properties) {
                return new RangeQueryInfo(properties);
            };
    
            /**
             * Encodes the specified RangeQueryInfo message. Does not implicitly {@link kvrwset.RangeQueryInfo.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {kvrwset.IRangeQueryInfo} message RangeQueryInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RangeQueryInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.startKey != null && message.hasOwnProperty("startKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.startKey);
                if (message.endKey != null && message.hasOwnProperty("endKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.endKey);
                if (message.itrExhausted != null && message.hasOwnProperty("itrExhausted"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.itrExhausted);
                if (message.rawReads != null && message.hasOwnProperty("rawReads"))
                    $root.kvrwset.QueryReads.encode(message.rawReads, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.readsMerkleHashes != null && message.hasOwnProperty("readsMerkleHashes"))
                    $root.kvrwset.QueryReadsMerkleSummary.encode(message.readsMerkleHashes, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified RangeQueryInfo message, length delimited. Does not implicitly {@link kvrwset.RangeQueryInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {kvrwset.IRangeQueryInfo} message RangeQueryInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RangeQueryInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a RangeQueryInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.RangeQueryInfo} RangeQueryInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RangeQueryInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.RangeQueryInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.startKey = reader.string();
                        break;
                    case 2:
                        message.endKey = reader.string();
                        break;
                    case 3:
                        message.itrExhausted = reader.bool();
                        break;
                    case 4:
                        message.rawReads = $root.kvrwset.QueryReads.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.readsMerkleHashes = $root.kvrwset.QueryReadsMerkleSummary.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a RangeQueryInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.RangeQueryInfo} RangeQueryInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RangeQueryInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a RangeQueryInfo message.
             * @function verify
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RangeQueryInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.startKey != null && message.hasOwnProperty("startKey"))
                    if (!$util.isString(message.startKey))
                        return "startKey: string expected";
                if (message.endKey != null && message.hasOwnProperty("endKey"))
                    if (!$util.isString(message.endKey))
                        return "endKey: string expected";
                if (message.itrExhausted != null && message.hasOwnProperty("itrExhausted"))
                    if (typeof message.itrExhausted !== "boolean")
                        return "itrExhausted: boolean expected";
                if (message.rawReads != null && message.hasOwnProperty("rawReads")) {
                    properties.readsInfo = 1;
                    {
                        var error = $root.kvrwset.QueryReads.verify(message.rawReads);
                        if (error)
                            return "rawReads." + error;
                    }
                }
                if (message.readsMerkleHashes != null && message.hasOwnProperty("readsMerkleHashes")) {
                    if (properties.readsInfo === 1)
                        return "readsInfo: multiple values";
                    properties.readsInfo = 1;
                    {
                        var error = $root.kvrwset.QueryReadsMerkleSummary.verify(message.readsMerkleHashes);
                        if (error)
                            return "readsMerkleHashes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a RangeQueryInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.RangeQueryInfo} RangeQueryInfo
             */
            RangeQueryInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.RangeQueryInfo)
                    return object;
                var message = new $root.kvrwset.RangeQueryInfo();
                if (object.startKey != null)
                    message.startKey = String(object.startKey);
                if (object.endKey != null)
                    message.endKey = String(object.endKey);
                if (object.itrExhausted != null)
                    message.itrExhausted = Boolean(object.itrExhausted);
                if (object.rawReads != null) {
                    if (typeof object.rawReads !== "object")
                        throw TypeError(".kvrwset.RangeQueryInfo.rawReads: object expected");
                    message.rawReads = $root.kvrwset.QueryReads.fromObject(object.rawReads);
                }
                if (object.readsMerkleHashes != null) {
                    if (typeof object.readsMerkleHashes !== "object")
                        throw TypeError(".kvrwset.RangeQueryInfo.readsMerkleHashes: object expected");
                    message.readsMerkleHashes = $root.kvrwset.QueryReadsMerkleSummary.fromObject(object.readsMerkleHashes);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a RangeQueryInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.RangeQueryInfo
             * @static
             * @param {kvrwset.RangeQueryInfo} message RangeQueryInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RangeQueryInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.startKey = "";
                    object.endKey = "";
                    object.itrExhausted = false;
                }
                if (message.startKey != null && message.hasOwnProperty("startKey"))
                    object.startKey = message.startKey;
                if (message.endKey != null && message.hasOwnProperty("endKey"))
                    object.endKey = message.endKey;
                if (message.itrExhausted != null && message.hasOwnProperty("itrExhausted"))
                    object.itrExhausted = message.itrExhausted;
                if (message.rawReads != null && message.hasOwnProperty("rawReads")) {
                    object.rawReads = $root.kvrwset.QueryReads.toObject(message.rawReads, options);
                    if (options.oneofs)
                        object.readsInfo = "rawReads";
                }
                if (message.readsMerkleHashes != null && message.hasOwnProperty("readsMerkleHashes")) {
                    object.readsMerkleHashes = $root.kvrwset.QueryReadsMerkleSummary.toObject(message.readsMerkleHashes, options);
                    if (options.oneofs)
                        object.readsInfo = "readsMerkleHashes";
                }
                return object;
            };
    
            /**
             * Converts this RangeQueryInfo to JSON.
             * @function toJSON
             * @memberof kvrwset.RangeQueryInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RangeQueryInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return RangeQueryInfo;
        })();
    
        kvrwset.QueryReads = (function() {
    
            /**
             * Properties of a QueryReads.
             * @memberof kvrwset
             * @interface IQueryReads
             * @property {Array.<kvrwset.IKVRead>|null} [kvReads] QueryReads kvReads
             */
    
            /**
             * Constructs a new QueryReads.
             * @memberof kvrwset
             * @classdesc Represents a QueryReads.
             * @implements IQueryReads
             * @constructor
             * @param {kvrwset.IQueryReads=} [properties] Properties to set
             */
            function QueryReads(properties) {
                this.kvReads = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryReads kvReads.
             * @member {Array.<kvrwset.IKVRead>} kvReads
             * @memberof kvrwset.QueryReads
             * @instance
             */
            QueryReads.prototype.kvReads = $util.emptyArray;
    
            /**
             * Creates a new QueryReads instance using the specified properties.
             * @function create
             * @memberof kvrwset.QueryReads
             * @static
             * @param {kvrwset.IQueryReads=} [properties] Properties to set
             * @returns {kvrwset.QueryReads} QueryReads instance
             */
            QueryReads.create = function create(properties) {
                return new QueryReads(properties);
            };
    
            /**
             * Encodes the specified QueryReads message. Does not implicitly {@link kvrwset.QueryReads.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.QueryReads
             * @static
             * @param {kvrwset.IQueryReads} message QueryReads message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryReads.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kvReads != null && message.kvReads.length)
                    for (var i = 0; i < message.kvReads.length; ++i)
                        $root.kvrwset.KVRead.encode(message.kvReads[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified QueryReads message, length delimited. Does not implicitly {@link kvrwset.QueryReads.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.QueryReads
             * @static
             * @param {kvrwset.IQueryReads} message QueryReads message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryReads.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryReads message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.QueryReads
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.QueryReads} QueryReads
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryReads.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.QueryReads();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.kvReads && message.kvReads.length))
                            message.kvReads = [];
                        message.kvReads.push($root.kvrwset.KVRead.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryReads message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.QueryReads
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.QueryReads} QueryReads
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryReads.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryReads message.
             * @function verify
             * @memberof kvrwset.QueryReads
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryReads.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kvReads != null && message.hasOwnProperty("kvReads")) {
                    if (!Array.isArray(message.kvReads))
                        return "kvReads: array expected";
                    for (var i = 0; i < message.kvReads.length; ++i) {
                        var error = $root.kvrwset.KVRead.verify(message.kvReads[i]);
                        if (error)
                            return "kvReads." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a QueryReads message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.QueryReads
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.QueryReads} QueryReads
             */
            QueryReads.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.QueryReads)
                    return object;
                var message = new $root.kvrwset.QueryReads();
                if (object.kvReads) {
                    if (!Array.isArray(object.kvReads))
                        throw TypeError(".kvrwset.QueryReads.kvReads: array expected");
                    message.kvReads = [];
                    for (var i = 0; i < object.kvReads.length; ++i) {
                        if (typeof object.kvReads[i] !== "object")
                            throw TypeError(".kvrwset.QueryReads.kvReads: object expected");
                        message.kvReads[i] = $root.kvrwset.KVRead.fromObject(object.kvReads[i]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryReads message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.QueryReads
             * @static
             * @param {kvrwset.QueryReads} message QueryReads
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryReads.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.kvReads = [];
                if (message.kvReads && message.kvReads.length) {
                    object.kvReads = [];
                    for (var j = 0; j < message.kvReads.length; ++j)
                        object.kvReads[j] = $root.kvrwset.KVRead.toObject(message.kvReads[j], options);
                }
                return object;
            };
    
            /**
             * Converts this QueryReads to JSON.
             * @function toJSON
             * @memberof kvrwset.QueryReads
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryReads.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryReads;
        })();
    
        kvrwset.QueryReadsMerkleSummary = (function() {
    
            /**
             * Properties of a QueryReadsMerkleSummary.
             * @memberof kvrwset
             * @interface IQueryReadsMerkleSummary
             * @property {number|null} [maxDegree] QueryReadsMerkleSummary maxDegree
             * @property {number|null} [maxLevel] QueryReadsMerkleSummary maxLevel
             * @property {Array.<Uint8Array>|null} [maxLevelHashes] QueryReadsMerkleSummary maxLevelHashes
             */
    
            /**
             * Constructs a new QueryReadsMerkleSummary.
             * @memberof kvrwset
             * @classdesc Represents a QueryReadsMerkleSummary.
             * @implements IQueryReadsMerkleSummary
             * @constructor
             * @param {kvrwset.IQueryReadsMerkleSummary=} [properties] Properties to set
             */
            function QueryReadsMerkleSummary(properties) {
                this.maxLevelHashes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryReadsMerkleSummary maxDegree.
             * @member {number} maxDegree
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @instance
             */
            QueryReadsMerkleSummary.prototype.maxDegree = 0;
    
            /**
             * QueryReadsMerkleSummary maxLevel.
             * @member {number} maxLevel
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @instance
             */
            QueryReadsMerkleSummary.prototype.maxLevel = 0;
    
            /**
             * QueryReadsMerkleSummary maxLevelHashes.
             * @member {Array.<Uint8Array>} maxLevelHashes
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @instance
             */
            QueryReadsMerkleSummary.prototype.maxLevelHashes = $util.emptyArray;
    
            /**
             * Creates a new QueryReadsMerkleSummary instance using the specified properties.
             * @function create
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {kvrwset.IQueryReadsMerkleSummary=} [properties] Properties to set
             * @returns {kvrwset.QueryReadsMerkleSummary} QueryReadsMerkleSummary instance
             */
            QueryReadsMerkleSummary.create = function create(properties) {
                return new QueryReadsMerkleSummary(properties);
            };
    
            /**
             * Encodes the specified QueryReadsMerkleSummary message. Does not implicitly {@link kvrwset.QueryReadsMerkleSummary.verify|verify} messages.
             * @function encode
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {kvrwset.IQueryReadsMerkleSummary} message QueryReadsMerkleSummary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryReadsMerkleSummary.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.maxDegree != null && message.hasOwnProperty("maxDegree"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.maxDegree);
                if (message.maxLevel != null && message.hasOwnProperty("maxLevel"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.maxLevel);
                if (message.maxLevelHashes != null && message.maxLevelHashes.length)
                    for (var i = 0; i < message.maxLevelHashes.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.maxLevelHashes[i]);
                return writer;
            };
    
            /**
             * Encodes the specified QueryReadsMerkleSummary message, length delimited. Does not implicitly {@link kvrwset.QueryReadsMerkleSummary.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {kvrwset.IQueryReadsMerkleSummary} message QueryReadsMerkleSummary message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryReadsMerkleSummary.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a QueryReadsMerkleSummary message from the specified reader or buffer.
             * @function decode
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kvrwset.QueryReadsMerkleSummary} QueryReadsMerkleSummary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryReadsMerkleSummary.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.kvrwset.QueryReadsMerkleSummary();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.maxDegree = reader.uint32();
                        break;
                    case 2:
                        message.maxLevel = reader.uint32();
                        break;
                    case 3:
                        if (!(message.maxLevelHashes && message.maxLevelHashes.length))
                            message.maxLevelHashes = [];
                        message.maxLevelHashes.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a QueryReadsMerkleSummary message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kvrwset.QueryReadsMerkleSummary} QueryReadsMerkleSummary
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryReadsMerkleSummary.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a QueryReadsMerkleSummary message.
             * @function verify
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryReadsMerkleSummary.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.maxDegree != null && message.hasOwnProperty("maxDegree"))
                    if (!$util.isInteger(message.maxDegree))
                        return "maxDegree: integer expected";
                if (message.maxLevel != null && message.hasOwnProperty("maxLevel"))
                    if (!$util.isInteger(message.maxLevel))
                        return "maxLevel: integer expected";
                if (message.maxLevelHashes != null && message.hasOwnProperty("maxLevelHashes")) {
                    if (!Array.isArray(message.maxLevelHashes))
                        return "maxLevelHashes: array expected";
                    for (var i = 0; i < message.maxLevelHashes.length; ++i)
                        if (!(message.maxLevelHashes[i] && typeof message.maxLevelHashes[i].length === "number" || $util.isString(message.maxLevelHashes[i])))
                            return "maxLevelHashes: buffer[] expected";
                }
                return null;
            };
    
            /**
             * Creates a QueryReadsMerkleSummary message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kvrwset.QueryReadsMerkleSummary} QueryReadsMerkleSummary
             */
            QueryReadsMerkleSummary.fromObject = function fromObject(object) {
                if (object instanceof $root.kvrwset.QueryReadsMerkleSummary)
                    return object;
                var message = new $root.kvrwset.QueryReadsMerkleSummary();
                if (object.maxDegree != null)
                    message.maxDegree = object.maxDegree >>> 0;
                if (object.maxLevel != null)
                    message.maxLevel = object.maxLevel >>> 0;
                if (object.maxLevelHashes) {
                    if (!Array.isArray(object.maxLevelHashes))
                        throw TypeError(".kvrwset.QueryReadsMerkleSummary.maxLevelHashes: array expected");
                    message.maxLevelHashes = [];
                    for (var i = 0; i < object.maxLevelHashes.length; ++i)
                        if (typeof object.maxLevelHashes[i] === "string")
                            $util.base64.decode(object.maxLevelHashes[i], message.maxLevelHashes[i] = $util.newBuffer($util.base64.length(object.maxLevelHashes[i])), 0);
                        else if (object.maxLevelHashes[i].length)
                            message.maxLevelHashes[i] = object.maxLevelHashes[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a QueryReadsMerkleSummary message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @static
             * @param {kvrwset.QueryReadsMerkleSummary} message QueryReadsMerkleSummary
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryReadsMerkleSummary.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.maxLevelHashes = [];
                if (options.defaults) {
                    object.maxDegree = 0;
                    object.maxLevel = 0;
                }
                if (message.maxDegree != null && message.hasOwnProperty("maxDegree"))
                    object.maxDegree = message.maxDegree;
                if (message.maxLevel != null && message.hasOwnProperty("maxLevel"))
                    object.maxLevel = message.maxLevel;
                if (message.maxLevelHashes && message.maxLevelHashes.length) {
                    object.maxLevelHashes = [];
                    for (var j = 0; j < message.maxLevelHashes.length; ++j)
                        object.maxLevelHashes[j] = options.bytes === String ? $util.base64.encode(message.maxLevelHashes[j], 0, message.maxLevelHashes[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.maxLevelHashes[j]) : message.maxLevelHashes[j];
                }
                return object;
            };
    
            /**
             * Converts this QueryReadsMerkleSummary to JSON.
             * @function toJSON
             * @memberof kvrwset.QueryReadsMerkleSummary
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryReadsMerkleSummary.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return QueryReadsMerkleSummary;
        })();
    
        return kvrwset;
    })();
    
    $root.queryresult = (function() {
    
        /**
         * Namespace queryresult.
         * @exports queryresult
         * @namespace
         */
        var queryresult = {};
    
        queryresult.KV = (function() {
    
            /**
             * Properties of a KV.
             * @memberof queryresult
             * @interface IKV
             * @property {string|null} [namespace] KV namespace
             * @property {string|null} [key] KV key
             * @property {Uint8Array|null} [value] KV value
             */
    
            /**
             * Constructs a new KV.
             * @memberof queryresult
             * @classdesc Represents a KV.
             * @implements IKV
             * @constructor
             * @param {queryresult.IKV=} [properties] Properties to set
             */
            function KV(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KV namespace.
             * @member {string} namespace
             * @memberof queryresult.KV
             * @instance
             */
            KV.prototype.namespace = "";
    
            /**
             * KV key.
             * @member {string} key
             * @memberof queryresult.KV
             * @instance
             */
            KV.prototype.key = "";
    
            /**
             * KV value.
             * @member {Uint8Array} value
             * @memberof queryresult.KV
             * @instance
             */
            KV.prototype.value = $util.newBuffer([]);
    
            /**
             * Creates a new KV instance using the specified properties.
             * @function create
             * @memberof queryresult.KV
             * @static
             * @param {queryresult.IKV=} [properties] Properties to set
             * @returns {queryresult.KV} KV instance
             */
            KV.create = function create(properties) {
                return new KV(properties);
            };
    
            /**
             * Encodes the specified KV message. Does not implicitly {@link queryresult.KV.verify|verify} messages.
             * @function encode
             * @memberof queryresult.KV
             * @static
             * @param {queryresult.IKV} message KV message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KV.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                return writer;
            };
    
            /**
             * Encodes the specified KV message, length delimited. Does not implicitly {@link queryresult.KV.verify|verify} messages.
             * @function encodeDelimited
             * @memberof queryresult.KV
             * @static
             * @param {queryresult.IKV} message KV message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KV.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KV message from the specified reader or buffer.
             * @function decode
             * @memberof queryresult.KV
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {queryresult.KV} KV
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KV.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.queryresult.KV();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.namespace = reader.string();
                        break;
                    case 2:
                        message.key = reader.string();
                        break;
                    case 3:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KV message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof queryresult.KV
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {queryresult.KV} KV
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KV.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KV message.
             * @function verify
             * @memberof queryresult.KV
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KV.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    if (!$util.isString(message.namespace))
                        return "namespace: string expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };
    
            /**
             * Creates a KV message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof queryresult.KV
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {queryresult.KV} KV
             */
            KV.fromObject = function fromObject(object) {
                if (object instanceof $root.queryresult.KV)
                    return object;
                var message = new $root.queryresult.KV();
                if (object.namespace != null)
                    message.namespace = String(object.namespace);
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };
    
            /**
             * Creates a plain object from a KV message. Also converts values to other types if specified.
             * @function toObject
             * @memberof queryresult.KV
             * @static
             * @param {queryresult.KV} message KV
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KV.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.namespace = "";
                    object.key = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.namespace != null && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };
    
            /**
             * Converts this KV to JSON.
             * @function toJSON
             * @memberof queryresult.KV
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KV.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KV;
        })();
    
        queryresult.KeyModification = (function() {
    
            /**
             * Properties of a KeyModification.
             * @memberof queryresult
             * @interface IKeyModification
             * @property {string|null} [txId] KeyModification txId
             * @property {Uint8Array|null} [value] KeyModification value
             * @property {google.protobuf.ITimestamp|null} [timestamp] KeyModification timestamp
             * @property {boolean|null} [isDelete] KeyModification isDelete
             */
    
            /**
             * Constructs a new KeyModification.
             * @memberof queryresult
             * @classdesc Represents a KeyModification.
             * @implements IKeyModification
             * @constructor
             * @param {queryresult.IKeyModification=} [properties] Properties to set
             */
            function KeyModification(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KeyModification txId.
             * @member {string} txId
             * @memberof queryresult.KeyModification
             * @instance
             */
            KeyModification.prototype.txId = "";
    
            /**
             * KeyModification value.
             * @member {Uint8Array} value
             * @memberof queryresult.KeyModification
             * @instance
             */
            KeyModification.prototype.value = $util.newBuffer([]);
    
            /**
             * KeyModification timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof queryresult.KeyModification
             * @instance
             */
            KeyModification.prototype.timestamp = null;
    
            /**
             * KeyModification isDelete.
             * @member {boolean} isDelete
             * @memberof queryresult.KeyModification
             * @instance
             */
            KeyModification.prototype.isDelete = false;
    
            /**
             * Creates a new KeyModification instance using the specified properties.
             * @function create
             * @memberof queryresult.KeyModification
             * @static
             * @param {queryresult.IKeyModification=} [properties] Properties to set
             * @returns {queryresult.KeyModification} KeyModification instance
             */
            KeyModification.create = function create(properties) {
                return new KeyModification(properties);
            };
    
            /**
             * Encodes the specified KeyModification message. Does not implicitly {@link queryresult.KeyModification.verify|verify} messages.
             * @function encode
             * @memberof queryresult.KeyModification
             * @static
             * @param {queryresult.IKeyModification} message KeyModification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyModification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txId != null && message.hasOwnProperty("txId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.txId);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isDelete);
                return writer;
            };
    
            /**
             * Encodes the specified KeyModification message, length delimited. Does not implicitly {@link queryresult.KeyModification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof queryresult.KeyModification
             * @static
             * @param {queryresult.IKeyModification} message KeyModification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyModification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KeyModification message from the specified reader or buffer.
             * @function decode
             * @memberof queryresult.KeyModification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {queryresult.KeyModification} KeyModification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyModification.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.queryresult.KeyModification();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txId = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    case 3:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.isDelete = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KeyModification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof queryresult.KeyModification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {queryresult.KeyModification} KeyModification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyModification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KeyModification message.
             * @function verify
             * @memberof queryresult.KeyModification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyModification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isString(message.txId))
                        return "txId: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                    if (typeof message.isDelete !== "boolean")
                        return "isDelete: boolean expected";
                return null;
            };
    
            /**
             * Creates a KeyModification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof queryresult.KeyModification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {queryresult.KeyModification} KeyModification
             */
            KeyModification.fromObject = function fromObject(object) {
                if (object instanceof $root.queryresult.KeyModification)
                    return object;
                var message = new $root.queryresult.KeyModification();
                if (object.txId != null)
                    message.txId = String(object.txId);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".queryresult.KeyModification.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                if (object.isDelete != null)
                    message.isDelete = Boolean(object.isDelete);
                return message;
            };
    
            /**
             * Creates a plain object from a KeyModification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof queryresult.KeyModification
             * @static
             * @param {queryresult.KeyModification} message KeyModification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyModification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.txId = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                    object.timestamp = null;
                    object.isDelete = false;
                }
                if (message.txId != null && message.hasOwnProperty("txId"))
                    object.txId = message.txId;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                if (message.isDelete != null && message.hasOwnProperty("isDelete"))
                    object.isDelete = message.isDelete;
                return object;
            };
    
            /**
             * Converts this KeyModification to JSON.
             * @function toJSON
             * @memberof queryresult.KeyModification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyModification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KeyModification;
        })();
    
        return queryresult;
    })();
    
    $root.transientstore = (function() {
    
        /**
         * Namespace transientstore.
         * @exports transientstore
         * @namespace
         */
        var transientstore = {};
    
        transientstore.TxPvtReadWriteSetWithConfigInfo = (function() {
    
            /**
             * Properties of a TxPvtReadWriteSetWithConfigInfo.
             * @memberof transientstore
             * @interface ITxPvtReadWriteSetWithConfigInfo
             * @property {number|Long|null} [endorsedAt] TxPvtReadWriteSetWithConfigInfo endorsedAt
             * @property {rwset.ITxPvtReadWriteSet|null} [pvtRwset] TxPvtReadWriteSetWithConfigInfo pvtRwset
             * @property {Object.<string,common.ICollectionConfigPackage>|null} [collectionConfigs] TxPvtReadWriteSetWithConfigInfo collectionConfigs
             */
    
            /**
             * Constructs a new TxPvtReadWriteSetWithConfigInfo.
             * @memberof transientstore
             * @classdesc Represents a TxPvtReadWriteSetWithConfigInfo.
             * @implements ITxPvtReadWriteSetWithConfigInfo
             * @constructor
             * @param {transientstore.ITxPvtReadWriteSetWithConfigInfo=} [properties] Properties to set
             */
            function TxPvtReadWriteSetWithConfigInfo(properties) {
                this.collectionConfigs = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TxPvtReadWriteSetWithConfigInfo endorsedAt.
             * @member {number|Long} endorsedAt
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @instance
             */
            TxPvtReadWriteSetWithConfigInfo.prototype.endorsedAt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * TxPvtReadWriteSetWithConfigInfo pvtRwset.
             * @member {rwset.ITxPvtReadWriteSet|null|undefined} pvtRwset
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @instance
             */
            TxPvtReadWriteSetWithConfigInfo.prototype.pvtRwset = null;
    
            /**
             * TxPvtReadWriteSetWithConfigInfo collectionConfigs.
             * @member {Object.<string,common.ICollectionConfigPackage>} collectionConfigs
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @instance
             */
            TxPvtReadWriteSetWithConfigInfo.prototype.collectionConfigs = $util.emptyObject;
    
            /**
             * Creates a new TxPvtReadWriteSetWithConfigInfo instance using the specified properties.
             * @function create
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {transientstore.ITxPvtReadWriteSetWithConfigInfo=} [properties] Properties to set
             * @returns {transientstore.TxPvtReadWriteSetWithConfigInfo} TxPvtReadWriteSetWithConfigInfo instance
             */
            TxPvtReadWriteSetWithConfigInfo.create = function create(properties) {
                return new TxPvtReadWriteSetWithConfigInfo(properties);
            };
    
            /**
             * Encodes the specified TxPvtReadWriteSetWithConfigInfo message. Does not implicitly {@link transientstore.TxPvtReadWriteSetWithConfigInfo.verify|verify} messages.
             * @function encode
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {transientstore.ITxPvtReadWriteSetWithConfigInfo} message TxPvtReadWriteSetWithConfigInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxPvtReadWriteSetWithConfigInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endorsedAt != null && message.hasOwnProperty("endorsedAt"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.endorsedAt);
                if (message.pvtRwset != null && message.hasOwnProperty("pvtRwset"))
                    $root.rwset.TxPvtReadWriteSet.encode(message.pvtRwset, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.collectionConfigs != null && message.hasOwnProperty("collectionConfigs"))
                    for (var keys = Object.keys(message.collectionConfigs), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.common.CollectionConfigPackage.encode(message.collectionConfigs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };
    
            /**
             * Encodes the specified TxPvtReadWriteSetWithConfigInfo message, length delimited. Does not implicitly {@link transientstore.TxPvtReadWriteSetWithConfigInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {transientstore.ITxPvtReadWriteSetWithConfigInfo} message TxPvtReadWriteSetWithConfigInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxPvtReadWriteSetWithConfigInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a TxPvtReadWriteSetWithConfigInfo message from the specified reader or buffer.
             * @function decode
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {transientstore.TxPvtReadWriteSetWithConfigInfo} TxPvtReadWriteSetWithConfigInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxPvtReadWriteSetWithConfigInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.transientstore.TxPvtReadWriteSetWithConfigInfo(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.endorsedAt = reader.uint64();
                        break;
                    case 2:
                        message.pvtRwset = $root.rwset.TxPvtReadWriteSet.decode(reader, reader.uint32());
                        break;
                    case 3:
                        reader.skip().pos++;
                        if (message.collectionConfigs === $util.emptyObject)
                            message.collectionConfigs = {};
                        key = reader.string();
                        reader.pos++;
                        message.collectionConfigs[key] = $root.common.CollectionConfigPackage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a TxPvtReadWriteSetWithConfigInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {transientstore.TxPvtReadWriteSetWithConfigInfo} TxPvtReadWriteSetWithConfigInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxPvtReadWriteSetWithConfigInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a TxPvtReadWriteSetWithConfigInfo message.
             * @function verify
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxPvtReadWriteSetWithConfigInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endorsedAt != null && message.hasOwnProperty("endorsedAt"))
                    if (!$util.isInteger(message.endorsedAt) && !(message.endorsedAt && $util.isInteger(message.endorsedAt.low) && $util.isInteger(message.endorsedAt.high)))
                        return "endorsedAt: integer|Long expected";
                if (message.pvtRwset != null && message.hasOwnProperty("pvtRwset")) {
                    var error = $root.rwset.TxPvtReadWriteSet.verify(message.pvtRwset);
                    if (error)
                        return "pvtRwset." + error;
                }
                if (message.collectionConfigs != null && message.hasOwnProperty("collectionConfigs")) {
                    if (!$util.isObject(message.collectionConfigs))
                        return "collectionConfigs: object expected";
                    var key = Object.keys(message.collectionConfigs);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.common.CollectionConfigPackage.verify(message.collectionConfigs[key[i]]);
                        if (error)
                            return "collectionConfigs." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a TxPvtReadWriteSetWithConfigInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {transientstore.TxPvtReadWriteSetWithConfigInfo} TxPvtReadWriteSetWithConfigInfo
             */
            TxPvtReadWriteSetWithConfigInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.transientstore.TxPvtReadWriteSetWithConfigInfo)
                    return object;
                var message = new $root.transientstore.TxPvtReadWriteSetWithConfigInfo();
                if (object.endorsedAt != null)
                    if ($util.Long)
                        (message.endorsedAt = $util.Long.fromValue(object.endorsedAt)).unsigned = true;
                    else if (typeof object.endorsedAt === "string")
                        message.endorsedAt = parseInt(object.endorsedAt, 10);
                    else if (typeof object.endorsedAt === "number")
                        message.endorsedAt = object.endorsedAt;
                    else if (typeof object.endorsedAt === "object")
                        message.endorsedAt = new $util.LongBits(object.endorsedAt.low >>> 0, object.endorsedAt.high >>> 0).toNumber(true);
                if (object.pvtRwset != null) {
                    if (typeof object.pvtRwset !== "object")
                        throw TypeError(".transientstore.TxPvtReadWriteSetWithConfigInfo.pvtRwset: object expected");
                    message.pvtRwset = $root.rwset.TxPvtReadWriteSet.fromObject(object.pvtRwset);
                }
                if (object.collectionConfigs) {
                    if (typeof object.collectionConfigs !== "object")
                        throw TypeError(".transientstore.TxPvtReadWriteSetWithConfigInfo.collectionConfigs: object expected");
                    message.collectionConfigs = {};
                    for (var keys = Object.keys(object.collectionConfigs), i = 0; i < keys.length; ++i) {
                        if (typeof object.collectionConfigs[keys[i]] !== "object")
                            throw TypeError(".transientstore.TxPvtReadWriteSetWithConfigInfo.collectionConfigs: object expected");
                        message.collectionConfigs[keys[i]] = $root.common.CollectionConfigPackage.fromObject(object.collectionConfigs[keys[i]]);
                    }
                }
                return message;
            };
    
            /**
             * Creates a plain object from a TxPvtReadWriteSetWithConfigInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @static
             * @param {transientstore.TxPvtReadWriteSetWithConfigInfo} message TxPvtReadWriteSetWithConfigInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxPvtReadWriteSetWithConfigInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.collectionConfigs = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.endorsedAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.endorsedAt = options.longs === String ? "0" : 0;
                    object.pvtRwset = null;
                }
                if (message.endorsedAt != null && message.hasOwnProperty("endorsedAt"))
                    if (typeof message.endorsedAt === "number")
                        object.endorsedAt = options.longs === String ? String(message.endorsedAt) : message.endorsedAt;
                    else
                        object.endorsedAt = options.longs === String ? $util.Long.prototype.toString.call(message.endorsedAt) : options.longs === Number ? new $util.LongBits(message.endorsedAt.low >>> 0, message.endorsedAt.high >>> 0).toNumber(true) : message.endorsedAt;
                if (message.pvtRwset != null && message.hasOwnProperty("pvtRwset"))
                    object.pvtRwset = $root.rwset.TxPvtReadWriteSet.toObject(message.pvtRwset, options);
                var keys2;
                if (message.collectionConfigs && (keys2 = Object.keys(message.collectionConfigs)).length) {
                    object.collectionConfigs = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.collectionConfigs[keys2[j]] = $root.common.CollectionConfigPackage.toObject(message.collectionConfigs[keys2[j]], options);
                }
                return object;
            };
    
            /**
             * Converts this TxPvtReadWriteSetWithConfigInfo to JSON.
             * @function toJSON
             * @memberof transientstore.TxPvtReadWriteSetWithConfigInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxPvtReadWriteSetWithConfigInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return TxPvtReadWriteSetWithConfigInfo;
        })();
    
        return transientstore;
    })();
    
    $root.etcdraft = (function() {
    
        /**
         * Namespace etcdraft.
         * @exports etcdraft
         * @namespace
         */
        var etcdraft = {};
    
        etcdraft.BlockMetadata = (function() {
    
            /**
             * Properties of a BlockMetadata.
             * @memberof etcdraft
             * @interface IBlockMetadata
             * @property {Array.<number|Long>|null} [consenterIds] BlockMetadata consenterIds
             * @property {number|Long|null} [nextConsenterId] BlockMetadata nextConsenterId
             * @property {number|Long|null} [raftIndex] BlockMetadata raftIndex
             */
    
            /**
             * Constructs a new BlockMetadata.
             * @memberof etcdraft
             * @classdesc Represents a BlockMetadata.
             * @implements IBlockMetadata
             * @constructor
             * @param {etcdraft.IBlockMetadata=} [properties] Properties to set
             */
            function BlockMetadata(properties) {
                this.consenterIds = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BlockMetadata consenterIds.
             * @member {Array.<number|Long>} consenterIds
             * @memberof etcdraft.BlockMetadata
             * @instance
             */
            BlockMetadata.prototype.consenterIds = $util.emptyArray;
    
            /**
             * BlockMetadata nextConsenterId.
             * @member {number|Long} nextConsenterId
             * @memberof etcdraft.BlockMetadata
             * @instance
             */
            BlockMetadata.prototype.nextConsenterId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * BlockMetadata raftIndex.
             * @member {number|Long} raftIndex
             * @memberof etcdraft.BlockMetadata
             * @instance
             */
            BlockMetadata.prototype.raftIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new BlockMetadata instance using the specified properties.
             * @function create
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {etcdraft.IBlockMetadata=} [properties] Properties to set
             * @returns {etcdraft.BlockMetadata} BlockMetadata instance
             */
            BlockMetadata.create = function create(properties) {
                return new BlockMetadata(properties);
            };
    
            /**
             * Encodes the specified BlockMetadata message. Does not implicitly {@link etcdraft.BlockMetadata.verify|verify} messages.
             * @function encode
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {etcdraft.IBlockMetadata} message BlockMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.consenterIds != null && message.consenterIds.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.consenterIds.length; ++i)
                        writer.uint64(message.consenterIds[i]);
                    writer.ldelim();
                }
                if (message.nextConsenterId != null && message.hasOwnProperty("nextConsenterId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nextConsenterId);
                if (message.raftIndex != null && message.hasOwnProperty("raftIndex"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.raftIndex);
                return writer;
            };
    
            /**
             * Encodes the specified BlockMetadata message, length delimited. Does not implicitly {@link etcdraft.BlockMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {etcdraft.IBlockMetadata} message BlockMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BlockMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {etcdraft.BlockMetadata} BlockMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.etcdraft.BlockMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.consenterIds && message.consenterIds.length))
                            message.consenterIds = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.consenterIds.push(reader.uint64());
                        } else
                            message.consenterIds.push(reader.uint64());
                        break;
                    case 2:
                        message.nextConsenterId = reader.uint64();
                        break;
                    case 3:
                        message.raftIndex = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BlockMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {etcdraft.BlockMetadata} BlockMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BlockMetadata message.
             * @function verify
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.consenterIds != null && message.hasOwnProperty("consenterIds")) {
                    if (!Array.isArray(message.consenterIds))
                        return "consenterIds: array expected";
                    for (var i = 0; i < message.consenterIds.length; ++i)
                        if (!$util.isInteger(message.consenterIds[i]) && !(message.consenterIds[i] && $util.isInteger(message.consenterIds[i].low) && $util.isInteger(message.consenterIds[i].high)))
                            return "consenterIds: integer|Long[] expected";
                }
                if (message.nextConsenterId != null && message.hasOwnProperty("nextConsenterId"))
                    if (!$util.isInteger(message.nextConsenterId) && !(message.nextConsenterId && $util.isInteger(message.nextConsenterId.low) && $util.isInteger(message.nextConsenterId.high)))
                        return "nextConsenterId: integer|Long expected";
                if (message.raftIndex != null && message.hasOwnProperty("raftIndex"))
                    if (!$util.isInteger(message.raftIndex) && !(message.raftIndex && $util.isInteger(message.raftIndex.low) && $util.isInteger(message.raftIndex.high)))
                        return "raftIndex: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a BlockMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {etcdraft.BlockMetadata} BlockMetadata
             */
            BlockMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.etcdraft.BlockMetadata)
                    return object;
                var message = new $root.etcdraft.BlockMetadata();
                if (object.consenterIds) {
                    if (!Array.isArray(object.consenterIds))
                        throw TypeError(".etcdraft.BlockMetadata.consenterIds: array expected");
                    message.consenterIds = [];
                    for (var i = 0; i < object.consenterIds.length; ++i)
                        if ($util.Long)
                            (message.consenterIds[i] = $util.Long.fromValue(object.consenterIds[i])).unsigned = true;
                        else if (typeof object.consenterIds[i] === "string")
                            message.consenterIds[i] = parseInt(object.consenterIds[i], 10);
                        else if (typeof object.consenterIds[i] === "number")
                            message.consenterIds[i] = object.consenterIds[i];
                        else if (typeof object.consenterIds[i] === "object")
                            message.consenterIds[i] = new $util.LongBits(object.consenterIds[i].low >>> 0, object.consenterIds[i].high >>> 0).toNumber(true);
                }
                if (object.nextConsenterId != null)
                    if ($util.Long)
                        (message.nextConsenterId = $util.Long.fromValue(object.nextConsenterId)).unsigned = true;
                    else if (typeof object.nextConsenterId === "string")
                        message.nextConsenterId = parseInt(object.nextConsenterId, 10);
                    else if (typeof object.nextConsenterId === "number")
                        message.nextConsenterId = object.nextConsenterId;
                    else if (typeof object.nextConsenterId === "object")
                        message.nextConsenterId = new $util.LongBits(object.nextConsenterId.low >>> 0, object.nextConsenterId.high >>> 0).toNumber(true);
                if (object.raftIndex != null)
                    if ($util.Long)
                        (message.raftIndex = $util.Long.fromValue(object.raftIndex)).unsigned = true;
                    else if (typeof object.raftIndex === "string")
                        message.raftIndex = parseInt(object.raftIndex, 10);
                    else if (typeof object.raftIndex === "number")
                        message.raftIndex = object.raftIndex;
                    else if (typeof object.raftIndex === "object")
                        message.raftIndex = new $util.LongBits(object.raftIndex.low >>> 0, object.raftIndex.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a BlockMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof etcdraft.BlockMetadata
             * @static
             * @param {etcdraft.BlockMetadata} message BlockMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.consenterIds = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.nextConsenterId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.nextConsenterId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.raftIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.raftIndex = options.longs === String ? "0" : 0;
                }
                if (message.consenterIds && message.consenterIds.length) {
                    object.consenterIds = [];
                    for (var j = 0; j < message.consenterIds.length; ++j)
                        if (typeof message.consenterIds[j] === "number")
                            object.consenterIds[j] = options.longs === String ? String(message.consenterIds[j]) : message.consenterIds[j];
                        else
                            object.consenterIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.consenterIds[j]) : options.longs === Number ? new $util.LongBits(message.consenterIds[j].low >>> 0, message.consenterIds[j].high >>> 0).toNumber(true) : message.consenterIds[j];
                }
                if (message.nextConsenterId != null && message.hasOwnProperty("nextConsenterId"))
                    if (typeof message.nextConsenterId === "number")
                        object.nextConsenterId = options.longs === String ? String(message.nextConsenterId) : message.nextConsenterId;
                    else
                        object.nextConsenterId = options.longs === String ? $util.Long.prototype.toString.call(message.nextConsenterId) : options.longs === Number ? new $util.LongBits(message.nextConsenterId.low >>> 0, message.nextConsenterId.high >>> 0).toNumber(true) : message.nextConsenterId;
                if (message.raftIndex != null && message.hasOwnProperty("raftIndex"))
                    if (typeof message.raftIndex === "number")
                        object.raftIndex = options.longs === String ? String(message.raftIndex) : message.raftIndex;
                    else
                        object.raftIndex = options.longs === String ? $util.Long.prototype.toString.call(message.raftIndex) : options.longs === Number ? new $util.LongBits(message.raftIndex.low >>> 0, message.raftIndex.high >>> 0).toNumber(true) : message.raftIndex;
                return object;
            };
    
            /**
             * Converts this BlockMetadata to JSON.
             * @function toJSON
             * @memberof etcdraft.BlockMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BlockMetadata;
        })();
    
        etcdraft.ClusterMetadata = (function() {
    
            /**
             * Properties of a ClusterMetadata.
             * @memberof etcdraft
             * @interface IClusterMetadata
             * @property {Array.<number|Long>|null} [activeNodes] ClusterMetadata activeNodes
             */
    
            /**
             * Constructs a new ClusterMetadata.
             * @memberof etcdraft
             * @classdesc Represents a ClusterMetadata.
             * @implements IClusterMetadata
             * @constructor
             * @param {etcdraft.IClusterMetadata=} [properties] Properties to set
             */
            function ClusterMetadata(properties) {
                this.activeNodes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ClusterMetadata activeNodes.
             * @member {Array.<number|Long>} activeNodes
             * @memberof etcdraft.ClusterMetadata
             * @instance
             */
            ClusterMetadata.prototype.activeNodes = $util.emptyArray;
    
            /**
             * Creates a new ClusterMetadata instance using the specified properties.
             * @function create
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {etcdraft.IClusterMetadata=} [properties] Properties to set
             * @returns {etcdraft.ClusterMetadata} ClusterMetadata instance
             */
            ClusterMetadata.create = function create(properties) {
                return new ClusterMetadata(properties);
            };
    
            /**
             * Encodes the specified ClusterMetadata message. Does not implicitly {@link etcdraft.ClusterMetadata.verify|verify} messages.
             * @function encode
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {etcdraft.IClusterMetadata} message ClusterMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClusterMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.activeNodes != null && message.activeNodes.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.activeNodes.length; ++i)
                        writer.uint64(message.activeNodes[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified ClusterMetadata message, length delimited. Does not implicitly {@link etcdraft.ClusterMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {etcdraft.IClusterMetadata} message ClusterMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClusterMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ClusterMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {etcdraft.ClusterMetadata} ClusterMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClusterMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.etcdraft.ClusterMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.activeNodes && message.activeNodes.length))
                            message.activeNodes = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.activeNodes.push(reader.uint64());
                        } else
                            message.activeNodes.push(reader.uint64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ClusterMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {etcdraft.ClusterMetadata} ClusterMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClusterMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ClusterMetadata message.
             * @function verify
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClusterMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.activeNodes != null && message.hasOwnProperty("activeNodes")) {
                    if (!Array.isArray(message.activeNodes))
                        return "activeNodes: array expected";
                    for (var i = 0; i < message.activeNodes.length; ++i)
                        if (!$util.isInteger(message.activeNodes[i]) && !(message.activeNodes[i] && $util.isInteger(message.activeNodes[i].low) && $util.isInteger(message.activeNodes[i].high)))
                            return "activeNodes: integer|Long[] expected";
                }
                return null;
            };
    
            /**
             * Creates a ClusterMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {etcdraft.ClusterMetadata} ClusterMetadata
             */
            ClusterMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.etcdraft.ClusterMetadata)
                    return object;
                var message = new $root.etcdraft.ClusterMetadata();
                if (object.activeNodes) {
                    if (!Array.isArray(object.activeNodes))
                        throw TypeError(".etcdraft.ClusterMetadata.activeNodes: array expected");
                    message.activeNodes = [];
                    for (var i = 0; i < object.activeNodes.length; ++i)
                        if ($util.Long)
                            (message.activeNodes[i] = $util.Long.fromValue(object.activeNodes[i])).unsigned = true;
                        else if (typeof object.activeNodes[i] === "string")
                            message.activeNodes[i] = parseInt(object.activeNodes[i], 10);
                        else if (typeof object.activeNodes[i] === "number")
                            message.activeNodes[i] = object.activeNodes[i];
                        else if (typeof object.activeNodes[i] === "object")
                            message.activeNodes[i] = new $util.LongBits(object.activeNodes[i].low >>> 0, object.activeNodes[i].high >>> 0).toNumber(true);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ClusterMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof etcdraft.ClusterMetadata
             * @static
             * @param {etcdraft.ClusterMetadata} message ClusterMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClusterMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.activeNodes = [];
                if (message.activeNodes && message.activeNodes.length) {
                    object.activeNodes = [];
                    for (var j = 0; j < message.activeNodes.length; ++j)
                        if (typeof message.activeNodes[j] === "number")
                            object.activeNodes[j] = options.longs === String ? String(message.activeNodes[j]) : message.activeNodes[j];
                        else
                            object.activeNodes[j] = options.longs === String ? $util.Long.prototype.toString.call(message.activeNodes[j]) : options.longs === Number ? new $util.LongBits(message.activeNodes[j].low >>> 0, message.activeNodes[j].high >>> 0).toNumber(true) : message.activeNodes[j];
                }
                return object;
            };
    
            /**
             * Converts this ClusterMetadata to JSON.
             * @function toJSON
             * @memberof etcdraft.ClusterMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClusterMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ClusterMetadata;
        })();
    
        etcdraft.ConfigMetadata = (function() {
    
            /**
             * Properties of a ConfigMetadata.
             * @memberof etcdraft
             * @interface IConfigMetadata
             * @property {Array.<etcdraft.IConsenter>|null} [consenters] ConfigMetadata consenters
             * @property {etcdraft.IOptions|null} [options] ConfigMetadata options
             */
    
            /**
             * Constructs a new ConfigMetadata.
             * @memberof etcdraft
             * @classdesc Represents a ConfigMetadata.
             * @implements IConfigMetadata
             * @constructor
             * @param {etcdraft.IConfigMetadata=} [properties] Properties to set
             */
            function ConfigMetadata(properties) {
                this.consenters = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConfigMetadata consenters.
             * @member {Array.<etcdraft.IConsenter>} consenters
             * @memberof etcdraft.ConfigMetadata
             * @instance
             */
            ConfigMetadata.prototype.consenters = $util.emptyArray;
    
            /**
             * ConfigMetadata options.
             * @member {etcdraft.IOptions|null|undefined} options
             * @memberof etcdraft.ConfigMetadata
             * @instance
             */
            ConfigMetadata.prototype.options = null;
    
            /**
             * Creates a new ConfigMetadata instance using the specified properties.
             * @function create
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {etcdraft.IConfigMetadata=} [properties] Properties to set
             * @returns {etcdraft.ConfigMetadata} ConfigMetadata instance
             */
            ConfigMetadata.create = function create(properties) {
                return new ConfigMetadata(properties);
            };
    
            /**
             * Encodes the specified ConfigMetadata message. Does not implicitly {@link etcdraft.ConfigMetadata.verify|verify} messages.
             * @function encode
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {etcdraft.IConfigMetadata} message ConfigMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.consenters != null && message.consenters.length)
                    for (var i = 0; i < message.consenters.length; ++i)
                        $root.etcdraft.Consenter.encode(message.consenters[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.etcdraft.Options.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified ConfigMetadata message, length delimited. Does not implicitly {@link etcdraft.ConfigMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {etcdraft.IConfigMetadata} message ConfigMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConfigMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {etcdraft.ConfigMetadata} ConfigMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.etcdraft.ConfigMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.consenters && message.consenters.length))
                            message.consenters = [];
                        message.consenters.push($root.etcdraft.Consenter.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.options = $root.etcdraft.Options.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConfigMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {etcdraft.ConfigMetadata} ConfigMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConfigMetadata message.
             * @function verify
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.consenters != null && message.hasOwnProperty("consenters")) {
                    if (!Array.isArray(message.consenters))
                        return "consenters: array expected";
                    for (var i = 0; i < message.consenters.length; ++i) {
                        var error = $root.etcdraft.Consenter.verify(message.consenters[i]);
                        if (error)
                            return "consenters." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.etcdraft.Options.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };
    
            /**
             * Creates a ConfigMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {etcdraft.ConfigMetadata} ConfigMetadata
             */
            ConfigMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.etcdraft.ConfigMetadata)
                    return object;
                var message = new $root.etcdraft.ConfigMetadata();
                if (object.consenters) {
                    if (!Array.isArray(object.consenters))
                        throw TypeError(".etcdraft.ConfigMetadata.consenters: array expected");
                    message.consenters = [];
                    for (var i = 0; i < object.consenters.length; ++i) {
                        if (typeof object.consenters[i] !== "object")
                            throw TypeError(".etcdraft.ConfigMetadata.consenters: object expected");
                        message.consenters[i] = $root.etcdraft.Consenter.fromObject(object.consenters[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".etcdraft.ConfigMetadata.options: object expected");
                    message.options = $root.etcdraft.Options.fromObject(object.options);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConfigMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof etcdraft.ConfigMetadata
             * @static
             * @param {etcdraft.ConfigMetadata} message ConfigMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.consenters = [];
                if (options.defaults)
                    object.options = null;
                if (message.consenters && message.consenters.length) {
                    object.consenters = [];
                    for (var j = 0; j < message.consenters.length; ++j)
                        object.consenters[j] = $root.etcdraft.Consenter.toObject(message.consenters[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.etcdraft.Options.toObject(message.options, options);
                return object;
            };
    
            /**
             * Converts this ConfigMetadata to JSON.
             * @function toJSON
             * @memberof etcdraft.ConfigMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConfigMetadata;
        })();
    
        etcdraft.Consenter = (function() {
    
            /**
             * Properties of a Consenter.
             * @memberof etcdraft
             * @interface IConsenter
             * @property {string|null} [host] Consenter host
             * @property {number|null} [port] Consenter port
             * @property {Uint8Array|null} [clientTlsCert] Consenter clientTlsCert
             * @property {Uint8Array|null} [serverTlsCert] Consenter serverTlsCert
             */
    
            /**
             * Constructs a new Consenter.
             * @memberof etcdraft
             * @classdesc Represents a Consenter.
             * @implements IConsenter
             * @constructor
             * @param {etcdraft.IConsenter=} [properties] Properties to set
             */
            function Consenter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Consenter host.
             * @member {string} host
             * @memberof etcdraft.Consenter
             * @instance
             */
            Consenter.prototype.host = "";
    
            /**
             * Consenter port.
             * @member {number} port
             * @memberof etcdraft.Consenter
             * @instance
             */
            Consenter.prototype.port = 0;
    
            /**
             * Consenter clientTlsCert.
             * @member {Uint8Array} clientTlsCert
             * @memberof etcdraft.Consenter
             * @instance
             */
            Consenter.prototype.clientTlsCert = $util.newBuffer([]);
    
            /**
             * Consenter serverTlsCert.
             * @member {Uint8Array} serverTlsCert
             * @memberof etcdraft.Consenter
             * @instance
             */
            Consenter.prototype.serverTlsCert = $util.newBuffer([]);
    
            /**
             * Creates a new Consenter instance using the specified properties.
             * @function create
             * @memberof etcdraft.Consenter
             * @static
             * @param {etcdraft.IConsenter=} [properties] Properties to set
             * @returns {etcdraft.Consenter} Consenter instance
             */
            Consenter.create = function create(properties) {
                return new Consenter(properties);
            };
    
            /**
             * Encodes the specified Consenter message. Does not implicitly {@link etcdraft.Consenter.verify|verify} messages.
             * @function encode
             * @memberof etcdraft.Consenter
             * @static
             * @param {etcdraft.IConsenter} message Consenter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Consenter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.host != null && message.hasOwnProperty("host"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
                if (message.port != null && message.hasOwnProperty("port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                if (message.clientTlsCert != null && message.hasOwnProperty("clientTlsCert"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.clientTlsCert);
                if (message.serverTlsCert != null && message.hasOwnProperty("serverTlsCert"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.serverTlsCert);
                return writer;
            };
    
            /**
             * Encodes the specified Consenter message, length delimited. Does not implicitly {@link etcdraft.Consenter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof etcdraft.Consenter
             * @static
             * @param {etcdraft.IConsenter} message Consenter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Consenter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Consenter message from the specified reader or buffer.
             * @function decode
             * @memberof etcdraft.Consenter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {etcdraft.Consenter} Consenter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Consenter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.etcdraft.Consenter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.host = reader.string();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    case 3:
                        message.clientTlsCert = reader.bytes();
                        break;
                    case 4:
                        message.serverTlsCert = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Consenter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof etcdraft.Consenter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {etcdraft.Consenter} Consenter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Consenter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Consenter message.
             * @function verify
             * @memberof etcdraft.Consenter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Consenter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.clientTlsCert != null && message.hasOwnProperty("clientTlsCert"))
                    if (!(message.clientTlsCert && typeof message.clientTlsCert.length === "number" || $util.isString(message.clientTlsCert)))
                        return "clientTlsCert: buffer expected";
                if (message.serverTlsCert != null && message.hasOwnProperty("serverTlsCert"))
                    if (!(message.serverTlsCert && typeof message.serverTlsCert.length === "number" || $util.isString(message.serverTlsCert)))
                        return "serverTlsCert: buffer expected";
                return null;
            };
    
            /**
             * Creates a Consenter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof etcdraft.Consenter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {etcdraft.Consenter} Consenter
             */
            Consenter.fromObject = function fromObject(object) {
                if (object instanceof $root.etcdraft.Consenter)
                    return object;
                var message = new $root.etcdraft.Consenter();
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.clientTlsCert != null)
                    if (typeof object.clientTlsCert === "string")
                        $util.base64.decode(object.clientTlsCert, message.clientTlsCert = $util.newBuffer($util.base64.length(object.clientTlsCert)), 0);
                    else if (object.clientTlsCert.length)
                        message.clientTlsCert = object.clientTlsCert;
                if (object.serverTlsCert != null)
                    if (typeof object.serverTlsCert === "string")
                        $util.base64.decode(object.serverTlsCert, message.serverTlsCert = $util.newBuffer($util.base64.length(object.serverTlsCert)), 0);
                    else if (object.serverTlsCert.length)
                        message.serverTlsCert = object.serverTlsCert;
                return message;
            };
    
            /**
             * Creates a plain object from a Consenter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof etcdraft.Consenter
             * @static
             * @param {etcdraft.Consenter} message Consenter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Consenter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.host = "";
                    object.port = 0;
                    if (options.bytes === String)
                        object.clientTlsCert = "";
                    else {
                        object.clientTlsCert = [];
                        if (options.bytes !== Array)
                            object.clientTlsCert = $util.newBuffer(object.clientTlsCert);
                    }
                    if (options.bytes === String)
                        object.serverTlsCert = "";
                    else {
                        object.serverTlsCert = [];
                        if (options.bytes !== Array)
                            object.serverTlsCert = $util.newBuffer(object.serverTlsCert);
                    }
                }
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.clientTlsCert != null && message.hasOwnProperty("clientTlsCert"))
                    object.clientTlsCert = options.bytes === String ? $util.base64.encode(message.clientTlsCert, 0, message.clientTlsCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.clientTlsCert) : message.clientTlsCert;
                if (message.serverTlsCert != null && message.hasOwnProperty("serverTlsCert"))
                    object.serverTlsCert = options.bytes === String ? $util.base64.encode(message.serverTlsCert, 0, message.serverTlsCert.length) : options.bytes === Array ? Array.prototype.slice.call(message.serverTlsCert) : message.serverTlsCert;
                return object;
            };
    
            /**
             * Converts this Consenter to JSON.
             * @function toJSON
             * @memberof etcdraft.Consenter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Consenter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Consenter;
        })();
    
        etcdraft.Options = (function() {
    
            /**
             * Properties of an Options.
             * @memberof etcdraft
             * @interface IOptions
             * @property {string|null} [tickInterval] Options tickInterval
             * @property {number|null} [electionTick] Options electionTick
             * @property {number|null} [heartbeatTick] Options heartbeatTick
             * @property {number|null} [maxInflightBlocks] Options maxInflightBlocks
             * @property {number|null} [snapshotIntervalSize] Options snapshotIntervalSize
             */
    
            /**
             * Constructs a new Options.
             * @memberof etcdraft
             * @classdesc Represents an Options.
             * @implements IOptions
             * @constructor
             * @param {etcdraft.IOptions=} [properties] Properties to set
             */
            function Options(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Options tickInterval.
             * @member {string} tickInterval
             * @memberof etcdraft.Options
             * @instance
             */
            Options.prototype.tickInterval = "";
    
            /**
             * Options electionTick.
             * @member {number} electionTick
             * @memberof etcdraft.Options
             * @instance
             */
            Options.prototype.electionTick = 0;
    
            /**
             * Options heartbeatTick.
             * @member {number} heartbeatTick
             * @memberof etcdraft.Options
             * @instance
             */
            Options.prototype.heartbeatTick = 0;
    
            /**
             * Options maxInflightBlocks.
             * @member {number} maxInflightBlocks
             * @memberof etcdraft.Options
             * @instance
             */
            Options.prototype.maxInflightBlocks = 0;
    
            /**
             * Options snapshotIntervalSize.
             * @member {number} snapshotIntervalSize
             * @memberof etcdraft.Options
             * @instance
             */
            Options.prototype.snapshotIntervalSize = 0;
    
            /**
             * Creates a new Options instance using the specified properties.
             * @function create
             * @memberof etcdraft.Options
             * @static
             * @param {etcdraft.IOptions=} [properties] Properties to set
             * @returns {etcdraft.Options} Options instance
             */
            Options.create = function create(properties) {
                return new Options(properties);
            };
    
            /**
             * Encodes the specified Options message. Does not implicitly {@link etcdraft.Options.verify|verify} messages.
             * @function encode
             * @memberof etcdraft.Options
             * @static
             * @param {etcdraft.IOptions} message Options message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Options.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tickInterval != null && message.hasOwnProperty("tickInterval"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tickInterval);
                if (message.electionTick != null && message.hasOwnProperty("electionTick"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.electionTick);
                if (message.heartbeatTick != null && message.hasOwnProperty("heartbeatTick"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.heartbeatTick);
                if (message.maxInflightBlocks != null && message.hasOwnProperty("maxInflightBlocks"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.maxInflightBlocks);
                if (message.snapshotIntervalSize != null && message.hasOwnProperty("snapshotIntervalSize"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.snapshotIntervalSize);
                return writer;
            };
    
            /**
             * Encodes the specified Options message, length delimited. Does not implicitly {@link etcdraft.Options.verify|verify} messages.
             * @function encodeDelimited
             * @memberof etcdraft.Options
             * @static
             * @param {etcdraft.IOptions} message Options message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Options.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Options message from the specified reader or buffer.
             * @function decode
             * @memberof etcdraft.Options
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {etcdraft.Options} Options
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Options.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.etcdraft.Options();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tickInterval = reader.string();
                        break;
                    case 2:
                        message.electionTick = reader.uint32();
                        break;
                    case 3:
                        message.heartbeatTick = reader.uint32();
                        break;
                    case 4:
                        message.maxInflightBlocks = reader.uint32();
                        break;
                    case 5:
                        message.snapshotIntervalSize = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Options message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof etcdraft.Options
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {etcdraft.Options} Options
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Options.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Options message.
             * @function verify
             * @memberof etcdraft.Options
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Options.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tickInterval != null && message.hasOwnProperty("tickInterval"))
                    if (!$util.isString(message.tickInterval))
                        return "tickInterval: string expected";
                if (message.electionTick != null && message.hasOwnProperty("electionTick"))
                    if (!$util.isInteger(message.electionTick))
                        return "electionTick: integer expected";
                if (message.heartbeatTick != null && message.hasOwnProperty("heartbeatTick"))
                    if (!$util.isInteger(message.heartbeatTick))
                        return "heartbeatTick: integer expected";
                if (message.maxInflightBlocks != null && message.hasOwnProperty("maxInflightBlocks"))
                    if (!$util.isInteger(message.maxInflightBlocks))
                        return "maxInflightBlocks: integer expected";
                if (message.snapshotIntervalSize != null && message.hasOwnProperty("snapshotIntervalSize"))
                    if (!$util.isInteger(message.snapshotIntervalSize))
                        return "snapshotIntervalSize: integer expected";
                return null;
            };
    
            /**
             * Creates an Options message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof etcdraft.Options
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {etcdraft.Options} Options
             */
            Options.fromObject = function fromObject(object) {
                if (object instanceof $root.etcdraft.Options)
                    return object;
                var message = new $root.etcdraft.Options();
                if (object.tickInterval != null)
                    message.tickInterval = String(object.tickInterval);
                if (object.electionTick != null)
                    message.electionTick = object.electionTick >>> 0;
                if (object.heartbeatTick != null)
                    message.heartbeatTick = object.heartbeatTick >>> 0;
                if (object.maxInflightBlocks != null)
                    message.maxInflightBlocks = object.maxInflightBlocks >>> 0;
                if (object.snapshotIntervalSize != null)
                    message.snapshotIntervalSize = object.snapshotIntervalSize >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from an Options message. Also converts values to other types if specified.
             * @function toObject
             * @memberof etcdraft.Options
             * @static
             * @param {etcdraft.Options} message Options
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Options.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tickInterval = "";
                    object.electionTick = 0;
                    object.heartbeatTick = 0;
                    object.maxInflightBlocks = 0;
                    object.snapshotIntervalSize = 0;
                }
                if (message.tickInterval != null && message.hasOwnProperty("tickInterval"))
                    object.tickInterval = message.tickInterval;
                if (message.electionTick != null && message.hasOwnProperty("electionTick"))
                    object.electionTick = message.electionTick;
                if (message.heartbeatTick != null && message.hasOwnProperty("heartbeatTick"))
                    object.heartbeatTick = message.heartbeatTick;
                if (message.maxInflightBlocks != null && message.hasOwnProperty("maxInflightBlocks"))
                    object.maxInflightBlocks = message.maxInflightBlocks;
                if (message.snapshotIntervalSize != null && message.hasOwnProperty("snapshotIntervalSize"))
                    object.snapshotIntervalSize = message.snapshotIntervalSize;
                return object;
            };
    
            /**
             * Converts this Options to JSON.
             * @function toJSON
             * @memberof etcdraft.Options
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Options.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Options;
        })();
    
        return etcdraft;
    })();
    
    $root.orderer = (function() {
    
        /**
         * Namespace orderer.
         * @exports orderer
         * @namespace
         */
        var orderer = {};
    
        orderer.Cluster = (function() {
    
            /**
             * Constructs a new Cluster service.
             * @memberof orderer
             * @classdesc Represents a Cluster
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Cluster(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (Cluster.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Cluster;
    
            /**
             * Creates new Cluster service using the specified rpc implementation.
             * @function create
             * @memberof orderer.Cluster
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Cluster} RPC service. Useful where requests and/or responses are streamed.
             */
            Cluster.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link orderer.Cluster#step}.
             * @memberof orderer.Cluster
             * @typedef StepCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {orderer.StepResponse} [response] StepResponse
             */
    
            /**
             * Calls Step.
             * @function step
             * @memberof orderer.Cluster
             * @instance
             * @param {orderer.IStepRequest} request StepRequest message or plain object
             * @param {orderer.Cluster.StepCallback} callback Node-style callback called with the error, if any, and StepResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Cluster.prototype.step = function step(request, callback) {
                return this.rpcCall(step, $root.orderer.StepRequest, $root.orderer.StepResponse, request, callback);
            }, "name", { value: "Step" });
    
            /**
             * Calls Step.
             * @function step
             * @memberof orderer.Cluster
             * @instance
             * @param {orderer.IStepRequest} request StepRequest message or plain object
             * @returns {Promise<orderer.StepResponse>} Promise
             * @variation 2
             */
    
            return Cluster;
        })();
    
        orderer.StepRequest = (function() {
    
            /**
             * Properties of a StepRequest.
             * @memberof orderer
             * @interface IStepRequest
             * @property {orderer.IConsensusRequest|null} [consensusRequest] StepRequest consensusRequest
             * @property {orderer.ISubmitRequest|null} [submitRequest] StepRequest submitRequest
             */
    
            /**
             * Constructs a new StepRequest.
             * @memberof orderer
             * @classdesc Represents a StepRequest.
             * @implements IStepRequest
             * @constructor
             * @param {orderer.IStepRequest=} [properties] Properties to set
             */
            function StepRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StepRequest consensusRequest.
             * @member {orderer.IConsensusRequest|null|undefined} consensusRequest
             * @memberof orderer.StepRequest
             * @instance
             */
            StepRequest.prototype.consensusRequest = null;
    
            /**
             * StepRequest submitRequest.
             * @member {orderer.ISubmitRequest|null|undefined} submitRequest
             * @memberof orderer.StepRequest
             * @instance
             */
            StepRequest.prototype.submitRequest = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * StepRequest payload.
             * @member {"consensusRequest"|"submitRequest"|undefined} payload
             * @memberof orderer.StepRequest
             * @instance
             */
            Object.defineProperty(StepRequest.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["consensusRequest", "submitRequest"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new StepRequest instance using the specified properties.
             * @function create
             * @memberof orderer.StepRequest
             * @static
             * @param {orderer.IStepRequest=} [properties] Properties to set
             * @returns {orderer.StepRequest} StepRequest instance
             */
            StepRequest.create = function create(properties) {
                return new StepRequest(properties);
            };
    
            /**
             * Encodes the specified StepRequest message. Does not implicitly {@link orderer.StepRequest.verify|verify} messages.
             * @function encode
             * @memberof orderer.StepRequest
             * @static
             * @param {orderer.IStepRequest} message StepRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.consensusRequest != null && message.hasOwnProperty("consensusRequest"))
                    $root.orderer.ConsensusRequest.encode(message.consensusRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.submitRequest != null && message.hasOwnProperty("submitRequest"))
                    $root.orderer.SubmitRequest.encode(message.submitRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StepRequest message, length delimited. Does not implicitly {@link orderer.StepRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.StepRequest
             * @static
             * @param {orderer.IStepRequest} message StepRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StepRequest message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.StepRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.StepRequest} StepRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.StepRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.consensusRequest = $root.orderer.ConsensusRequest.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.submitRequest = $root.orderer.SubmitRequest.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StepRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.StepRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.StepRequest} StepRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StepRequest message.
             * @function verify
             * @memberof orderer.StepRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.consensusRequest != null && message.hasOwnProperty("consensusRequest")) {
                    properties.payload = 1;
                    {
                        var error = $root.orderer.ConsensusRequest.verify(message.consensusRequest);
                        if (error)
                            return "consensusRequest." + error;
                    }
                }
                if (message.submitRequest != null && message.hasOwnProperty("submitRequest")) {
                    if (properties.payload === 1)
                        return "payload: multiple values";
                    properties.payload = 1;
                    {
                        var error = $root.orderer.SubmitRequest.verify(message.submitRequest);
                        if (error)
                            return "submitRequest." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a StepRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.StepRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.StepRequest} StepRequest
             */
            StepRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.StepRequest)
                    return object;
                var message = new $root.orderer.StepRequest();
                if (object.consensusRequest != null) {
                    if (typeof object.consensusRequest !== "object")
                        throw TypeError(".orderer.StepRequest.consensusRequest: object expected");
                    message.consensusRequest = $root.orderer.ConsensusRequest.fromObject(object.consensusRequest);
                }
                if (object.submitRequest != null) {
                    if (typeof object.submitRequest !== "object")
                        throw TypeError(".orderer.StepRequest.submitRequest: object expected");
                    message.submitRequest = $root.orderer.SubmitRequest.fromObject(object.submitRequest);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StepRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.StepRequest
             * @static
             * @param {orderer.StepRequest} message StepRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.consensusRequest != null && message.hasOwnProperty("consensusRequest")) {
                    object.consensusRequest = $root.orderer.ConsensusRequest.toObject(message.consensusRequest, options);
                    if (options.oneofs)
                        object.payload = "consensusRequest";
                }
                if (message.submitRequest != null && message.hasOwnProperty("submitRequest")) {
                    object.submitRequest = $root.orderer.SubmitRequest.toObject(message.submitRequest, options);
                    if (options.oneofs)
                        object.payload = "submitRequest";
                }
                return object;
            };
    
            /**
             * Converts this StepRequest to JSON.
             * @function toJSON
             * @memberof orderer.StepRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StepRequest;
        })();
    
        orderer.StepResponse = (function() {
    
            /**
             * Properties of a StepResponse.
             * @memberof orderer
             * @interface IStepResponse
             * @property {orderer.ISubmitResponse|null} [submitRes] StepResponse submitRes
             */
    
            /**
             * Constructs a new StepResponse.
             * @memberof orderer
             * @classdesc Represents a StepResponse.
             * @implements IStepResponse
             * @constructor
             * @param {orderer.IStepResponse=} [properties] Properties to set
             */
            function StepResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StepResponse submitRes.
             * @member {orderer.ISubmitResponse|null|undefined} submitRes
             * @memberof orderer.StepResponse
             * @instance
             */
            StepResponse.prototype.submitRes = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * StepResponse payload.
             * @member {"submitRes"|undefined} payload
             * @memberof orderer.StepResponse
             * @instance
             */
            Object.defineProperty(StepResponse.prototype, "payload", {
                get: $util.oneOfGetter($oneOfFields = ["submitRes"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new StepResponse instance using the specified properties.
             * @function create
             * @memberof orderer.StepResponse
             * @static
             * @param {orderer.IStepResponse=} [properties] Properties to set
             * @returns {orderer.StepResponse} StepResponse instance
             */
            StepResponse.create = function create(properties) {
                return new StepResponse(properties);
            };
    
            /**
             * Encodes the specified StepResponse message. Does not implicitly {@link orderer.StepResponse.verify|verify} messages.
             * @function encode
             * @memberof orderer.StepResponse
             * @static
             * @param {orderer.IStepResponse} message StepResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.submitRes != null && message.hasOwnProperty("submitRes"))
                    $root.orderer.SubmitResponse.encode(message.submitRes, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StepResponse message, length delimited. Does not implicitly {@link orderer.StepResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.StepResponse
             * @static
             * @param {orderer.IStepResponse} message StepResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StepResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StepResponse message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.StepResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.StepResponse} StepResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.StepResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.submitRes = $root.orderer.SubmitResponse.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StepResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.StepResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.StepResponse} StepResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StepResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StepResponse message.
             * @function verify
             * @memberof orderer.StepResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StepResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.submitRes != null && message.hasOwnProperty("submitRes")) {
                    properties.payload = 1;
                    {
                        var error = $root.orderer.SubmitResponse.verify(message.submitRes);
                        if (error)
                            return "submitRes." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a StepResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.StepResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.StepResponse} StepResponse
             */
            StepResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.StepResponse)
                    return object;
                var message = new $root.orderer.StepResponse();
                if (object.submitRes != null) {
                    if (typeof object.submitRes !== "object")
                        throw TypeError(".orderer.StepResponse.submitRes: object expected");
                    message.submitRes = $root.orderer.SubmitResponse.fromObject(object.submitRes);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StepResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.StepResponse
             * @static
             * @param {orderer.StepResponse} message StepResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StepResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.submitRes != null && message.hasOwnProperty("submitRes")) {
                    object.submitRes = $root.orderer.SubmitResponse.toObject(message.submitRes, options);
                    if (options.oneofs)
                        object.payload = "submitRes";
                }
                return object;
            };
    
            /**
             * Converts this StepResponse to JSON.
             * @function toJSON
             * @memberof orderer.StepResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StepResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StepResponse;
        })();
    
        orderer.ConsensusRequest = (function() {
    
            /**
             * Properties of a ConsensusRequest.
             * @memberof orderer
             * @interface IConsensusRequest
             * @property {string|null} [channel] ConsensusRequest channel
             * @property {Uint8Array|null} [payload] ConsensusRequest payload
             * @property {Uint8Array|null} [metadata] ConsensusRequest metadata
             */
    
            /**
             * Constructs a new ConsensusRequest.
             * @memberof orderer
             * @classdesc Represents a ConsensusRequest.
             * @implements IConsensusRequest
             * @constructor
             * @param {orderer.IConsensusRequest=} [properties] Properties to set
             */
            function ConsensusRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConsensusRequest channel.
             * @member {string} channel
             * @memberof orderer.ConsensusRequest
             * @instance
             */
            ConsensusRequest.prototype.channel = "";
    
            /**
             * ConsensusRequest payload.
             * @member {Uint8Array} payload
             * @memberof orderer.ConsensusRequest
             * @instance
             */
            ConsensusRequest.prototype.payload = $util.newBuffer([]);
    
            /**
             * ConsensusRequest metadata.
             * @member {Uint8Array} metadata
             * @memberof orderer.ConsensusRequest
             * @instance
             */
            ConsensusRequest.prototype.metadata = $util.newBuffer([]);
    
            /**
             * Creates a new ConsensusRequest instance using the specified properties.
             * @function create
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {orderer.IConsensusRequest=} [properties] Properties to set
             * @returns {orderer.ConsensusRequest} ConsensusRequest instance
             */
            ConsensusRequest.create = function create(properties) {
                return new ConsensusRequest(properties);
            };
    
            /**
             * Encodes the specified ConsensusRequest message. Does not implicitly {@link orderer.ConsensusRequest.verify|verify} messages.
             * @function encode
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {orderer.IConsensusRequest} message ConsensusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConsensusRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.metadata);
                return writer;
            };
    
            /**
             * Encodes the specified ConsensusRequest message, length delimited. Does not implicitly {@link orderer.ConsensusRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {orderer.IConsensusRequest} message ConsensusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConsensusRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConsensusRequest message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.ConsensusRequest} ConsensusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConsensusRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.ConsensusRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.payload = reader.bytes();
                        break;
                    case 3:
                        message.metadata = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConsensusRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.ConsensusRequest} ConsensusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConsensusRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConsensusRequest message.
             * @function verify
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConsensusRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                return null;
            };
    
            /**
             * Creates a ConsensusRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.ConsensusRequest} ConsensusRequest
             */
            ConsensusRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.ConsensusRequest)
                    return object;
                var message = new $root.orderer.ConsensusRequest();
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                return message;
            };
    
            /**
             * Creates a plain object from a ConsensusRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.ConsensusRequest
             * @static
             * @param {orderer.ConsensusRequest} message ConsensusRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConsensusRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = "";
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                return object;
            };
    
            /**
             * Converts this ConsensusRequest to JSON.
             * @function toJSON
             * @memberof orderer.ConsensusRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConsensusRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ConsensusRequest;
        })();
    
        orderer.SubmitRequest = (function() {
    
            /**
             * Properties of a SubmitRequest.
             * @memberof orderer
             * @interface ISubmitRequest
             * @property {string|null} [channel] SubmitRequest channel
             * @property {number|Long|null} [lastValidationSeq] SubmitRequest lastValidationSeq
             * @property {common.IEnvelope|null} [payload] SubmitRequest payload
             */
    
            /**
             * Constructs a new SubmitRequest.
             * @memberof orderer
             * @classdesc Represents a SubmitRequest.
             * @implements ISubmitRequest
             * @constructor
             * @param {orderer.ISubmitRequest=} [properties] Properties to set
             */
            function SubmitRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SubmitRequest channel.
             * @member {string} channel
             * @memberof orderer.SubmitRequest
             * @instance
             */
            SubmitRequest.prototype.channel = "";
    
            /**
             * SubmitRequest lastValidationSeq.
             * @member {number|Long} lastValidationSeq
             * @memberof orderer.SubmitRequest
             * @instance
             */
            SubmitRequest.prototype.lastValidationSeq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * SubmitRequest payload.
             * @member {common.IEnvelope|null|undefined} payload
             * @memberof orderer.SubmitRequest
             * @instance
             */
            SubmitRequest.prototype.payload = null;
    
            /**
             * Creates a new SubmitRequest instance using the specified properties.
             * @function create
             * @memberof orderer.SubmitRequest
             * @static
             * @param {orderer.ISubmitRequest=} [properties] Properties to set
             * @returns {orderer.SubmitRequest} SubmitRequest instance
             */
            SubmitRequest.create = function create(properties) {
                return new SubmitRequest(properties);
            };
    
            /**
             * Encodes the specified SubmitRequest message. Does not implicitly {@link orderer.SubmitRequest.verify|verify} messages.
             * @function encode
             * @memberof orderer.SubmitRequest
             * @static
             * @param {orderer.ISubmitRequest} message SubmitRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubmitRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.lastValidationSeq != null && message.hasOwnProperty("lastValidationSeq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.lastValidationSeq);
                if (message.payload != null && message.hasOwnProperty("payload"))
                    $root.common.Envelope.encode(message.payload, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SubmitRequest message, length delimited. Does not implicitly {@link orderer.SubmitRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SubmitRequest
             * @static
             * @param {orderer.ISubmitRequest} message SubmitRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubmitRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SubmitRequest message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SubmitRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SubmitRequest} SubmitRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubmitRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SubmitRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.lastValidationSeq = reader.uint64();
                        break;
                    case 3:
                        message.payload = $root.common.Envelope.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SubmitRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SubmitRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SubmitRequest} SubmitRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubmitRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SubmitRequest message.
             * @function verify
             * @memberof orderer.SubmitRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SubmitRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.lastValidationSeq != null && message.hasOwnProperty("lastValidationSeq"))
                    if (!$util.isInteger(message.lastValidationSeq) && !(message.lastValidationSeq && $util.isInteger(message.lastValidationSeq.low) && $util.isInteger(message.lastValidationSeq.high)))
                        return "lastValidationSeq: integer|Long expected";
                if (message.payload != null && message.hasOwnProperty("payload")) {
                    var error = $root.common.Envelope.verify(message.payload);
                    if (error)
                        return "payload." + error;
                }
                return null;
            };
    
            /**
             * Creates a SubmitRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SubmitRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SubmitRequest} SubmitRequest
             */
            SubmitRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SubmitRequest)
                    return object;
                var message = new $root.orderer.SubmitRequest();
                if (object.channel != null)
                    message.channel = String(object.channel);
                if (object.lastValidationSeq != null)
                    if ($util.Long)
                        (message.lastValidationSeq = $util.Long.fromValue(object.lastValidationSeq)).unsigned = true;
                    else if (typeof object.lastValidationSeq === "string")
                        message.lastValidationSeq = parseInt(object.lastValidationSeq, 10);
                    else if (typeof object.lastValidationSeq === "number")
                        message.lastValidationSeq = object.lastValidationSeq;
                    else if (typeof object.lastValidationSeq === "object")
                        message.lastValidationSeq = new $util.LongBits(object.lastValidationSeq.low >>> 0, object.lastValidationSeq.high >>> 0).toNumber(true);
                if (object.payload != null) {
                    if (typeof object.payload !== "object")
                        throw TypeError(".orderer.SubmitRequest.payload: object expected");
                    message.payload = $root.common.Envelope.fromObject(object.payload);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SubmitRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SubmitRequest
             * @static
             * @param {orderer.SubmitRequest} message SubmitRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SubmitRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.lastValidationSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastValidationSeq = options.longs === String ? "0" : 0;
                    object.payload = null;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.lastValidationSeq != null && message.hasOwnProperty("lastValidationSeq"))
                    if (typeof message.lastValidationSeq === "number")
                        object.lastValidationSeq = options.longs === String ? String(message.lastValidationSeq) : message.lastValidationSeq;
                    else
                        object.lastValidationSeq = options.longs === String ? $util.Long.prototype.toString.call(message.lastValidationSeq) : options.longs === Number ? new $util.LongBits(message.lastValidationSeq.low >>> 0, message.lastValidationSeq.high >>> 0).toNumber(true) : message.lastValidationSeq;
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = $root.common.Envelope.toObject(message.payload, options);
                return object;
            };
    
            /**
             * Converts this SubmitRequest to JSON.
             * @function toJSON
             * @memberof orderer.SubmitRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SubmitRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SubmitRequest;
        })();
    
        orderer.SubmitResponse = (function() {
    
            /**
             * Properties of a SubmitResponse.
             * @memberof orderer
             * @interface ISubmitResponse
             * @property {string|null} [channel] SubmitResponse channel
             * @property {common.Status|null} [status] SubmitResponse status
             * @property {string|null} [info] SubmitResponse info
             */
    
            /**
             * Constructs a new SubmitResponse.
             * @memberof orderer
             * @classdesc Represents a SubmitResponse.
             * @implements ISubmitResponse
             * @constructor
             * @param {orderer.ISubmitResponse=} [properties] Properties to set
             */
            function SubmitResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SubmitResponse channel.
             * @member {string} channel
             * @memberof orderer.SubmitResponse
             * @instance
             */
            SubmitResponse.prototype.channel = "";
    
            /**
             * SubmitResponse status.
             * @member {common.Status} status
             * @memberof orderer.SubmitResponse
             * @instance
             */
            SubmitResponse.prototype.status = 0;
    
            /**
             * SubmitResponse info.
             * @member {string} info
             * @memberof orderer.SubmitResponse
             * @instance
             */
            SubmitResponse.prototype.info = "";
    
            /**
             * Creates a new SubmitResponse instance using the specified properties.
             * @function create
             * @memberof orderer.SubmitResponse
             * @static
             * @param {orderer.ISubmitResponse=} [properties] Properties to set
             * @returns {orderer.SubmitResponse} SubmitResponse instance
             */
            SubmitResponse.create = function create(properties) {
                return new SubmitResponse(properties);
            };
    
            /**
             * Encodes the specified SubmitResponse message. Does not implicitly {@link orderer.SubmitResponse.verify|verify} messages.
             * @function encode
             * @memberof orderer.SubmitResponse
             * @static
             * @param {orderer.ISubmitResponse} message SubmitResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubmitResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                if (message.info != null && message.hasOwnProperty("info"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.info);
                return writer;
            };
    
            /**
             * Encodes the specified SubmitResponse message, length delimited. Does not implicitly {@link orderer.SubmitResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SubmitResponse
             * @static
             * @param {orderer.ISubmitResponse} message SubmitResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubmitResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SubmitResponse message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SubmitResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SubmitResponse} SubmitResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubmitResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SubmitResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.status = reader.int32();
                        break;
                    case 3:
                        message.info = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SubmitResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SubmitResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SubmitResponse} SubmitResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubmitResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SubmitResponse message.
             * @function verify
             * @memberof orderer.SubmitResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SubmitResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel"))
                    if (!$util.isString(message.channel))
                        return "channel: string expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 200:
                    case 400:
                    case 403:
                    case 404:
                    case 413:
                    case 500:
                    case 501:
                    case 503:
                        break;
                    }
                if (message.info != null && message.hasOwnProperty("info"))
                    if (!$util.isString(message.info))
                        return "info: string expected";
                return null;
            };
    
            /**
             * Creates a SubmitResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SubmitResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SubmitResponse} SubmitResponse
             */
            SubmitResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SubmitResponse)
                    return object;
                var message = new $root.orderer.SubmitResponse();
                if (object.channel != null)
                    message.channel = String(object.channel);
                switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 200:
                    message.status = 200;
                    break;
                case "BAD_REQUEST":
                case 400:
                    message.status = 400;
                    break;
                case "FORBIDDEN":
                case 403:
                    message.status = 403;
                    break;
                case "NOT_FOUND":
                case 404:
                    message.status = 404;
                    break;
                case "REQUEST_ENTITY_TOO_LARGE":
                case 413:
                    message.status = 413;
                    break;
                case "INTERNAL_SERVER_ERROR":
                case 500:
                    message.status = 500;
                    break;
                case "NOT_IMPLEMENTED":
                case 501:
                    message.status = 501;
                    break;
                case "SERVICE_UNAVAILABLE":
                case 503:
                    message.status = 503;
                    break;
                }
                if (object.info != null)
                    message.info = String(object.info);
                return message;
            };
    
            /**
             * Creates a plain object from a SubmitResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SubmitResponse
             * @static
             * @param {orderer.SubmitResponse} message SubmitResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SubmitResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.channel = "";
                    object.status = options.enums === String ? "UNKNOWN" : 0;
                    object.info = "";
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = message.channel;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.common.Status[message.status] : message.status;
                if (message.info != null && message.hasOwnProperty("info"))
                    object.info = message.info;
                return object;
            };
    
            /**
             * Converts this SubmitResponse to JSON.
             * @function toJSON
             * @memberof orderer.SubmitResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SubmitResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SubmitResponse;
        })();
    
        orderer.BroadcastResponse = (function() {
    
            /**
             * Properties of a BroadcastResponse.
             * @memberof orderer
             * @interface IBroadcastResponse
             * @property {common.Status|null} [status] BroadcastResponse status
             * @property {string|null} [info] BroadcastResponse info
             */
    
            /**
             * Constructs a new BroadcastResponse.
             * @memberof orderer
             * @classdesc Represents a BroadcastResponse.
             * @implements IBroadcastResponse
             * @constructor
             * @param {orderer.IBroadcastResponse=} [properties] Properties to set
             */
            function BroadcastResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BroadcastResponse status.
             * @member {common.Status} status
             * @memberof orderer.BroadcastResponse
             * @instance
             */
            BroadcastResponse.prototype.status = 0;
    
            /**
             * BroadcastResponse info.
             * @member {string} info
             * @memberof orderer.BroadcastResponse
             * @instance
             */
            BroadcastResponse.prototype.info = "";
    
            /**
             * Creates a new BroadcastResponse instance using the specified properties.
             * @function create
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {orderer.IBroadcastResponse=} [properties] Properties to set
             * @returns {orderer.BroadcastResponse} BroadcastResponse instance
             */
            BroadcastResponse.create = function create(properties) {
                return new BroadcastResponse(properties);
            };
    
            /**
             * Encodes the specified BroadcastResponse message. Does not implicitly {@link orderer.BroadcastResponse.verify|verify} messages.
             * @function encode
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {orderer.IBroadcastResponse} message BroadcastResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BroadcastResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.info != null && message.hasOwnProperty("info"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.info);
                return writer;
            };
    
            /**
             * Encodes the specified BroadcastResponse message, length delimited. Does not implicitly {@link orderer.BroadcastResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {orderer.IBroadcastResponse} message BroadcastResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BroadcastResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BroadcastResponse message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.BroadcastResponse} BroadcastResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BroadcastResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.BroadcastResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        message.info = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BroadcastResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.BroadcastResponse} BroadcastResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BroadcastResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BroadcastResponse message.
             * @function verify
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BroadcastResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 200:
                    case 400:
                    case 403:
                    case 404:
                    case 413:
                    case 500:
                    case 501:
                    case 503:
                        break;
                    }
                if (message.info != null && message.hasOwnProperty("info"))
                    if (!$util.isString(message.info))
                        return "info: string expected";
                return null;
            };
    
            /**
             * Creates a BroadcastResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.BroadcastResponse} BroadcastResponse
             */
            BroadcastResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.BroadcastResponse)
                    return object;
                var message = new $root.orderer.BroadcastResponse();
                switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 200:
                    message.status = 200;
                    break;
                case "BAD_REQUEST":
                case 400:
                    message.status = 400;
                    break;
                case "FORBIDDEN":
                case 403:
                    message.status = 403;
                    break;
                case "NOT_FOUND":
                case 404:
                    message.status = 404;
                    break;
                case "REQUEST_ENTITY_TOO_LARGE":
                case 413:
                    message.status = 413;
                    break;
                case "INTERNAL_SERVER_ERROR":
                case 500:
                    message.status = 500;
                    break;
                case "NOT_IMPLEMENTED":
                case 501:
                    message.status = 501;
                    break;
                case "SERVICE_UNAVAILABLE":
                case 503:
                    message.status = 503;
                    break;
                }
                if (object.info != null)
                    message.info = String(object.info);
                return message;
            };
    
            /**
             * Creates a plain object from a BroadcastResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.BroadcastResponse
             * @static
             * @param {orderer.BroadcastResponse} message BroadcastResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BroadcastResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.status = options.enums === String ? "UNKNOWN" : 0;
                    object.info = "";
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.common.Status[message.status] : message.status;
                if (message.info != null && message.hasOwnProperty("info"))
                    object.info = message.info;
                return object;
            };
    
            /**
             * Converts this BroadcastResponse to JSON.
             * @function toJSON
             * @memberof orderer.BroadcastResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BroadcastResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BroadcastResponse;
        })();
    
        orderer.SeekNewest = (function() {
    
            /**
             * Properties of a SeekNewest.
             * @memberof orderer
             * @interface ISeekNewest
             */
    
            /**
             * Constructs a new SeekNewest.
             * @memberof orderer
             * @classdesc Represents a SeekNewest.
             * @implements ISeekNewest
             * @constructor
             * @param {orderer.ISeekNewest=} [properties] Properties to set
             */
            function SeekNewest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new SeekNewest instance using the specified properties.
             * @function create
             * @memberof orderer.SeekNewest
             * @static
             * @param {orderer.ISeekNewest=} [properties] Properties to set
             * @returns {orderer.SeekNewest} SeekNewest instance
             */
            SeekNewest.create = function create(properties) {
                return new SeekNewest(properties);
            };
    
            /**
             * Encodes the specified SeekNewest message. Does not implicitly {@link orderer.SeekNewest.verify|verify} messages.
             * @function encode
             * @memberof orderer.SeekNewest
             * @static
             * @param {orderer.ISeekNewest} message SeekNewest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekNewest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified SeekNewest message, length delimited. Does not implicitly {@link orderer.SeekNewest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SeekNewest
             * @static
             * @param {orderer.ISeekNewest} message SeekNewest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekNewest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeekNewest message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SeekNewest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SeekNewest} SeekNewest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekNewest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SeekNewest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeekNewest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SeekNewest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SeekNewest} SeekNewest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekNewest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeekNewest message.
             * @function verify
             * @memberof orderer.SeekNewest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeekNewest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a SeekNewest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SeekNewest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SeekNewest} SeekNewest
             */
            SeekNewest.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SeekNewest)
                    return object;
                return new $root.orderer.SeekNewest();
            };
    
            /**
             * Creates a plain object from a SeekNewest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SeekNewest
             * @static
             * @param {orderer.SeekNewest} message SeekNewest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeekNewest.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this SeekNewest to JSON.
             * @function toJSON
             * @memberof orderer.SeekNewest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeekNewest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeekNewest;
        })();
    
        orderer.SeekOldest = (function() {
    
            /**
             * Properties of a SeekOldest.
             * @memberof orderer
             * @interface ISeekOldest
             */
    
            /**
             * Constructs a new SeekOldest.
             * @memberof orderer
             * @classdesc Represents a SeekOldest.
             * @implements ISeekOldest
             * @constructor
             * @param {orderer.ISeekOldest=} [properties] Properties to set
             */
            function SeekOldest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new SeekOldest instance using the specified properties.
             * @function create
             * @memberof orderer.SeekOldest
             * @static
             * @param {orderer.ISeekOldest=} [properties] Properties to set
             * @returns {orderer.SeekOldest} SeekOldest instance
             */
            SeekOldest.create = function create(properties) {
                return new SeekOldest(properties);
            };
    
            /**
             * Encodes the specified SeekOldest message. Does not implicitly {@link orderer.SeekOldest.verify|verify} messages.
             * @function encode
             * @memberof orderer.SeekOldest
             * @static
             * @param {orderer.ISeekOldest} message SeekOldest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekOldest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified SeekOldest message, length delimited. Does not implicitly {@link orderer.SeekOldest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SeekOldest
             * @static
             * @param {orderer.ISeekOldest} message SeekOldest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekOldest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeekOldest message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SeekOldest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SeekOldest} SeekOldest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekOldest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SeekOldest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeekOldest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SeekOldest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SeekOldest} SeekOldest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekOldest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeekOldest message.
             * @function verify
             * @memberof orderer.SeekOldest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeekOldest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates a SeekOldest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SeekOldest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SeekOldest} SeekOldest
             */
            SeekOldest.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SeekOldest)
                    return object;
                return new $root.orderer.SeekOldest();
            };
    
            /**
             * Creates a plain object from a SeekOldest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SeekOldest
             * @static
             * @param {orderer.SeekOldest} message SeekOldest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeekOldest.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this SeekOldest to JSON.
             * @function toJSON
             * @memberof orderer.SeekOldest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeekOldest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeekOldest;
        })();
    
        orderer.SeekSpecified = (function() {
    
            /**
             * Properties of a SeekSpecified.
             * @memberof orderer
             * @interface ISeekSpecified
             * @property {number|Long|null} [number] SeekSpecified number
             */
    
            /**
             * Constructs a new SeekSpecified.
             * @memberof orderer
             * @classdesc Represents a SeekSpecified.
             * @implements ISeekSpecified
             * @constructor
             * @param {orderer.ISeekSpecified=} [properties] Properties to set
             */
            function SeekSpecified(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeekSpecified number.
             * @member {number|Long} number
             * @memberof orderer.SeekSpecified
             * @instance
             */
            SeekSpecified.prototype.number = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new SeekSpecified instance using the specified properties.
             * @function create
             * @memberof orderer.SeekSpecified
             * @static
             * @param {orderer.ISeekSpecified=} [properties] Properties to set
             * @returns {orderer.SeekSpecified} SeekSpecified instance
             */
            SeekSpecified.create = function create(properties) {
                return new SeekSpecified(properties);
            };
    
            /**
             * Encodes the specified SeekSpecified message. Does not implicitly {@link orderer.SeekSpecified.verify|verify} messages.
             * @function encode
             * @memberof orderer.SeekSpecified
             * @static
             * @param {orderer.ISeekSpecified} message SeekSpecified message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekSpecified.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.number);
                return writer;
            };
    
            /**
             * Encodes the specified SeekSpecified message, length delimited. Does not implicitly {@link orderer.SeekSpecified.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SeekSpecified
             * @static
             * @param {orderer.ISeekSpecified} message SeekSpecified message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekSpecified.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeekSpecified message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SeekSpecified
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SeekSpecified} SeekSpecified
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekSpecified.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SeekSpecified();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.number = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeekSpecified message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SeekSpecified
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SeekSpecified} SeekSpecified
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekSpecified.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeekSpecified message.
             * @function verify
             * @memberof orderer.SeekSpecified
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeekSpecified.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a SeekSpecified message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SeekSpecified
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SeekSpecified} SeekSpecified
             */
            SeekSpecified.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SeekSpecified)
                    return object;
                var message = new $root.orderer.SeekSpecified();
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = true;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a SeekSpecified message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SeekSpecified
             * @static
             * @param {orderer.SeekSpecified} message SeekSpecified
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeekSpecified.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber(true) : message.number;
                return object;
            };
    
            /**
             * Converts this SeekSpecified to JSON.
             * @function toJSON
             * @memberof orderer.SeekSpecified
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeekSpecified.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeekSpecified;
        })();
    
        orderer.SeekPosition = (function() {
    
            /**
             * Properties of a SeekPosition.
             * @memberof orderer
             * @interface ISeekPosition
             * @property {orderer.ISeekNewest|null} [newest] SeekPosition newest
             * @property {orderer.ISeekOldest|null} [oldest] SeekPosition oldest
             * @property {orderer.ISeekSpecified|null} [specified] SeekPosition specified
             */
    
            /**
             * Constructs a new SeekPosition.
             * @memberof orderer
             * @classdesc Represents a SeekPosition.
             * @implements ISeekPosition
             * @constructor
             * @param {orderer.ISeekPosition=} [properties] Properties to set
             */
            function SeekPosition(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeekPosition newest.
             * @member {orderer.ISeekNewest|null|undefined} newest
             * @memberof orderer.SeekPosition
             * @instance
             */
            SeekPosition.prototype.newest = null;
    
            /**
             * SeekPosition oldest.
             * @member {orderer.ISeekOldest|null|undefined} oldest
             * @memberof orderer.SeekPosition
             * @instance
             */
            SeekPosition.prototype.oldest = null;
    
            /**
             * SeekPosition specified.
             * @member {orderer.ISeekSpecified|null|undefined} specified
             * @memberof orderer.SeekPosition
             * @instance
             */
            SeekPosition.prototype.specified = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * SeekPosition Type.
             * @member {"newest"|"oldest"|"specified"|undefined} Type
             * @memberof orderer.SeekPosition
             * @instance
             */
            Object.defineProperty(SeekPosition.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["newest", "oldest", "specified"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new SeekPosition instance using the specified properties.
             * @function create
             * @memberof orderer.SeekPosition
             * @static
             * @param {orderer.ISeekPosition=} [properties] Properties to set
             * @returns {orderer.SeekPosition} SeekPosition instance
             */
            SeekPosition.create = function create(properties) {
                return new SeekPosition(properties);
            };
    
            /**
             * Encodes the specified SeekPosition message. Does not implicitly {@link orderer.SeekPosition.verify|verify} messages.
             * @function encode
             * @memberof orderer.SeekPosition
             * @static
             * @param {orderer.ISeekPosition} message SeekPosition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekPosition.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.newest != null && message.hasOwnProperty("newest"))
                    $root.orderer.SeekNewest.encode(message.newest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.oldest != null && message.hasOwnProperty("oldest"))
                    $root.orderer.SeekOldest.encode(message.oldest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.specified != null && message.hasOwnProperty("specified"))
                    $root.orderer.SeekSpecified.encode(message.specified, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified SeekPosition message, length delimited. Does not implicitly {@link orderer.SeekPosition.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SeekPosition
             * @static
             * @param {orderer.ISeekPosition} message SeekPosition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekPosition.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeekPosition message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SeekPosition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SeekPosition} SeekPosition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekPosition.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SeekPosition();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.newest = $root.orderer.SeekNewest.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.oldest = $root.orderer.SeekOldest.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.specified = $root.orderer.SeekSpecified.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeekPosition message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SeekPosition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SeekPosition} SeekPosition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekPosition.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeekPosition message.
             * @function verify
             * @memberof orderer.SeekPosition
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeekPosition.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.newest != null && message.hasOwnProperty("newest")) {
                    properties.Type = 1;
                    {
                        var error = $root.orderer.SeekNewest.verify(message.newest);
                        if (error)
                            return "newest." + error;
                    }
                }
                if (message.oldest != null && message.hasOwnProperty("oldest")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.orderer.SeekOldest.verify(message.oldest);
                        if (error)
                            return "oldest." + error;
                    }
                }
                if (message.specified != null && message.hasOwnProperty("specified")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.orderer.SeekSpecified.verify(message.specified);
                        if (error)
                            return "specified." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a SeekPosition message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SeekPosition
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SeekPosition} SeekPosition
             */
            SeekPosition.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SeekPosition)
                    return object;
                var message = new $root.orderer.SeekPosition();
                if (object.newest != null) {
                    if (typeof object.newest !== "object")
                        throw TypeError(".orderer.SeekPosition.newest: object expected");
                    message.newest = $root.orderer.SeekNewest.fromObject(object.newest);
                }
                if (object.oldest != null) {
                    if (typeof object.oldest !== "object")
                        throw TypeError(".orderer.SeekPosition.oldest: object expected");
                    message.oldest = $root.orderer.SeekOldest.fromObject(object.oldest);
                }
                if (object.specified != null) {
                    if (typeof object.specified !== "object")
                        throw TypeError(".orderer.SeekPosition.specified: object expected");
                    message.specified = $root.orderer.SeekSpecified.fromObject(object.specified);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeekPosition message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SeekPosition
             * @static
             * @param {orderer.SeekPosition} message SeekPosition
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeekPosition.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.newest != null && message.hasOwnProperty("newest")) {
                    object.newest = $root.orderer.SeekNewest.toObject(message.newest, options);
                    if (options.oneofs)
                        object.Type = "newest";
                }
                if (message.oldest != null && message.hasOwnProperty("oldest")) {
                    object.oldest = $root.orderer.SeekOldest.toObject(message.oldest, options);
                    if (options.oneofs)
                        object.Type = "oldest";
                }
                if (message.specified != null && message.hasOwnProperty("specified")) {
                    object.specified = $root.orderer.SeekSpecified.toObject(message.specified, options);
                    if (options.oneofs)
                        object.Type = "specified";
                }
                return object;
            };
    
            /**
             * Converts this SeekPosition to JSON.
             * @function toJSON
             * @memberof orderer.SeekPosition
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeekPosition.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SeekPosition;
        })();
    
        orderer.SeekInfo = (function() {
    
            /**
             * Properties of a SeekInfo.
             * @memberof orderer
             * @interface ISeekInfo
             * @property {orderer.ISeekPosition|null} [start] SeekInfo start
             * @property {orderer.ISeekPosition|null} [stop] SeekInfo stop
             * @property {orderer.SeekInfo.SeekBehavior|null} [behavior] SeekInfo behavior
             * @property {orderer.SeekInfo.SeekErrorResponse|null} [errorResponse] SeekInfo errorResponse
             */
    
            /**
             * Constructs a new SeekInfo.
             * @memberof orderer
             * @classdesc Represents a SeekInfo.
             * @implements ISeekInfo
             * @constructor
             * @param {orderer.ISeekInfo=} [properties] Properties to set
             */
            function SeekInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SeekInfo start.
             * @member {orderer.ISeekPosition|null|undefined} start
             * @memberof orderer.SeekInfo
             * @instance
             */
            SeekInfo.prototype.start = null;
    
            /**
             * SeekInfo stop.
             * @member {orderer.ISeekPosition|null|undefined} stop
             * @memberof orderer.SeekInfo
             * @instance
             */
            SeekInfo.prototype.stop = null;
    
            /**
             * SeekInfo behavior.
             * @member {orderer.SeekInfo.SeekBehavior} behavior
             * @memberof orderer.SeekInfo
             * @instance
             */
            SeekInfo.prototype.behavior = 0;
    
            /**
             * SeekInfo errorResponse.
             * @member {orderer.SeekInfo.SeekErrorResponse} errorResponse
             * @memberof orderer.SeekInfo
             * @instance
             */
            SeekInfo.prototype.errorResponse = 0;
    
            /**
             * Creates a new SeekInfo instance using the specified properties.
             * @function create
             * @memberof orderer.SeekInfo
             * @static
             * @param {orderer.ISeekInfo=} [properties] Properties to set
             * @returns {orderer.SeekInfo} SeekInfo instance
             */
            SeekInfo.create = function create(properties) {
                return new SeekInfo(properties);
            };
    
            /**
             * Encodes the specified SeekInfo message. Does not implicitly {@link orderer.SeekInfo.verify|verify} messages.
             * @function encode
             * @memberof orderer.SeekInfo
             * @static
             * @param {orderer.ISeekInfo} message SeekInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start != null && message.hasOwnProperty("start"))
                    $root.orderer.SeekPosition.encode(message.start, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.stop != null && message.hasOwnProperty("stop"))
                    $root.orderer.SeekPosition.encode(message.stop, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.behavior != null && message.hasOwnProperty("behavior"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.behavior);
                if (message.errorResponse != null && message.hasOwnProperty("errorResponse"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.errorResponse);
                return writer;
            };
    
            /**
             * Encodes the specified SeekInfo message, length delimited. Does not implicitly {@link orderer.SeekInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.SeekInfo
             * @static
             * @param {orderer.ISeekInfo} message SeekInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SeekInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SeekInfo message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.SeekInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.SeekInfo} SeekInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.SeekInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.start = $root.orderer.SeekPosition.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.stop = $root.orderer.SeekPosition.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.behavior = reader.int32();
                        break;
                    case 4:
                        message.errorResponse = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a SeekInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.SeekInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.SeekInfo} SeekInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SeekInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SeekInfo message.
             * @function verify
             * @memberof orderer.SeekInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SeekInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.start != null && message.hasOwnProperty("start")) {
                    var error = $root.orderer.SeekPosition.verify(message.start);
                    if (error)
                        return "start." + error;
                }
                if (message.stop != null && message.hasOwnProperty("stop")) {
                    var error = $root.orderer.SeekPosition.verify(message.stop);
                    if (error)
                        return "stop." + error;
                }
                if (message.behavior != null && message.hasOwnProperty("behavior"))
                    switch (message.behavior) {
                    default:
                        return "behavior: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.errorResponse != null && message.hasOwnProperty("errorResponse"))
                    switch (message.errorResponse) {
                    default:
                        return "errorResponse: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a SeekInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.SeekInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.SeekInfo} SeekInfo
             */
            SeekInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.SeekInfo)
                    return object;
                var message = new $root.orderer.SeekInfo();
                if (object.start != null) {
                    if (typeof object.start !== "object")
                        throw TypeError(".orderer.SeekInfo.start: object expected");
                    message.start = $root.orderer.SeekPosition.fromObject(object.start);
                }
                if (object.stop != null) {
                    if (typeof object.stop !== "object")
                        throw TypeError(".orderer.SeekInfo.stop: object expected");
                    message.stop = $root.orderer.SeekPosition.fromObject(object.stop);
                }
                switch (object.behavior) {
                case "BLOCK_UNTIL_READY":
                case 0:
                    message.behavior = 0;
                    break;
                case "FAIL_IF_NOT_READY":
                case 1:
                    message.behavior = 1;
                    break;
                }
                switch (object.errorResponse) {
                case "STRICT":
                case 0:
                    message.errorResponse = 0;
                    break;
                case "BEST_EFFORT":
                case 1:
                    message.errorResponse = 1;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a SeekInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.SeekInfo
             * @static
             * @param {orderer.SeekInfo} message SeekInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SeekInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.start = null;
                    object.stop = null;
                    object.behavior = options.enums === String ? "BLOCK_UNTIL_READY" : 0;
                    object.errorResponse = options.enums === String ? "STRICT" : 0;
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = $root.orderer.SeekPosition.toObject(message.start, options);
                if (message.stop != null && message.hasOwnProperty("stop"))
                    object.stop = $root.orderer.SeekPosition.toObject(message.stop, options);
                if (message.behavior != null && message.hasOwnProperty("behavior"))
                    object.behavior = options.enums === String ? $root.orderer.SeekInfo.SeekBehavior[message.behavior] : message.behavior;
                if (message.errorResponse != null && message.hasOwnProperty("errorResponse"))
                    object.errorResponse = options.enums === String ? $root.orderer.SeekInfo.SeekErrorResponse[message.errorResponse] : message.errorResponse;
                return object;
            };
    
            /**
             * Converts this SeekInfo to JSON.
             * @function toJSON
             * @memberof orderer.SeekInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SeekInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * SeekBehavior enum.
             * @name orderer.SeekInfo.SeekBehavior
             * @enum {string}
             * @property {number} BLOCK_UNTIL_READY=0 BLOCK_UNTIL_READY value
             * @property {number} FAIL_IF_NOT_READY=1 FAIL_IF_NOT_READY value
             */
            SeekInfo.SeekBehavior = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "BLOCK_UNTIL_READY"] = 0;
                values[valuesById[1] = "FAIL_IF_NOT_READY"] = 1;
                return values;
            })();
    
            /**
             * SeekErrorResponse enum.
             * @name orderer.SeekInfo.SeekErrorResponse
             * @enum {string}
             * @property {number} STRICT=0 STRICT value
             * @property {number} BEST_EFFORT=1 BEST_EFFORT value
             */
            SeekInfo.SeekErrorResponse = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRICT"] = 0;
                values[valuesById[1] = "BEST_EFFORT"] = 1;
                return values;
            })();
    
            return SeekInfo;
        })();
    
        orderer.DeliverResponse = (function() {
    
            /**
             * Properties of a DeliverResponse.
             * @memberof orderer
             * @interface IDeliverResponse
             * @property {common.Status|null} [status] DeliverResponse status
             * @property {common.IBlock|null} [block] DeliverResponse block
             */
    
            /**
             * Constructs a new DeliverResponse.
             * @memberof orderer
             * @classdesc Represents a DeliverResponse.
             * @implements IDeliverResponse
             * @constructor
             * @param {orderer.IDeliverResponse=} [properties] Properties to set
             */
            function DeliverResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DeliverResponse status.
             * @member {common.Status} status
             * @memberof orderer.DeliverResponse
             * @instance
             */
            DeliverResponse.prototype.status = 0;
    
            /**
             * DeliverResponse block.
             * @member {common.IBlock|null|undefined} block
             * @memberof orderer.DeliverResponse
             * @instance
             */
            DeliverResponse.prototype.block = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * DeliverResponse Type.
             * @member {"status"|"block"|undefined} Type
             * @memberof orderer.DeliverResponse
             * @instance
             */
            Object.defineProperty(DeliverResponse.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["status", "block"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new DeliverResponse instance using the specified properties.
             * @function create
             * @memberof orderer.DeliverResponse
             * @static
             * @param {orderer.IDeliverResponse=} [properties] Properties to set
             * @returns {orderer.DeliverResponse} DeliverResponse instance
             */
            DeliverResponse.create = function create(properties) {
                return new DeliverResponse(properties);
            };
    
            /**
             * Encodes the specified DeliverResponse message. Does not implicitly {@link orderer.DeliverResponse.verify|verify} messages.
             * @function encode
             * @memberof orderer.DeliverResponse
             * @static
             * @param {orderer.IDeliverResponse} message DeliverResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeliverResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.block != null && message.hasOwnProperty("block"))
                    $root.common.Block.encode(message.block, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified DeliverResponse message, length delimited. Does not implicitly {@link orderer.DeliverResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.DeliverResponse
             * @static
             * @param {orderer.IDeliverResponse} message DeliverResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeliverResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a DeliverResponse message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.DeliverResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.DeliverResponse} DeliverResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeliverResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.DeliverResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        message.block = $root.common.Block.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a DeliverResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.DeliverResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.DeliverResponse} DeliverResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeliverResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a DeliverResponse message.
             * @function verify
             * @memberof orderer.DeliverResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeliverResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.status != null && message.hasOwnProperty("status")) {
                    properties.Type = 1;
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 200:
                    case 400:
                    case 403:
                    case 404:
                    case 413:
                    case 500:
                    case 501:
                    case 503:
                        break;
                    }
                }
                if (message.block != null && message.hasOwnProperty("block")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.common.Block.verify(message.block);
                        if (error)
                            return "block." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a DeliverResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.DeliverResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.DeliverResponse} DeliverResponse
             */
            DeliverResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.DeliverResponse)
                    return object;
                var message = new $root.orderer.DeliverResponse();
                switch (object.status) {
                case "UNKNOWN":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 200:
                    message.status = 200;
                    break;
                case "BAD_REQUEST":
                case 400:
                    message.status = 400;
                    break;
                case "FORBIDDEN":
                case 403:
                    message.status = 403;
                    break;
                case "NOT_FOUND":
                case 404:
                    message.status = 404;
                    break;
                case "REQUEST_ENTITY_TOO_LARGE":
                case 413:
                    message.status = 413;
                    break;
                case "INTERNAL_SERVER_ERROR":
                case 500:
                    message.status = 500;
                    break;
                case "NOT_IMPLEMENTED":
                case 501:
                    message.status = 501;
                    break;
                case "SERVICE_UNAVAILABLE":
                case 503:
                    message.status = 503;
                    break;
                }
                if (object.block != null) {
                    if (typeof object.block !== "object")
                        throw TypeError(".orderer.DeliverResponse.block: object expected");
                    message.block = $root.common.Block.fromObject(object.block);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a DeliverResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.DeliverResponse
             * @static
             * @param {orderer.DeliverResponse} message DeliverResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeliverResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.status != null && message.hasOwnProperty("status")) {
                    object.status = options.enums === String ? $root.common.Status[message.status] : message.status;
                    if (options.oneofs)
                        object.Type = "status";
                }
                if (message.block != null && message.hasOwnProperty("block")) {
                    object.block = $root.common.Block.toObject(message.block, options);
                    if (options.oneofs)
                        object.Type = "block";
                }
                return object;
            };
    
            /**
             * Converts this DeliverResponse to JSON.
             * @function toJSON
             * @memberof orderer.DeliverResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeliverResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return DeliverResponse;
        })();
    
        orderer.AtomicBroadcast = (function() {
    
            /**
             * Constructs a new AtomicBroadcast service.
             * @memberof orderer
             * @classdesc Represents an AtomicBroadcast
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function AtomicBroadcast(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }
    
            (AtomicBroadcast.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AtomicBroadcast;
    
            /**
             * Creates new AtomicBroadcast service using the specified rpc implementation.
             * @function create
             * @memberof orderer.AtomicBroadcast
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {AtomicBroadcast} RPC service. Useful where requests and/or responses are streamed.
             */
            AtomicBroadcast.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };
    
            /**
             * Callback as used by {@link orderer.AtomicBroadcast#broadcast}.
             * @memberof orderer.AtomicBroadcast
             * @typedef BroadcastCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {orderer.BroadcastResponse} [response] BroadcastResponse
             */
    
            /**
             * Calls Broadcast.
             * @function broadcast
             * @memberof orderer.AtomicBroadcast
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @param {orderer.AtomicBroadcast.BroadcastCallback} callback Node-style callback called with the error, if any, and BroadcastResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AtomicBroadcast.prototype.broadcast = function broadcast(request, callback) {
                return this.rpcCall(broadcast, $root.common.Envelope, $root.orderer.BroadcastResponse, request, callback);
            }, "name", { value: "Broadcast" });
    
            /**
             * Calls Broadcast.
             * @function broadcast
             * @memberof orderer.AtomicBroadcast
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @returns {Promise<orderer.BroadcastResponse>} Promise
             * @variation 2
             */
    
            /**
             * Callback as used by {@link orderer.AtomicBroadcast#deliver}.
             * @memberof orderer.AtomicBroadcast
             * @typedef DeliverCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {orderer.DeliverResponse} [response] DeliverResponse
             */
    
            /**
             * Calls Deliver.
             * @function deliver
             * @memberof orderer.AtomicBroadcast
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @param {orderer.AtomicBroadcast.DeliverCallback} callback Node-style callback called with the error, if any, and DeliverResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AtomicBroadcast.prototype.deliver = function deliver(request, callback) {
                return this.rpcCall(deliver, $root.common.Envelope, $root.orderer.DeliverResponse, request, callback);
            }, "name", { value: "Deliver" });
    
            /**
             * Calls Deliver.
             * @function deliver
             * @memberof orderer.AtomicBroadcast
             * @instance
             * @param {common.IEnvelope} request Envelope message or plain object
             * @returns {Promise<orderer.DeliverResponse>} Promise
             * @variation 2
             */
    
            return AtomicBroadcast;
        })();
    
        orderer.ConsensusType = (function() {
    
            /**
             * Properties of a ConsensusType.
             * @memberof orderer
             * @interface IConsensusType
             * @property {string|null} [type] ConsensusType type
             * @property {Uint8Array|null} [metadata] ConsensusType metadata
             * @property {orderer.ConsensusType.State|null} [state] ConsensusType state
             */
    
            /**
             * Constructs a new ConsensusType.
             * @memberof orderer
             * @classdesc Represents a ConsensusType.
             * @implements IConsensusType
             * @constructor
             * @param {orderer.IConsensusType=} [properties] Properties to set
             */
            function ConsensusType(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ConsensusType type.
             * @member {string} type
             * @memberof orderer.ConsensusType
             * @instance
             */
            ConsensusType.prototype.type = "";
    
            /**
             * ConsensusType metadata.
             * @member {Uint8Array} metadata
             * @memberof orderer.ConsensusType
             * @instance
             */
            ConsensusType.prototype.metadata = $util.newBuffer([]);
    
            /**
             * ConsensusType state.
             * @member {orderer.ConsensusType.State} state
             * @memberof orderer.ConsensusType
             * @instance
             */
            ConsensusType.prototype.state = 0;
    
            /**
             * Creates a new ConsensusType instance using the specified properties.
             * @function create
             * @memberof orderer.ConsensusType
             * @static
             * @param {orderer.IConsensusType=} [properties] Properties to set
             * @returns {orderer.ConsensusType} ConsensusType instance
             */
            ConsensusType.create = function create(properties) {
                return new ConsensusType(properties);
            };
    
            /**
             * Encodes the specified ConsensusType message. Does not implicitly {@link orderer.ConsensusType.verify|verify} messages.
             * @function encode
             * @memberof orderer.ConsensusType
             * @static
             * @param {orderer.IConsensusType} message ConsensusType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConsensusType.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.metadata);
                if (message.state != null && message.hasOwnProperty("state"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.state);
                return writer;
            };
    
            /**
             * Encodes the specified ConsensusType message, length delimited. Does not implicitly {@link orderer.ConsensusType.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.ConsensusType
             * @static
             * @param {orderer.IConsensusType} message ConsensusType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConsensusType.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ConsensusType message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.ConsensusType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.ConsensusType} ConsensusType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConsensusType.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.ConsensusType();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.string();
                        break;
                    case 2:
                        message.metadata = reader.bytes();
                        break;
                    case 3:
                        message.state = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ConsensusType message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.ConsensusType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.ConsensusType} ConsensusType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConsensusType.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ConsensusType message.
             * @function verify
             * @memberof orderer.ConsensusType
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConsensusType.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
                        return "metadata: buffer expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };
    
            /**
             * Creates a ConsensusType message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.ConsensusType
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.ConsensusType} ConsensusType
             */
            ConsensusType.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.ConsensusType)
                    return object;
                var message = new $root.orderer.ConsensusType();
                if (object.type != null)
                    message.type = String(object.type);
                if (object.metadata != null)
                    if (typeof object.metadata === "string")
                        $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
                    else if (object.metadata.length)
                        message.metadata = object.metadata;
                switch (object.state) {
                case "STATE_NORMAL":
                case 0:
                    message.state = 0;
                    break;
                case "STATE_MAINTENANCE":
                case 1:
                    message.state = 1;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a ConsensusType message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.ConsensusType
             * @static
             * @param {orderer.ConsensusType} message ConsensusType
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConsensusType.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = "";
                    if (options.bytes === String)
                        object.metadata = "";
                    else {
                        object.metadata = [];
                        if (options.bytes !== Array)
                            object.metadata = $util.newBuffer(object.metadata);
                    }
                    object.state = options.enums === String ? "STATE_NORMAL" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.orderer.ConsensusType.State[message.state] : message.state;
                return object;
            };
    
            /**
             * Converts this ConsensusType to JSON.
             * @function toJSON
             * @memberof orderer.ConsensusType
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConsensusType.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * State enum.
             * @name orderer.ConsensusType.State
             * @enum {string}
             * @property {number} STATE_NORMAL=0 STATE_NORMAL value
             * @property {number} STATE_MAINTENANCE=1 STATE_MAINTENANCE value
             */
            ConsensusType.State = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STATE_NORMAL"] = 0;
                values[valuesById[1] = "STATE_MAINTENANCE"] = 1;
                return values;
            })();
    
            return ConsensusType;
        })();
    
        orderer.BatchSize = (function() {
    
            /**
             * Properties of a BatchSize.
             * @memberof orderer
             * @interface IBatchSize
             * @property {number|null} [maxMessageCount] BatchSize maxMessageCount
             * @property {number|null} [absoluteMaxBytes] BatchSize absoluteMaxBytes
             * @property {number|null} [preferredMaxBytes] BatchSize preferredMaxBytes
             */
    
            /**
             * Constructs a new BatchSize.
             * @memberof orderer
             * @classdesc Represents a BatchSize.
             * @implements IBatchSize
             * @constructor
             * @param {orderer.IBatchSize=} [properties] Properties to set
             */
            function BatchSize(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BatchSize maxMessageCount.
             * @member {number} maxMessageCount
             * @memberof orderer.BatchSize
             * @instance
             */
            BatchSize.prototype.maxMessageCount = 0;
    
            /**
             * BatchSize absoluteMaxBytes.
             * @member {number} absoluteMaxBytes
             * @memberof orderer.BatchSize
             * @instance
             */
            BatchSize.prototype.absoluteMaxBytes = 0;
    
            /**
             * BatchSize preferredMaxBytes.
             * @member {number} preferredMaxBytes
             * @memberof orderer.BatchSize
             * @instance
             */
            BatchSize.prototype.preferredMaxBytes = 0;
    
            /**
             * Creates a new BatchSize instance using the specified properties.
             * @function create
             * @memberof orderer.BatchSize
             * @static
             * @param {orderer.IBatchSize=} [properties] Properties to set
             * @returns {orderer.BatchSize} BatchSize instance
             */
            BatchSize.create = function create(properties) {
                return new BatchSize(properties);
            };
    
            /**
             * Encodes the specified BatchSize message. Does not implicitly {@link orderer.BatchSize.verify|verify} messages.
             * @function encode
             * @memberof orderer.BatchSize
             * @static
             * @param {orderer.IBatchSize} message BatchSize message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchSize.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.maxMessageCount != null && message.hasOwnProperty("maxMessageCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.maxMessageCount);
                if (message.absoluteMaxBytes != null && message.hasOwnProperty("absoluteMaxBytes"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.absoluteMaxBytes);
                if (message.preferredMaxBytes != null && message.hasOwnProperty("preferredMaxBytes"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.preferredMaxBytes);
                return writer;
            };
    
            /**
             * Encodes the specified BatchSize message, length delimited. Does not implicitly {@link orderer.BatchSize.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.BatchSize
             * @static
             * @param {orderer.IBatchSize} message BatchSize message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchSize.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BatchSize message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.BatchSize
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.BatchSize} BatchSize
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchSize.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.BatchSize();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.maxMessageCount = reader.uint32();
                        break;
                    case 2:
                        message.absoluteMaxBytes = reader.uint32();
                        break;
                    case 3:
                        message.preferredMaxBytes = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BatchSize message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.BatchSize
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.BatchSize} BatchSize
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchSize.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BatchSize message.
             * @function verify
             * @memberof orderer.BatchSize
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchSize.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.maxMessageCount != null && message.hasOwnProperty("maxMessageCount"))
                    if (!$util.isInteger(message.maxMessageCount))
                        return "maxMessageCount: integer expected";
                if (message.absoluteMaxBytes != null && message.hasOwnProperty("absoluteMaxBytes"))
                    if (!$util.isInteger(message.absoluteMaxBytes))
                        return "absoluteMaxBytes: integer expected";
                if (message.preferredMaxBytes != null && message.hasOwnProperty("preferredMaxBytes"))
                    if (!$util.isInteger(message.preferredMaxBytes))
                        return "preferredMaxBytes: integer expected";
                return null;
            };
    
            /**
             * Creates a BatchSize message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.BatchSize
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.BatchSize} BatchSize
             */
            BatchSize.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.BatchSize)
                    return object;
                var message = new $root.orderer.BatchSize();
                if (object.maxMessageCount != null)
                    message.maxMessageCount = object.maxMessageCount >>> 0;
                if (object.absoluteMaxBytes != null)
                    message.absoluteMaxBytes = object.absoluteMaxBytes >>> 0;
                if (object.preferredMaxBytes != null)
                    message.preferredMaxBytes = object.preferredMaxBytes >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from a BatchSize message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.BatchSize
             * @static
             * @param {orderer.BatchSize} message BatchSize
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchSize.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.maxMessageCount = 0;
                    object.absoluteMaxBytes = 0;
                    object.preferredMaxBytes = 0;
                }
                if (message.maxMessageCount != null && message.hasOwnProperty("maxMessageCount"))
                    object.maxMessageCount = message.maxMessageCount;
                if (message.absoluteMaxBytes != null && message.hasOwnProperty("absoluteMaxBytes"))
                    object.absoluteMaxBytes = message.absoluteMaxBytes;
                if (message.preferredMaxBytes != null && message.hasOwnProperty("preferredMaxBytes"))
                    object.preferredMaxBytes = message.preferredMaxBytes;
                return object;
            };
    
            /**
             * Converts this BatchSize to JSON.
             * @function toJSON
             * @memberof orderer.BatchSize
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchSize.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BatchSize;
        })();
    
        orderer.BatchTimeout = (function() {
    
            /**
             * Properties of a BatchTimeout.
             * @memberof orderer
             * @interface IBatchTimeout
             * @property {string|null} [timeout] BatchTimeout timeout
             */
    
            /**
             * Constructs a new BatchTimeout.
             * @memberof orderer
             * @classdesc Represents a BatchTimeout.
             * @implements IBatchTimeout
             * @constructor
             * @param {orderer.IBatchTimeout=} [properties] Properties to set
             */
            function BatchTimeout(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BatchTimeout timeout.
             * @member {string} timeout
             * @memberof orderer.BatchTimeout
             * @instance
             */
            BatchTimeout.prototype.timeout = "";
    
            /**
             * Creates a new BatchTimeout instance using the specified properties.
             * @function create
             * @memberof orderer.BatchTimeout
             * @static
             * @param {orderer.IBatchTimeout=} [properties] Properties to set
             * @returns {orderer.BatchTimeout} BatchTimeout instance
             */
            BatchTimeout.create = function create(properties) {
                return new BatchTimeout(properties);
            };
    
            /**
             * Encodes the specified BatchTimeout message. Does not implicitly {@link orderer.BatchTimeout.verify|verify} messages.
             * @function encode
             * @memberof orderer.BatchTimeout
             * @static
             * @param {orderer.IBatchTimeout} message BatchTimeout message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchTimeout.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.timeout);
                return writer;
            };
    
            /**
             * Encodes the specified BatchTimeout message, length delimited. Does not implicitly {@link orderer.BatchTimeout.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.BatchTimeout
             * @static
             * @param {orderer.IBatchTimeout} message BatchTimeout message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BatchTimeout.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BatchTimeout message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.BatchTimeout
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.BatchTimeout} BatchTimeout
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchTimeout.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.BatchTimeout();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timeout = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BatchTimeout message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.BatchTimeout
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.BatchTimeout} BatchTimeout
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BatchTimeout.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BatchTimeout message.
             * @function verify
             * @memberof orderer.BatchTimeout
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BatchTimeout.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    if (!$util.isString(message.timeout))
                        return "timeout: string expected";
                return null;
            };
    
            /**
             * Creates a BatchTimeout message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.BatchTimeout
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.BatchTimeout} BatchTimeout
             */
            BatchTimeout.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.BatchTimeout)
                    return object;
                var message = new $root.orderer.BatchTimeout();
                if (object.timeout != null)
                    message.timeout = String(object.timeout);
                return message;
            };
    
            /**
             * Creates a plain object from a BatchTimeout message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.BatchTimeout
             * @static
             * @param {orderer.BatchTimeout} message BatchTimeout
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BatchTimeout.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.timeout = "";
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    object.timeout = message.timeout;
                return object;
            };
    
            /**
             * Converts this BatchTimeout to JSON.
             * @function toJSON
             * @memberof orderer.BatchTimeout
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BatchTimeout.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BatchTimeout;
        })();
    
        orderer.KafkaBrokers = (function() {
    
            /**
             * Properties of a KafkaBrokers.
             * @memberof orderer
             * @interface IKafkaBrokers
             * @property {Array.<string>|null} [brokers] KafkaBrokers brokers
             */
    
            /**
             * Constructs a new KafkaBrokers.
             * @memberof orderer
             * @classdesc Represents a KafkaBrokers.
             * @implements IKafkaBrokers
             * @constructor
             * @param {orderer.IKafkaBrokers=} [properties] Properties to set
             */
            function KafkaBrokers(properties) {
                this.brokers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KafkaBrokers brokers.
             * @member {Array.<string>} brokers
             * @memberof orderer.KafkaBrokers
             * @instance
             */
            KafkaBrokers.prototype.brokers = $util.emptyArray;
    
            /**
             * Creates a new KafkaBrokers instance using the specified properties.
             * @function create
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {orderer.IKafkaBrokers=} [properties] Properties to set
             * @returns {orderer.KafkaBrokers} KafkaBrokers instance
             */
            KafkaBrokers.create = function create(properties) {
                return new KafkaBrokers(properties);
            };
    
            /**
             * Encodes the specified KafkaBrokers message. Does not implicitly {@link orderer.KafkaBrokers.verify|verify} messages.
             * @function encode
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {orderer.IKafkaBrokers} message KafkaBrokers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaBrokers.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.brokers != null && message.brokers.length)
                    for (var i = 0; i < message.brokers.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.brokers[i]);
                return writer;
            };
    
            /**
             * Encodes the specified KafkaBrokers message, length delimited. Does not implicitly {@link orderer.KafkaBrokers.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {orderer.IKafkaBrokers} message KafkaBrokers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaBrokers.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KafkaBrokers message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.KafkaBrokers} KafkaBrokers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaBrokers.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.KafkaBrokers();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.brokers && message.brokers.length))
                            message.brokers = [];
                        message.brokers.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KafkaBrokers message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.KafkaBrokers} KafkaBrokers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaBrokers.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KafkaBrokers message.
             * @function verify
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaBrokers.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.brokers != null && message.hasOwnProperty("brokers")) {
                    if (!Array.isArray(message.brokers))
                        return "brokers: array expected";
                    for (var i = 0; i < message.brokers.length; ++i)
                        if (!$util.isString(message.brokers[i]))
                            return "brokers: string[] expected";
                }
                return null;
            };
    
            /**
             * Creates a KafkaBrokers message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.KafkaBrokers} KafkaBrokers
             */
            KafkaBrokers.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.KafkaBrokers)
                    return object;
                var message = new $root.orderer.KafkaBrokers();
                if (object.brokers) {
                    if (!Array.isArray(object.brokers))
                        throw TypeError(".orderer.KafkaBrokers.brokers: array expected");
                    message.brokers = [];
                    for (var i = 0; i < object.brokers.length; ++i)
                        message.brokers[i] = String(object.brokers[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KafkaBrokers message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.KafkaBrokers
             * @static
             * @param {orderer.KafkaBrokers} message KafkaBrokers
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaBrokers.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.brokers = [];
                if (message.brokers && message.brokers.length) {
                    object.brokers = [];
                    for (var j = 0; j < message.brokers.length; ++j)
                        object.brokers[j] = message.brokers[j];
                }
                return object;
            };
    
            /**
             * Converts this KafkaBrokers to JSON.
             * @function toJSON
             * @memberof orderer.KafkaBrokers
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaBrokers.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KafkaBrokers;
        })();
    
        orderer.ChannelRestrictions = (function() {
    
            /**
             * Properties of a ChannelRestrictions.
             * @memberof orderer
             * @interface IChannelRestrictions
             * @property {number|Long|null} [maxCount] ChannelRestrictions maxCount
             */
    
            /**
             * Constructs a new ChannelRestrictions.
             * @memberof orderer
             * @classdesc Represents a ChannelRestrictions.
             * @implements IChannelRestrictions
             * @constructor
             * @param {orderer.IChannelRestrictions=} [properties] Properties to set
             */
            function ChannelRestrictions(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChannelRestrictions maxCount.
             * @member {number|Long} maxCount
             * @memberof orderer.ChannelRestrictions
             * @instance
             */
            ChannelRestrictions.prototype.maxCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new ChannelRestrictions instance using the specified properties.
             * @function create
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {orderer.IChannelRestrictions=} [properties] Properties to set
             * @returns {orderer.ChannelRestrictions} ChannelRestrictions instance
             */
            ChannelRestrictions.create = function create(properties) {
                return new ChannelRestrictions(properties);
            };
    
            /**
             * Encodes the specified ChannelRestrictions message. Does not implicitly {@link orderer.ChannelRestrictions.verify|verify} messages.
             * @function encode
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {orderer.IChannelRestrictions} message ChannelRestrictions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelRestrictions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.maxCount != null && message.hasOwnProperty("maxCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.maxCount);
                return writer;
            };
    
            /**
             * Encodes the specified ChannelRestrictions message, length delimited. Does not implicitly {@link orderer.ChannelRestrictions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {orderer.IChannelRestrictions} message ChannelRestrictions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelRestrictions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ChannelRestrictions message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.ChannelRestrictions} ChannelRestrictions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelRestrictions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.ChannelRestrictions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.maxCount = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ChannelRestrictions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.ChannelRestrictions} ChannelRestrictions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelRestrictions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ChannelRestrictions message.
             * @function verify
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChannelRestrictions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.maxCount != null && message.hasOwnProperty("maxCount"))
                    if (!$util.isInteger(message.maxCount) && !(message.maxCount && $util.isInteger(message.maxCount.low) && $util.isInteger(message.maxCount.high)))
                        return "maxCount: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a ChannelRestrictions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.ChannelRestrictions} ChannelRestrictions
             */
            ChannelRestrictions.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.ChannelRestrictions)
                    return object;
                var message = new $root.orderer.ChannelRestrictions();
                if (object.maxCount != null)
                    if ($util.Long)
                        (message.maxCount = $util.Long.fromValue(object.maxCount)).unsigned = true;
                    else if (typeof object.maxCount === "string")
                        message.maxCount = parseInt(object.maxCount, 10);
                    else if (typeof object.maxCount === "number")
                        message.maxCount = object.maxCount;
                    else if (typeof object.maxCount === "object")
                        message.maxCount = new $util.LongBits(object.maxCount.low >>> 0, object.maxCount.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a ChannelRestrictions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.ChannelRestrictions
             * @static
             * @param {orderer.ChannelRestrictions} message ChannelRestrictions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChannelRestrictions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.maxCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxCount = options.longs === String ? "0" : 0;
                if (message.maxCount != null && message.hasOwnProperty("maxCount"))
                    if (typeof message.maxCount === "number")
                        object.maxCount = options.longs === String ? String(message.maxCount) : message.maxCount;
                    else
                        object.maxCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxCount) : options.longs === Number ? new $util.LongBits(message.maxCount.low >>> 0, message.maxCount.high >>> 0).toNumber(true) : message.maxCount;
                return object;
            };
    
            /**
             * Converts this ChannelRestrictions to JSON.
             * @function toJSON
             * @memberof orderer.ChannelRestrictions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChannelRestrictions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ChannelRestrictions;
        })();
    
        orderer.KafkaMessage = (function() {
    
            /**
             * Properties of a KafkaMessage.
             * @memberof orderer
             * @interface IKafkaMessage
             * @property {orderer.IKafkaMessageRegular|null} [regular] KafkaMessage regular
             * @property {orderer.IKafkaMessageTimeToCut|null} [timeToCut] KafkaMessage timeToCut
             * @property {orderer.IKafkaMessageConnect|null} [connect] KafkaMessage connect
             */
    
            /**
             * Constructs a new KafkaMessage.
             * @memberof orderer
             * @classdesc Represents a KafkaMessage.
             * @implements IKafkaMessage
             * @constructor
             * @param {orderer.IKafkaMessage=} [properties] Properties to set
             */
            function KafkaMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KafkaMessage regular.
             * @member {orderer.IKafkaMessageRegular|null|undefined} regular
             * @memberof orderer.KafkaMessage
             * @instance
             */
            KafkaMessage.prototype.regular = null;
    
            /**
             * KafkaMessage timeToCut.
             * @member {orderer.IKafkaMessageTimeToCut|null|undefined} timeToCut
             * @memberof orderer.KafkaMessage
             * @instance
             */
            KafkaMessage.prototype.timeToCut = null;
    
            /**
             * KafkaMessage connect.
             * @member {orderer.IKafkaMessageConnect|null|undefined} connect
             * @memberof orderer.KafkaMessage
             * @instance
             */
            KafkaMessage.prototype.connect = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * KafkaMessage Type.
             * @member {"regular"|"timeToCut"|"connect"|undefined} Type
             * @memberof orderer.KafkaMessage
             * @instance
             */
            Object.defineProperty(KafkaMessage.prototype, "Type", {
                get: $util.oneOfGetter($oneOfFields = ["regular", "timeToCut", "connect"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new KafkaMessage instance using the specified properties.
             * @function create
             * @memberof orderer.KafkaMessage
             * @static
             * @param {orderer.IKafkaMessage=} [properties] Properties to set
             * @returns {orderer.KafkaMessage} KafkaMessage instance
             */
            KafkaMessage.create = function create(properties) {
                return new KafkaMessage(properties);
            };
    
            /**
             * Encodes the specified KafkaMessage message. Does not implicitly {@link orderer.KafkaMessage.verify|verify} messages.
             * @function encode
             * @memberof orderer.KafkaMessage
             * @static
             * @param {orderer.IKafkaMessage} message KafkaMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.regular != null && message.hasOwnProperty("regular"))
                    $root.orderer.KafkaMessageRegular.encode(message.regular, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.timeToCut != null && message.hasOwnProperty("timeToCut"))
                    $root.orderer.KafkaMessageTimeToCut.encode(message.timeToCut, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.connect != null && message.hasOwnProperty("connect"))
                    $root.orderer.KafkaMessageConnect.encode(message.connect, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified KafkaMessage message, length delimited. Does not implicitly {@link orderer.KafkaMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.KafkaMessage
             * @static
             * @param {orderer.IKafkaMessage} message KafkaMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KafkaMessage message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.KafkaMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.KafkaMessage} KafkaMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.KafkaMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.regular = $root.orderer.KafkaMessageRegular.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.timeToCut = $root.orderer.KafkaMessageTimeToCut.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.connect = $root.orderer.KafkaMessageConnect.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KafkaMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.KafkaMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.KafkaMessage} KafkaMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KafkaMessage message.
             * @function verify
             * @memberof orderer.KafkaMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.regular != null && message.hasOwnProperty("regular")) {
                    properties.Type = 1;
                    {
                        var error = $root.orderer.KafkaMessageRegular.verify(message.regular);
                        if (error)
                            return "regular." + error;
                    }
                }
                if (message.timeToCut != null && message.hasOwnProperty("timeToCut")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.orderer.KafkaMessageTimeToCut.verify(message.timeToCut);
                        if (error)
                            return "timeToCut." + error;
                    }
                }
                if (message.connect != null && message.hasOwnProperty("connect")) {
                    if (properties.Type === 1)
                        return "Type: multiple values";
                    properties.Type = 1;
                    {
                        var error = $root.orderer.KafkaMessageConnect.verify(message.connect);
                        if (error)
                            return "connect." + error;
                    }
                }
                return null;
            };
    
            /**
             * Creates a KafkaMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.KafkaMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.KafkaMessage} KafkaMessage
             */
            KafkaMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.KafkaMessage)
                    return object;
                var message = new $root.orderer.KafkaMessage();
                if (object.regular != null) {
                    if (typeof object.regular !== "object")
                        throw TypeError(".orderer.KafkaMessage.regular: object expected");
                    message.regular = $root.orderer.KafkaMessageRegular.fromObject(object.regular);
                }
                if (object.timeToCut != null) {
                    if (typeof object.timeToCut !== "object")
                        throw TypeError(".orderer.KafkaMessage.timeToCut: object expected");
                    message.timeToCut = $root.orderer.KafkaMessageTimeToCut.fromObject(object.timeToCut);
                }
                if (object.connect != null) {
                    if (typeof object.connect !== "object")
                        throw TypeError(".orderer.KafkaMessage.connect: object expected");
                    message.connect = $root.orderer.KafkaMessageConnect.fromObject(object.connect);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a KafkaMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.KafkaMessage
             * @static
             * @param {orderer.KafkaMessage} message KafkaMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.regular != null && message.hasOwnProperty("regular")) {
                    object.regular = $root.orderer.KafkaMessageRegular.toObject(message.regular, options);
                    if (options.oneofs)
                        object.Type = "regular";
                }
                if (message.timeToCut != null && message.hasOwnProperty("timeToCut")) {
                    object.timeToCut = $root.orderer.KafkaMessageTimeToCut.toObject(message.timeToCut, options);
                    if (options.oneofs)
                        object.Type = "timeToCut";
                }
                if (message.connect != null && message.hasOwnProperty("connect")) {
                    object.connect = $root.orderer.KafkaMessageConnect.toObject(message.connect, options);
                    if (options.oneofs)
                        object.Type = "connect";
                }
                return object;
            };
    
            /**
             * Converts this KafkaMessage to JSON.
             * @function toJSON
             * @memberof orderer.KafkaMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KafkaMessage;
        })();
    
        orderer.KafkaMessageRegular = (function() {
    
            /**
             * Properties of a KafkaMessageRegular.
             * @memberof orderer
             * @interface IKafkaMessageRegular
             * @property {Uint8Array|null} [payload] KafkaMessageRegular payload
             * @property {number|Long|null} [configSeq] KafkaMessageRegular configSeq
             * @property {orderer.KafkaMessageRegular.Class|null} ["class"] KafkaMessageRegular class
             * @property {number|Long|null} [originalOffset] KafkaMessageRegular originalOffset
             */
    
            /**
             * Constructs a new KafkaMessageRegular.
             * @memberof orderer
             * @classdesc Represents a KafkaMessageRegular.
             * @implements IKafkaMessageRegular
             * @constructor
             * @param {orderer.IKafkaMessageRegular=} [properties] Properties to set
             */
            function KafkaMessageRegular(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KafkaMessageRegular payload.
             * @member {Uint8Array} payload
             * @memberof orderer.KafkaMessageRegular
             * @instance
             */
            KafkaMessageRegular.prototype.payload = $util.newBuffer([]);
    
            /**
             * KafkaMessageRegular configSeq.
             * @member {number|Long} configSeq
             * @memberof orderer.KafkaMessageRegular
             * @instance
             */
            KafkaMessageRegular.prototype.configSeq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * KafkaMessageRegular class.
             * @member {orderer.KafkaMessageRegular.Class} class
             * @memberof orderer.KafkaMessageRegular
             * @instance
             */
            KafkaMessageRegular.prototype["class"] = 0;
    
            /**
             * KafkaMessageRegular originalOffset.
             * @member {number|Long} originalOffset
             * @memberof orderer.KafkaMessageRegular
             * @instance
             */
            KafkaMessageRegular.prototype.originalOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new KafkaMessageRegular instance using the specified properties.
             * @function create
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {orderer.IKafkaMessageRegular=} [properties] Properties to set
             * @returns {orderer.KafkaMessageRegular} KafkaMessageRegular instance
             */
            KafkaMessageRegular.create = function create(properties) {
                return new KafkaMessageRegular(properties);
            };
    
            /**
             * Encodes the specified KafkaMessageRegular message. Does not implicitly {@link orderer.KafkaMessageRegular.verify|verify} messages.
             * @function encode
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {orderer.IKafkaMessageRegular} message KafkaMessageRegular message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessageRegular.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
                if (message.configSeq != null && message.hasOwnProperty("configSeq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.configSeq);
                if (message["class"] != null && message.hasOwnProperty("class"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message["class"]);
                if (message.originalOffset != null && message.hasOwnProperty("originalOffset"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.originalOffset);
                return writer;
            };
    
            /**
             * Encodes the specified KafkaMessageRegular message, length delimited. Does not implicitly {@link orderer.KafkaMessageRegular.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {orderer.IKafkaMessageRegular} message KafkaMessageRegular message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessageRegular.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KafkaMessageRegular message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.KafkaMessageRegular} KafkaMessageRegular
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessageRegular.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.KafkaMessageRegular();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = reader.bytes();
                        break;
                    case 2:
                        message.configSeq = reader.uint64();
                        break;
                    case 3:
                        message["class"] = reader.int32();
                        break;
                    case 4:
                        message.originalOffset = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KafkaMessageRegular message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.KafkaMessageRegular} KafkaMessageRegular
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessageRegular.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KafkaMessageRegular message.
             * @function verify
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaMessageRegular.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.configSeq != null && message.hasOwnProperty("configSeq"))
                    if (!$util.isInteger(message.configSeq) && !(message.configSeq && $util.isInteger(message.configSeq.low) && $util.isInteger(message.configSeq.high)))
                        return "configSeq: integer|Long expected";
                if (message["class"] != null && message.hasOwnProperty("class"))
                    switch (message["class"]) {
                    default:
                        return "class: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.originalOffset != null && message.hasOwnProperty("originalOffset"))
                    if (!$util.isInteger(message.originalOffset) && !(message.originalOffset && $util.isInteger(message.originalOffset.low) && $util.isInteger(message.originalOffset.high)))
                        return "originalOffset: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a KafkaMessageRegular message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.KafkaMessageRegular} KafkaMessageRegular
             */
            KafkaMessageRegular.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.KafkaMessageRegular)
                    return object;
                var message = new $root.orderer.KafkaMessageRegular();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.configSeq != null)
                    if ($util.Long)
                        (message.configSeq = $util.Long.fromValue(object.configSeq)).unsigned = true;
                    else if (typeof object.configSeq === "string")
                        message.configSeq = parseInt(object.configSeq, 10);
                    else if (typeof object.configSeq === "number")
                        message.configSeq = object.configSeq;
                    else if (typeof object.configSeq === "object")
                        message.configSeq = new $util.LongBits(object.configSeq.low >>> 0, object.configSeq.high >>> 0).toNumber(true);
                switch (object["class"]) {
                case "UNKNOWN":
                case 0:
                    message["class"] = 0;
                    break;
                case "NORMAL":
                case 1:
                    message["class"] = 1;
                    break;
                case "CONFIG":
                case 2:
                    message["class"] = 2;
                    break;
                }
                if (object.originalOffset != null)
                    if ($util.Long)
                        (message.originalOffset = $util.Long.fromValue(object.originalOffset)).unsigned = false;
                    else if (typeof object.originalOffset === "string")
                        message.originalOffset = parseInt(object.originalOffset, 10);
                    else if (typeof object.originalOffset === "number")
                        message.originalOffset = object.originalOffset;
                    else if (typeof object.originalOffset === "object")
                        message.originalOffset = new $util.LongBits(object.originalOffset.low >>> 0, object.originalOffset.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from a KafkaMessageRegular message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.KafkaMessageRegular
             * @static
             * @param {orderer.KafkaMessageRegular} message KafkaMessageRegular
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaMessageRegular.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.configSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.configSeq = options.longs === String ? "0" : 0;
                    object["class"] = options.enums === String ? "UNKNOWN" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.originalOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.originalOffset = options.longs === String ? "0" : 0;
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.configSeq != null && message.hasOwnProperty("configSeq"))
                    if (typeof message.configSeq === "number")
                        object.configSeq = options.longs === String ? String(message.configSeq) : message.configSeq;
                    else
                        object.configSeq = options.longs === String ? $util.Long.prototype.toString.call(message.configSeq) : options.longs === Number ? new $util.LongBits(message.configSeq.low >>> 0, message.configSeq.high >>> 0).toNumber(true) : message.configSeq;
                if (message["class"] != null && message.hasOwnProperty("class"))
                    object["class"] = options.enums === String ? $root.orderer.KafkaMessageRegular.Class[message["class"]] : message["class"];
                if (message.originalOffset != null && message.hasOwnProperty("originalOffset"))
                    if (typeof message.originalOffset === "number")
                        object.originalOffset = options.longs === String ? String(message.originalOffset) : message.originalOffset;
                    else
                        object.originalOffset = options.longs === String ? $util.Long.prototype.toString.call(message.originalOffset) : options.longs === Number ? new $util.LongBits(message.originalOffset.low >>> 0, message.originalOffset.high >>> 0).toNumber() : message.originalOffset;
                return object;
            };
    
            /**
             * Converts this KafkaMessageRegular to JSON.
             * @function toJSON
             * @memberof orderer.KafkaMessageRegular
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaMessageRegular.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Class enum.
             * @name orderer.KafkaMessageRegular.Class
             * @enum {string}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} NORMAL=1 NORMAL value
             * @property {number} CONFIG=2 CONFIG value
             */
            KafkaMessageRegular.Class = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "NORMAL"] = 1;
                values[valuesById[2] = "CONFIG"] = 2;
                return values;
            })();
    
            return KafkaMessageRegular;
        })();
    
        orderer.KafkaMessageTimeToCut = (function() {
    
            /**
             * Properties of a KafkaMessageTimeToCut.
             * @memberof orderer
             * @interface IKafkaMessageTimeToCut
             * @property {number|Long|null} [blockNumber] KafkaMessageTimeToCut blockNumber
             */
    
            /**
             * Constructs a new KafkaMessageTimeToCut.
             * @memberof orderer
             * @classdesc Represents a KafkaMessageTimeToCut.
             * @implements IKafkaMessageTimeToCut
             * @constructor
             * @param {orderer.IKafkaMessageTimeToCut=} [properties] Properties to set
             */
            function KafkaMessageTimeToCut(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KafkaMessageTimeToCut blockNumber.
             * @member {number|Long} blockNumber
             * @memberof orderer.KafkaMessageTimeToCut
             * @instance
             */
            KafkaMessageTimeToCut.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * Creates a new KafkaMessageTimeToCut instance using the specified properties.
             * @function create
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {orderer.IKafkaMessageTimeToCut=} [properties] Properties to set
             * @returns {orderer.KafkaMessageTimeToCut} KafkaMessageTimeToCut instance
             */
            KafkaMessageTimeToCut.create = function create(properties) {
                return new KafkaMessageTimeToCut(properties);
            };
    
            /**
             * Encodes the specified KafkaMessageTimeToCut message. Does not implicitly {@link orderer.KafkaMessageTimeToCut.verify|verify} messages.
             * @function encode
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {orderer.IKafkaMessageTimeToCut} message KafkaMessageTimeToCut message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessageTimeToCut.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.blockNumber);
                return writer;
            };
    
            /**
             * Encodes the specified KafkaMessageTimeToCut message, length delimited. Does not implicitly {@link orderer.KafkaMessageTimeToCut.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {orderer.IKafkaMessageTimeToCut} message KafkaMessageTimeToCut message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessageTimeToCut.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KafkaMessageTimeToCut message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.KafkaMessageTimeToCut} KafkaMessageTimeToCut
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessageTimeToCut.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.KafkaMessageTimeToCut();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.blockNumber = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KafkaMessageTimeToCut message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.KafkaMessageTimeToCut} KafkaMessageTimeToCut
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessageTimeToCut.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KafkaMessageTimeToCut message.
             * @function verify
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaMessageTimeToCut.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                    if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                        return "blockNumber: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a KafkaMessageTimeToCut message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.KafkaMessageTimeToCut} KafkaMessageTimeToCut
             */
            KafkaMessageTimeToCut.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.KafkaMessageTimeToCut)
                    return object;
                var message = new $root.orderer.KafkaMessageTimeToCut();
                if (object.blockNumber != null)
                    if ($util.Long)
                        (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = true;
                    else if (typeof object.blockNumber === "string")
                        message.blockNumber = parseInt(object.blockNumber, 10);
                    else if (typeof object.blockNumber === "number")
                        message.blockNumber = object.blockNumber;
                    else if (typeof object.blockNumber === "object")
                        message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber(true);
                return message;
            };
    
            /**
             * Creates a plain object from a KafkaMessageTimeToCut message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.KafkaMessageTimeToCut
             * @static
             * @param {orderer.KafkaMessageTimeToCut} message KafkaMessageTimeToCut
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaMessageTimeToCut.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.blockNumber = options.longs === String ? "0" : 0;
                if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                    if (typeof message.blockNumber === "number")
                        object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                    else
                        object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber(true) : message.blockNumber;
                return object;
            };
    
            /**
             * Converts this KafkaMessageTimeToCut to JSON.
             * @function toJSON
             * @memberof orderer.KafkaMessageTimeToCut
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaMessageTimeToCut.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KafkaMessageTimeToCut;
        })();
    
        orderer.KafkaMessageConnect = (function() {
    
            /**
             * Properties of a KafkaMessageConnect.
             * @memberof orderer
             * @interface IKafkaMessageConnect
             * @property {Uint8Array|null} [payload] KafkaMessageConnect payload
             */
    
            /**
             * Constructs a new KafkaMessageConnect.
             * @memberof orderer
             * @classdesc Represents a KafkaMessageConnect.
             * @implements IKafkaMessageConnect
             * @constructor
             * @param {orderer.IKafkaMessageConnect=} [properties] Properties to set
             */
            function KafkaMessageConnect(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KafkaMessageConnect payload.
             * @member {Uint8Array} payload
             * @memberof orderer.KafkaMessageConnect
             * @instance
             */
            KafkaMessageConnect.prototype.payload = $util.newBuffer([]);
    
            /**
             * Creates a new KafkaMessageConnect instance using the specified properties.
             * @function create
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {orderer.IKafkaMessageConnect=} [properties] Properties to set
             * @returns {orderer.KafkaMessageConnect} KafkaMessageConnect instance
             */
            KafkaMessageConnect.create = function create(properties) {
                return new KafkaMessageConnect(properties);
            };
    
            /**
             * Encodes the specified KafkaMessageConnect message. Does not implicitly {@link orderer.KafkaMessageConnect.verify|verify} messages.
             * @function encode
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {orderer.IKafkaMessageConnect} message KafkaMessageConnect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessageConnect.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && message.hasOwnProperty("payload"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
                return writer;
            };
    
            /**
             * Encodes the specified KafkaMessageConnect message, length delimited. Does not implicitly {@link orderer.KafkaMessageConnect.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {orderer.IKafkaMessageConnect} message KafkaMessageConnect message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMessageConnect.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KafkaMessageConnect message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.KafkaMessageConnect} KafkaMessageConnect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessageConnect.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.KafkaMessageConnect();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.payload = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KafkaMessageConnect message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.KafkaMessageConnect} KafkaMessageConnect
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMessageConnect.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KafkaMessageConnect message.
             * @function verify
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaMessageConnect.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                return null;
            };
    
            /**
             * Creates a KafkaMessageConnect message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.KafkaMessageConnect} KafkaMessageConnect
             */
            KafkaMessageConnect.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.KafkaMessageConnect)
                    return object;
                var message = new $root.orderer.KafkaMessageConnect();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                return message;
            };
    
            /**
             * Creates a plain object from a KafkaMessageConnect message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.KafkaMessageConnect
             * @static
             * @param {orderer.KafkaMessageConnect} message KafkaMessageConnect
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaMessageConnect.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                return object;
            };
    
            /**
             * Converts this KafkaMessageConnect to JSON.
             * @function toJSON
             * @memberof orderer.KafkaMessageConnect
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaMessageConnect.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KafkaMessageConnect;
        })();
    
        orderer.KafkaMetadata = (function() {
    
            /**
             * Properties of a KafkaMetadata.
             * @memberof orderer
             * @interface IKafkaMetadata
             * @property {number|Long|null} [lastOffsetPersisted] KafkaMetadata lastOffsetPersisted
             * @property {number|Long|null} [lastOriginalOffsetProcessed] KafkaMetadata lastOriginalOffsetProcessed
             * @property {number|Long|null} [lastResubmittedConfigOffset] KafkaMetadata lastResubmittedConfigOffset
             */
    
            /**
             * Constructs a new KafkaMetadata.
             * @memberof orderer
             * @classdesc Represents a KafkaMetadata.
             * @implements IKafkaMetadata
             * @constructor
             * @param {orderer.IKafkaMetadata=} [properties] Properties to set
             */
            function KafkaMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * KafkaMetadata lastOffsetPersisted.
             * @member {number|Long} lastOffsetPersisted
             * @memberof orderer.KafkaMetadata
             * @instance
             */
            KafkaMetadata.prototype.lastOffsetPersisted = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * KafkaMetadata lastOriginalOffsetProcessed.
             * @member {number|Long} lastOriginalOffsetProcessed
             * @memberof orderer.KafkaMetadata
             * @instance
             */
            KafkaMetadata.prototype.lastOriginalOffsetProcessed = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * KafkaMetadata lastResubmittedConfigOffset.
             * @member {number|Long} lastResubmittedConfigOffset
             * @memberof orderer.KafkaMetadata
             * @instance
             */
            KafkaMetadata.prototype.lastResubmittedConfigOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new KafkaMetadata instance using the specified properties.
             * @function create
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {orderer.IKafkaMetadata=} [properties] Properties to set
             * @returns {orderer.KafkaMetadata} KafkaMetadata instance
             */
            KafkaMetadata.create = function create(properties) {
                return new KafkaMetadata(properties);
            };
    
            /**
             * Encodes the specified KafkaMetadata message. Does not implicitly {@link orderer.KafkaMetadata.verify|verify} messages.
             * @function encode
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {orderer.IKafkaMetadata} message KafkaMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lastOffsetPersisted != null && message.hasOwnProperty("lastOffsetPersisted"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.lastOffsetPersisted);
                if (message.lastOriginalOffsetProcessed != null && message.hasOwnProperty("lastOriginalOffsetProcessed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.lastOriginalOffsetProcessed);
                if (message.lastResubmittedConfigOffset != null && message.hasOwnProperty("lastResubmittedConfigOffset"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.lastResubmittedConfigOffset);
                return writer;
            };
    
            /**
             * Encodes the specified KafkaMetadata message, length delimited. Does not implicitly {@link orderer.KafkaMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {orderer.IKafkaMetadata} message KafkaMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KafkaMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a KafkaMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {orderer.KafkaMetadata} KafkaMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orderer.KafkaMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lastOffsetPersisted = reader.int64();
                        break;
                    case 2:
                        message.lastOriginalOffsetProcessed = reader.int64();
                        break;
                    case 3:
                        message.lastResubmittedConfigOffset = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a KafkaMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {orderer.KafkaMetadata} KafkaMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KafkaMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a KafkaMetadata message.
             * @function verify
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KafkaMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lastOffsetPersisted != null && message.hasOwnProperty("lastOffsetPersisted"))
                    if (!$util.isInteger(message.lastOffsetPersisted) && !(message.lastOffsetPersisted && $util.isInteger(message.lastOffsetPersisted.low) && $util.isInteger(message.lastOffsetPersisted.high)))
                        return "lastOffsetPersisted: integer|Long expected";
                if (message.lastOriginalOffsetProcessed != null && message.hasOwnProperty("lastOriginalOffsetProcessed"))
                    if (!$util.isInteger(message.lastOriginalOffsetProcessed) && !(message.lastOriginalOffsetProcessed && $util.isInteger(message.lastOriginalOffsetProcessed.low) && $util.isInteger(message.lastOriginalOffsetProcessed.high)))
                        return "lastOriginalOffsetProcessed: integer|Long expected";
                if (message.lastResubmittedConfigOffset != null && message.hasOwnProperty("lastResubmittedConfigOffset"))
                    if (!$util.isInteger(message.lastResubmittedConfigOffset) && !(message.lastResubmittedConfigOffset && $util.isInteger(message.lastResubmittedConfigOffset.low) && $util.isInteger(message.lastResubmittedConfigOffset.high)))
                        return "lastResubmittedConfigOffset: integer|Long expected";
                return null;
            };
    
            /**
             * Creates a KafkaMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {orderer.KafkaMetadata} KafkaMetadata
             */
            KafkaMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.orderer.KafkaMetadata)
                    return object;
                var message = new $root.orderer.KafkaMetadata();
                if (object.lastOffsetPersisted != null)
                    if ($util.Long)
                        (message.lastOffsetPersisted = $util.Long.fromValue(object.lastOffsetPersisted)).unsigned = false;
                    else if (typeof object.lastOffsetPersisted === "string")
                        message.lastOffsetPersisted = parseInt(object.lastOffsetPersisted, 10);
                    else if (typeof object.lastOffsetPersisted === "number")
                        message.lastOffsetPersisted = object.lastOffsetPersisted;
                    else if (typeof object.lastOffsetPersisted === "object")
                        message.lastOffsetPersisted = new $util.LongBits(object.lastOffsetPersisted.low >>> 0, object.lastOffsetPersisted.high >>> 0).toNumber();
                if (object.lastOriginalOffsetProcessed != null)
                    if ($util.Long)
                        (message.lastOriginalOffsetProcessed = $util.Long.fromValue(object.lastOriginalOffsetProcessed)).unsigned = false;
                    else if (typeof object.lastOriginalOffsetProcessed === "string")
                        message.lastOriginalOffsetProcessed = parseInt(object.lastOriginalOffsetProcessed, 10);
                    else if (typeof object.lastOriginalOffsetProcessed === "number")
                        message.lastOriginalOffsetProcessed = object.lastOriginalOffsetProcessed;
                    else if (typeof object.lastOriginalOffsetProcessed === "object")
                        message.lastOriginalOffsetProcessed = new $util.LongBits(object.lastOriginalOffsetProcessed.low >>> 0, object.lastOriginalOffsetProcessed.high >>> 0).toNumber();
                if (object.lastResubmittedConfigOffset != null)
                    if ($util.Long)
                        (message.lastResubmittedConfigOffset = $util.Long.fromValue(object.lastResubmittedConfigOffset)).unsigned = false;
                    else if (typeof object.lastResubmittedConfigOffset === "string")
                        message.lastResubmittedConfigOffset = parseInt(object.lastResubmittedConfigOffset, 10);
                    else if (typeof object.lastResubmittedConfigOffset === "number")
                        message.lastResubmittedConfigOffset = object.lastResubmittedConfigOffset;
                    else if (typeof object.lastResubmittedConfigOffset === "object")
                        message.lastResubmittedConfigOffset = new $util.LongBits(object.lastResubmittedConfigOffset.low >>> 0, object.lastResubmittedConfigOffset.high >>> 0).toNumber();
                return message;
            };
    
            /**
             * Creates a plain object from a KafkaMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof orderer.KafkaMetadata
             * @static
             * @param {orderer.KafkaMetadata} message KafkaMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KafkaMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lastOffsetPersisted = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastOffsetPersisted = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lastOriginalOffsetProcessed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastOriginalOffsetProcessed = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lastResubmittedConfigOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastResubmittedConfigOffset = options.longs === String ? "0" : 0;
                }
                if (message.lastOffsetPersisted != null && message.hasOwnProperty("lastOffsetPersisted"))
                    if (typeof message.lastOffsetPersisted === "number")
                        object.lastOffsetPersisted = options.longs === String ? String(message.lastOffsetPersisted) : message.lastOffsetPersisted;
                    else
                        object.lastOffsetPersisted = options.longs === String ? $util.Long.prototype.toString.call(message.lastOffsetPersisted) : options.longs === Number ? new $util.LongBits(message.lastOffsetPersisted.low >>> 0, message.lastOffsetPersisted.high >>> 0).toNumber() : message.lastOffsetPersisted;
                if (message.lastOriginalOffsetProcessed != null && message.hasOwnProperty("lastOriginalOffsetProcessed"))
                    if (typeof message.lastOriginalOffsetProcessed === "number")
                        object.lastOriginalOffsetProcessed = options.longs === String ? String(message.lastOriginalOffsetProcessed) : message.lastOriginalOffsetProcessed;
                    else
                        object.lastOriginalOffsetProcessed = options.longs === String ? $util.Long.prototype.toString.call(message.lastOriginalOffsetProcessed) : options.longs === Number ? new $util.LongBits(message.lastOriginalOffsetProcessed.low >>> 0, message.lastOriginalOffsetProcessed.high >>> 0).toNumber() : message.lastOriginalOffsetProcessed;
                if (message.lastResubmittedConfigOffset != null && message.hasOwnProperty("lastResubmittedConfigOffset"))
                    if (typeof message.lastResubmittedConfigOffset === "number")
                        object.lastResubmittedConfigOffset = options.longs === String ? String(message.lastResubmittedConfigOffset) : message.lastResubmittedConfigOffset;
                    else
                        object.lastResubmittedConfigOffset = options.longs === String ? $util.Long.prototype.toString.call(message.lastResubmittedConfigOffset) : options.longs === Number ? new $util.LongBits(message.lastResubmittedConfigOffset.low >>> 0, message.lastResubmittedConfigOffset.high >>> 0).toNumber() : message.lastResubmittedConfigOffset;
                return object;
            };
    
            /**
             * Converts this KafkaMetadata to JSON.
             * @function toJSON
             * @memberof orderer.KafkaMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KafkaMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return KafkaMetadata;
        })();
    
        return orderer;
    })();

    return $root;
});
