<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Classes Classes Context Contract ChaincodeInterface ChaincodeProposalPayload ChaincodeStub ChannelHeader ClientIdentity CommonIterator ErrorResponse FunctionAndParameters Header HistoryQueryIterator PaginationQueryResponse PrivateQueryResponse Proposal ProposalCreator QueryResponseMetadata Response Shim SignatureHeader SignedProposal StateQueryIterator SuccessResponse exports × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"interfaces.list.html":{"id":"interfaces.list.html","title":"Interfaces","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Interfaces Classes Context Contract ChaincodeInterface ChaincodeProposalPayload ChaincodeStub ChannelHeader ClientIdentity CommonIterator ErrorResponse FunctionAndParameters Header HistoryQueryIterator PaginationQueryResponse PrivateQueryResponse Proposal ProposalCreator QueryResponseMetadata Response Shim SignatureHeader SignedProposal StateQueryIterator SuccessResponse exports × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Tutorials Classes Context Contract ChaincodeInterface ChaincodeProposalPayload ChaincodeStub ChannelHeader ClientIdentity CommonIterator ErrorResponse FunctionAndParameters Header HistoryQueryIterator PaginationQueryResponse PrivateQueryResponse Proposal ProposalCreator QueryResponseMetadata Response Shim SignatureHeader SignedProposal StateQueryIterator SuccessResponse exports × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Discord Chat Overview The fabric-contract-api provides the contract interface. a high level API for application developers to implement Smart Contracts. Within Hyperledger Fabric, Smart Contracts are also known as Chaincode. Working with this API provides a high level entry point to writing business logic. The fabric-shim provides the chaincode interface, a lower level API for implementing \"Smart Contracts\". It also provides the implementation to support communication with Hyperledger Fabric peers for Smart Contracts written using the fabric-contract-api together with the fabric-chaincode-node cli to launch Chaincode or Smart Contracts. To confirm that the fabric-shim maintains API and functional compatibility with previous versions of Hyperledger Fabric. A more detailed explanation on the concept and programming model can be found in the smart contract tutorial. Contract Interface Installation npm install --save fabric-contract-api Usage Implement a class that ends the contract class, a constructor is needed. The other functions will be invokable functions of your Smart Contract // updatevalues.js 'use strict'; // SDK Library to asset with writing the logic const { Contract } = require('fabric-contract-api'); // Business logic (well just util but still it's general purpose logic) const util = require('util'); /** * Support the Updating of values within the SmartContract */ class UpdateValuesContract extends Contract constructor(){ super('UpdateValuesContract'); } async transactionA(ctx, newValue) { // retrieve existing chaincode states let oldValue = await ctx.stub.getState(key); await ctx.stub.putState(key, Buffer.from(newValue)); return Buffer.from(newValue.toString()); } async transactionB(ctx) { // ..... } }; module.exports = UpdateValuesContract As with standard node modules make sure that this class is exported as follows. // index.js 'use strict'; const UpdateValues = require('./updatevalues') module.exports.contracts = ['UpdateValues']; Note: In order to make this contract runnable in version 1.4, also install the fabric-shim module as below, and ensure that the 'start' script in package.json refers to fabric-chaincode-node \"scripts\": { \"start\": \"fabric-chaincode-node start\" } Chaincode Interface Installation npm install --save fabric-shim Usage The chaincode interface contains two methods to be implemented: const shim = require('fabric-shim'); const Chaincode = class { async Init(stub) { // use the instantiate input arguments to decide initial chaincode state values // save the initial states await stub.putState(key, Buffer.from(aStringValue)); return shim.success(Buffer.from('Initialized Successfully!')); } async Invoke(stub) { // use the invoke input arguments to decide intended changes // retrieve existing chaincode states let oldValue = await stub.getState(key); // calculate new state values and saves them let newValue = oldValue + delta; await stub.putState(key, Buffer.from(newValue)); return shim.success(Buffer.from(newValue.toString())); } }; Start the chaincode process and listen for incoming endorsement requests: shim.start(new Chaincode()); Run chaincode as a external service To run chaincode as an external service, fabric-shim provides the shim.server API. If you are using contract APIs, you may want to use the server command provided by fabric-chaincode-node CLI to run a contract in the external service mode. To run a chaincode with the fabric-contract API as an external service, simply use fabric-chaincode-node server instead of fabric-chaincode-node start. Here is a sample for package.json: { \"scripts\": { \"start\": \"fabric-chaincode-node server\" }, ... } When fabric-chaincode-node server is used, the following options should be set as either arguments or environment variables: CORE_CHAINCODE_ID (--chaincode-id) CORE_CHAINCODE_ADDRESS (--chaincode-address) If TLS is enabled, the following additional options are required: CORE_CHAINCODE_TLS_CERT_FILE (--chaincode-tls-cert-file): path to a certificate CORE_CHAINCODE_TLS_KEY_FILE (--chaincode-tls-key-file): path to a private key When mutual TLS is enabled, CORE_CHAINCODE_TLS_CLIENT_CACERT_FILE (--chaincode-tls-client-cacert-file) option should be set to specify the path to the CA certificate for acceptable client certific There are other optional arguments can be set to pass gRPC options which will be used to override the default values. Here is a sample for package.json: { \"scripts\": { \"start\": \"fabric-chaincode-node server --chaincode-address=localhost:7100 --chaincode-id=&lt;ccid&gt; --grpc.max_send_message_length 100000000 --grpc.max_receive_message_length 100000000\" }, ... } This would increase the grpc limit from the default of 4MB to 100MB. This gRPC parameter override option has been added in node chaincode v2.5.4. The valid options are as listed below: --chaincode-address [string] [required] --chaincode-id [string] [required] --grpc.max_send_message_length [number] [default: -1] --grpc.max_receive_message_length [number] [default: -1] --grpc.keepalive_time_ms [number] [default: 110000] --grpc.http2.min_time_between_pings_ms [number] [default: 110000] --grpc.keepalive_timeout_ms [number] [default: 20000] --grpc.http2.max_pings_without_data [number] [default: 0] --grpc.keepalive_permit_without_calls [number] [default: 1] --chaincode-tls-cert-file [string] --chaincode-tls-cert-path [string] --chaincode-tls-key-file [string] --chaincode-tls-key-path [string] --chaincode-tls-client-cacert-file [string] --chaincode-tls-client-cacert-path [string] --module-path [string] Support Tested with node.js 8.9.0 (LTS). License This package is distributed under the Apache License, Version 2.0, see LICENSE.txt for more information. × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"ChaincodeServerOpts.html":{"id":"ChaincodeServerOpts.html","title":"Interface: ChaincodeServerOpts","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Interface: ChaincodeServerOpts ChaincodeServerOpts Properties: Name Type Argument Description ccid string Chaincode ID address string Listen address for the server tlsProps ChaincodeServerTLSProperties &lt;optional&gt; TLS properties if TLS is required. Extends GRPCOptions × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"ChaincodeServerTLSProperties.html":{"id":"ChaincodeServerTLSProperties.html","title":"Interface: ChaincodeServerTLSProperties","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Interface: ChaincodeServerTLSProperties ChaincodeServerTLSProperties Properties: Name Type Argument Description key Buffer Private key for TLS cert Buffer Certificate for TLS clientCACerts Buffer &lt;optional&gt; CA certificate for client certificates if mutual TLS is used. × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-contract-api.Context.html":{"id":"fabric-contract-api.Context.html","title":"Class: Context","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: Context Context The Context class provides the transactional context per a transactional execution. This can be subclassed to provided additional functional behaviour to support smart contract execution. An example would be to provide additional help to map application object ids to world state composite keys. In the constructor, do not reference the stub or clientidentity functions. new Context() Example class ScenarioContext extends Context{ constructor(){ super(); } generateKey(){ return this.stub.createCompositeKey('type',['keyvalue']); } } Methods setChaincodeStub(stub) This sets the chaincode stub object with api to use for worldstate access. MUST NOT BE CALLED FROM SMART CONTRACT CODE Parameters: Name Type Description stub ChaincodeStub chaincode stub instance setClientIdentity(clientIdentity) This sets the ClientIdentity object to use for information on the transaction invoking identity MUST NOT BE CALLED FROM SMART CONTRACT CODE Parameters: Name Type Description clientIdentity ClientIdentity chaincode stub instance × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-contract-api.Contract.html":{"id":"fabric-contract-api.Contract.html","title":"Class: Contract","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: Contract Contract The main Contact class that all code working within a Chaincode Container must be extending. Overriding of the `beforeTransaction`, `afterTransaction`, `aroundTransaction`, `unknownTransaction` and `createContext` are all optional Supplying a name within the constructor is also option and will default to '' new Contract(name) Constructor - supplying a name is recommended but is not mandatory. Parameters: Name Type Description name String name for the logic within this contract Methods &lt;static&gt; _isContract(obj) isContract provides functionality to check if a passed object is a contract type. Enables checking if its a contract for when contract-api is \"required\" by different modules Parameters: Name Type Description obj Object &lt;async&gt; afterTransaction(ctx, result) 'afterTransaction' will be called before any of the transaction functions within your contract Override this method to implement your own processing. Examples of what you may wish to code are Logging, Event Publishing If an error is thrown, the whole transaction will be rejected Parameters: Name Type Description ctx Context the transactional context result Object value that is returned from the transaction function &lt;async&gt; aroundTransaction(ctx, fn, paramters) 'aroundTransaction' wraps the call to the transaction function within your contract, allowing you to encapsulate it into a code block. Examples of what you could do overriding this include, but are not limited to: catching exceptions, logging, use a thread-store. When overriding this function, remember to call `super.aroundTransaction(ctx, fn, parameters)`! If you don't, the contract won't be able to run any transaction. If an error is thrown, the whole transaction will be rejected Parameters: Name Type Description ctx Context the transactional context fn function the contract function to invoke paramters any the parameters for the function to invoke &lt;async&gt; beforeTransaction(ctx) 'beforeTransaction' will be called before any of the transaction functions within your contract Override this method to implement your own processing. Examples of what you may wish to code are Logging, Event Publishing or Permissions checks If an error is thrown, the whole transaction will be rejected Parameters: Name Type Description ctx Context the transactional context createContext() 'createContext' is called before any after, before, unknown or user defined transaction function. This permits contracts to use their own subclass of context to add additinal processing. After this function returns, the chaincodeStub and client identity objects will be injected. No chaincode apis are available for calling directly within this function. Nor should the constructor of the subclasses context assume any other setup. Returns: a context implementation that must subclass context Type Context getName() Returns: returns the namespace Type String &lt;async&gt; unknownTransaction(ctx) 'unknownTransaction' will be called if the required transaction function requested does not exist Override this method to implement your own processing. If an error is thrown, the whole transaction will be rejected Parameters: Name Type Description ctx Context the transactional context × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.ChaincodeInterface.html":{"id":"fabric-shim.ChaincodeInterface.html","title":"Class: ChaincodeInterface","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: ChaincodeInterface ChaincodeInterface Chaincodes must implement the methods in this interface. The Init() method is called during chaincode instantiation or upgrade to preform any necessary intitialization of the application state. Invoke() is called by invoke transaction or query requests. Both methods are provided with a stub object that can be used to discover information on the request (invoking identity, target channel, arguments, etc.) as well as talking with the peer to retrieve or update application state. new ChaincodeInterface() Methods &lt;async&gt; Init(stub) Called during chaincode instantiate and upgrade. This method can be used to initialize asset states Parameters: Name Type Description stub ChaincodeStub The chaincode stub is implemented by the fabric-shim library and passed to the ChaincodeInterface calls by the Hyperledger Fabric platform. The stub encapsulates the APIs between the chaincode implementation and the Fabric peer &lt;async&gt; Invoke(stub) called throughout the life time of the chaincode to carry out business transaction logic and effect the asset states Parameters: Name Type Description stub ChaincodeStub The chaincode stub is implemented by the fabric-shim library and passed to the ChaincodeInterface calls by the Hyperledger Fabric platform. The stub encapsulates the APIs between the chaincode implementation and the Fabric peer × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.ChaincodeProposalPayload.html":{"id":"fabric-shim.ChaincodeProposalPayload.html","title":"Class: ChaincodeProposalPayload","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: ChaincodeProposalPayload ChaincodeProposalPayload new ChaincodeProposalPayload() Properties: Name Type Description input Buffer Input contains the arguments for this invocation. If this invocation deploys a new chaincode, ESCC/VSCC are part of this field. This is usually a marshaled ChaincodeInvocationSpec transientMap Map.&lt;string:Buffer&gt; TransientMap contains data (e.g. cryptographic material) that might be used to implement some form of application-level confidentiality. The contents of this field are supposed to always be omitted from the transaction and excluded from the ledger. × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.ChaincodeStub.html":{"id":"fabric-shim.ChaincodeStub.html","title":"Class: ChaincodeStub","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: ChaincodeStub ChaincodeStub The ChaincodeStub is implemented by the fabric-shim library and passed to the ChaincodeInterface calls by the Hyperledger Fabric platform. The stub encapsulates the APIs between the chaincode implementation and the Fabric peer new ChaincodeStub(client, channel_id, txId, chaincodeInput, signedProposalpb) Parameters: Name Type Description client Handler an instance of the Handler class channel_id string channel id txId string transaction id chaincodeInput any decoded message from peer signedProposalpb any the proposal protobuf Methods createCompositeKey(objectType, attributes) Creates a composite key by combining the objectType string and the given `attributes` to form a composite key. The objectType and attributes are expected to have only valid utf8 strings and should not contain U+0000 (nil byte) and U+10FFFF (biggest and unallocated code point). The resulting composite key can be used as the key in putState(). Hyperledger Fabric uses a simple key/value model for saving chaincode states. In some use case scenarios, it is necessary to keep track of multiple attributes. Furthermore, it may be necessary to make the various attributes searchable. Composite keys can be used to address these requirements. Similar to using composite keys in a relational database table, here you would treat the searchable attributes as key columns that make up the composite key. Values for the attributes become part of the key, thus they are searchable with functions like getStateByRange() and getStateByPartialCompositeKey(). Parameters: Name Type Description objectType string A string used as the prefix of the resulting key attributes Array.&lt;string&gt; List of attribute values to concatenate into the key Returns: A composite key with the objectType and the array of attributes joined together with special delimiters that will not be confused with values of the attributes Type string &lt;async&gt; deletePrivateData(collection, key) deletePrivateData records the specified `key` to be deleted in the private writeset of the transaction. Note that only hash of the private writeset goes into the transaction proposal response (which is sent to the client who issued the transaction) and the actual private writeset gets temporarily stored in a transient store. The `key` and its value will be deleted from the collection when the transaction is validated and successfully committed. Parameters: Name Type Description collection string The collection name key string Private data variable key to delete from the state store &lt;async&gt; deleteState(key) Deletes the state variable key from the state store. Parameters: Name Type Description key string State variable key to delete from the state store Returns: Promise will be resolved when the peer has successfully handled the state delete request or rejected if any errors Type Promise getArgs() Returns the arguments as array of strings from the chaincode invocation request. Equivalent to getStringArgs() Returns: Type Array.&lt;string&gt; getBinding() Returns a HEX-encoded string of SHA256 hash of the transaction's nonce, creator and epoch concatenated, as a unique representation of the specific transaction. This value can be used to prevent replay attacks in chaincodes that need to authenticate an identity independent of the transaction's submitter. In a chaincode proposal, the submitter will have been authenticated by the peer such that the identity returned by stub.getCreator() can be trusted. But in some scenarios, the chaincode needs to authenticate an identity independent of the proposal submitter. For example, Alice is the administrator who installs and instantiates a chaincode that manages assets. During instantiate Alice assigns the initial owner of the asset to Bob. The chaincode has a function called transfer() that moves the asset to another identity by changing the asset's \"owner\" property to the identity receiving the asset. Naturally only Bob, the current owner, is supposed to be able to call that function. While the chaincode can rely on stub.getCreator() to check the submitter's identity and compare that with the current owner, sometimes it's not always possible for the asset owner itself to submit the transaction. Let's suppose Bob hires a broker agency to handle his trades. The agency participates in the blockchain network and carry out trades on behalf of Bob. The chaincode must have a way to authenticate the transaction to ensure it has Bob's authorization to do the asset transfer. This can be achieved by asking Bob to sign the message, so that the chaincode can use Bob's certificate, which was obtained during the chaincode instantiate, to verify the signature and thus ensure the trade was authorized by Bob. Now, to prevent Bob's signature from being re-used in a malicious attack, we want to ensure the signature is unique. This is where the binding concept comes in. As explained above, the binding string uniquely represents the transaction where the trade proposal and Bob's authorization is submitted in. As long as Bob's signature is over the proposal payload and the binding string concatenated together, namely sigma=Sign(BobSigningKey, tx.Payload||tx.Binding), it's guaranteed to be unique and can not be re-used in a different transaction for exploitation. Returns: A HEX-encoded string of SHA256 hash of the transaction's nonce, creator and epoch concatenated Type string getChannelID() Returns the channel ID for the proposal for chaincode to process. This would be the 'channel_id' of the transaction proposal (see ChannelHeader in protos/common/common.proto) except where the chaincode is calling another on a different channel. getCreator() Returns the identity object of the chaincode invocation's submitter Returns: Type ProposalCreator getDateTimestamp() Returns the Date object of when the transaction was created. This is taken from the transaction ChannelHeader, therefore it will indicate the client's date, and will have the same value across all endorsers. getFunctionAndParameters() Returns an object containing the chaincode function name to invoke, and the array of arguments to pass to the target function Returns: Type FunctionAndParameters &lt;async&gt; getHistoryForKey(key) Returns a history of key values across time. For each historic key update, the historic value and associated transaction id and timestamp are returned. The timestamp is the timestamp provided by the client in the proposal header. This method requires peer configuration core.ledger.history.enableHistoryDatabase to be true. The query is NOT re-executed during validation phase, phantom reads are not detected. That is, other committed transactions may have updated the key concurrently, impacting the result set, and this would not be detected at validation/commit time. Applications susceptible to this should therefore not use GetHistoryForKey as part of transactions that update ledger, and should limit use to read-only chaincode operations. Parameters: Name Type Description key string The state variable key Returns: Promise for a HistoryQueryIterator object Type Promise getMspID() Returns the MSPID of the peer that started this chaincode Returns: MSPID Type string &lt;async&gt; getPrivateData(collection, key) getPrivateData returns the value of the specified `key` from the specified `collection`. Note that GetPrivateData doesn't read data from the private writeset, which has not been committed to the `collection`. In other words, GetPrivateData doesn't consider data modified by PutPrivateData that has not been committed. Parameters: Name Type Description collection string The collection name key string Private data variable key to retrieve from the state store Returns: Promise for the private value from the state store Type Promise.&lt;Array.&lt;byte&gt;&gt; getPrivateDataByPartialCompositeKey(collection, objectType, attributes) getPrivateDataByPartialCompositeKey queries the state in a given private collection based on a given partial composite key. This function returns an iterator which can be used to iterate over all composite keys whose prefix matches the given partial composite key. The `objectType` and attributes are expected to have only valid utf8 strings and should not contain U+0000 (nil byte) and U+10FFFF (biggest and unallocated code point). See related functions SplitCompositeKey and CreateCompositeKey. Call Close() on the returned StateQueryIteratorInterface object when done. The query is re-executed during validation phase to ensure result set has not changed since transaction endorsement (phantom reads detected). This function should be used only for a partial composite key. For a full composite key, an iter with empty response would be returned. Parameters: Name Type Description collection string The collection name objectType string A string used as the prefix of the resulting key attributes Array.&lt;string&gt; List of attribute values to concatenate into the partial composite key Returns: Promise for a PrivateQueryResponse object Type Promise getPrivateDataByRange(collection, startKey, endKey) getPrivateDataByRange returns a range iterator over a set of keys in a given private collection. The iterator can be used to iterate over all keys between the startKey (inclusive) and endKey (exclusive). The keys are returned by the iterator in lexical order. Note that startKey and endKey can be empty string, which implies unbounded range query on start or end. Call Close() on the returned StateQueryIteratorInterface object when done. The query is re-executed during validation phase to ensure result set has not changed since transaction endorsement (phantom reads detected). Parameters: Name Type Description collection string The collection name startKey string Private data variable key as the start of the key range (inclusive) endKey string Private data variable key as the end of the key range (exclusive) Returns: Promise for a PrivateQueryResponse object Type Promise &lt;async&gt; getPrivateDataHash(collection, key) getPrivateDataHash returns the hash of the value of the specified `key` from the specified `collection`. Parameters: Name Type Description collection string The collection name key string Private data variable key to retrieve a hash from the state store Returns: Promise for the private value hash from the state store Type Promise.&lt;Array.&lt;byte&gt;&gt; getPrivateDataQueryResult(collection, query) getPrivateDataQueryResult performs a \"rich\" query against a given private collection. It is only supported for state databases that support rich query, e.g.CouchDB. The query string is in the native syntax of the underlying state database. An iterator is returned which can be used to iterate (next) over the query result set. The query is NOT re-executed during validation phase, phantom reads are not detected. That is, other committed transactions may have added, updated, or removed keys that impact the result set, and this would not be detected at validation/commit time. Applications susceptible to this should therefore not use GetQueryResult as part of transactions that update ledger, and should limit use to read-only chaincode operations. Parameters: Name Type Description collection string The collection name query string The query to be performed Returns: Promise for a PrivateQueryResponse object Type Promise &lt;async&gt; getPrivateDataValidationParameter(collection, key) GetPrivateDataValidationParameter retrieves the key-level endorsement policy for the private data specified by `key`. Note that this introduces a read dependency on `key` in the transaction's readset. Parameters: Name Type Description collection string The collection name for this private data key string Private data variable key by which to retrieve endorsement policy Returns: endorsement policy for this key Type Buffer &lt;async&gt; getQueryResult(query) Performs a \"rich\" query against a state database. It is only supported for state databases that support rich query, e.g. CouchDB. The query string is in the native syntax of the underlying state database. An StateQueryIterator is returned which can be used to iterate over all keys in the query result set. However, if the number of keys in the query result set is greater than the totalQueryLimit (defined in core.yaml), this iterator cannot be used to fetch all keys in the query result set (results will be limited by the totalQueryLimit). The query is NOT re-executed during validation phase, phantom reads are not detected. That is, other committed transactions may have added, updated, or removed keys that impact the result set, and this would not be detected at validation/commit time. Applications susceptible to this should therefore not use GetQueryResult as part of transactions that update ledger, and should limit use to read-only chaincode operations. Parameters: Name Type Description query string Query string native to the underlying state database Returns: Promise for a StateQueryIterator object Type Promise getQueryResultWithPagination(query, pageSize, bookmark) getQueryResultWithPagination performs a \"rich\" query against a state database. It is only supported for state databases that support rich query, e.g., CouchDB. The query string is in the native syntax of the underlying state database. An iterator is returned which can be used to iterate over keys in the query result set. When an empty string is passed as a value to the bookmark argument, the returned iterator can be used to fetch the first `pageSize` of query results. When the bookmark is a non-emptry string, the iterator can be used to fetch the first `pageSize` keys between the bookmark and the last key in the query result. Note that only the bookmark present in a prior page of query results (ResponseMetadata) can be used as a value to the bookmark argument. Otherwise, an empty string must be passed as bookmark. This call is only supported in a read only transaction. Parameters: Name Type Description query string pageSize int bookmark string Returns: Promise for a PaginationQueryResponse object Type Promise getSignedProposal() Returns a fully decoded object of the signed transaction proposal Returns: Type SignedProposal &lt;async&gt; getState(key) Retrieves the current value of the state variable key Parameters: Name Type Description key string State variable key to retrieve from the state store Returns: Promise for the current value of the state variable Type Promise.&lt;Array.&lt;byte&gt;&gt; &lt;async&gt; getStateByPartialCompositeKey(objectType, attributes) Queries the state in the ledger based on a given partial composite key. This function returns an iterator which can be used to iterate over all composite keys whose prefix matches the given partial composite key. However, if the number of matching composite keys is greater than the totalQueryLimit (defined in core.yaml), this iterator cannot be used to fetch all matching keys (results will be limited by the totalQueryLimit). The `objectType` and attributes are expected to have only valid utf8 strings and should not contain U+0000 (nil byte) and U+10FFFF (biggest and unallocated code point). See related functions splitCompositeKey and createCompositeKey. Call close() on the returned StateQueryIterator object when done. The query is re-executed during validation phase to ensure result set has not changed since transaction endorsement (phantom reads detected). This function should be used only for a partial composite key. For a full composite key, an iter with empty response would be returned. Parameters: Name Type Description objectType string A string used as the prefix of the resulting key attributes Array.&lt;string&gt; List of attribute values to concatenate into the partial composite key Returns: A promise that resolves with a StateQueryIterator, rejects if an error occurs Type Promise getStateByPartialCompositeKeyWithPagination(objectType, attributes, pageSize, bookmark) GetStateByPartialCompositeKeyWithPagination queries the state in the ledger based on a given partial composite key. This function returns an iterator which can be used to iterate over the composite keys whose prefix matches the given partial composite key. When an empty string is passed as a value to the bookmark argument, the returned iterator can be used to fetch the first `pageSize` composite keys whose prefix matches the given partial composite key. When the bookmark is a non-emptry string, the iterator can be used to fetch the first `pageSize` keys between the bookmark (inclusive) and the last matching composite key. Note that only the bookmark present in a prior page of query result (ResponseMetadata) can be used as a value to the bookmark argument. Otherwise, an empty string must be passed as bookmark. The `objectType` and attributes are expected to have only valid utf8 strings and should not contain U+0000 (nil byte) and U+10FFFF (biggest and unallocated code point). See related functions SplitCompositeKey and CreateCompositeKey. Call Close() on the returned StateQueryIteratorInterface object when done. This call is only supported in a read only transaction. This function should be used only for a partial composite key. For a full composite key, an iter with empty response would be returned. Parameters: Name Type Description objectType string attributes Array.&lt;string&gt; pageSize int bookmark string Returns: Promise for a PaginationQueryResponse object Type Promise &lt;async&gt; getStateByRange(startKey, endKey) Returns a range iterator over a set of keys in the ledger. The iterator can be used to iterate over all keys between the startKey (inclusive) and endKey (exclusive). However, if the number of keys between startKey and endKey is greater than the totalQueryLimit (defined in core.yaml, which is the peer's configuration file), this iterator cannot be used to fetch all keys (results will be limited by the totalQueryLimit). The keys are returned by the iterator in lexical order. Note that startKey and endKey can be empty string, which implies unbounded range query on start or end. Call close() on the returned StateQueryIterator object when done. The query is re-executed during validation phase to ensure result set has not changed since transaction endorsement (phantom reads detected). Parameters: Name Type Description startKey string State variable key as the start of the key range (inclusive) endKey string State variable key as the end of the key range (exclusive) Returns: Promise for a StateQueryIterator object Type Promise getStateByRangeWithPagination(startKey, endKey, pageSize, bookmark) getStateByRangeWithPagination returns a range iterator over a set of keys in the ledger. The iterator can be used to fetch keys between the startKey (inclusive) and endKey (exclusive). When an empty string is passed as a value to the bookmark argument, the returned iterator can be used to fetch the first `pageSize` keys between the startKey (inclusive) and endKey (exclusive). When the bookmark is a non-emptry string, the iterator can be used to fetch the first `pageSize` keys between the bookmark (inclusive) and endKey (exclusive). Note that only the bookmark present in a prior page of query results (ResponseMetadata) can be used as a value to the bookmark argument. Otherwise, an empty string must be passed as bookmark. The keys are returned by the iterator in lexical order. Note that startKey and endKey can be empty string, which implies unbounded range query on start or end. Call Close() on the returned StateQueryIteratorInterface object when done. This call is only supported in a read only transaction. Parameters: Name Type Description startKey string endKey string pageSize int bookmark string Returns: Promise for a PaginationQueryResponse object Type Promise &lt;async&gt; getStateValidationParameter(key) getStateValidationParameter retrieves the key-level endorsement policy for `key`. Note that this will introduce a read dependency on `key` in the transaction's readset. Parameters: Name Type Description key string State variable key to set endorsement policy Returns: returns the endorsement policy for this key Type Buffer getStringArgs() Returns the arguments as array of strings from the chaincode invocation request Returns: Type Array.&lt;string&gt; getTransient() Returns the transient map that can be used by the chaincode but not saved in the ledger, such as cryptographic information for encryption and decryption Returns: Type Map.&lt;string:Buffer&gt; getTxID() Returns the transaction ID for the current chaincode invocation request. The transaction ID uniquely identifies the transaction within the scope of the channel. getTxTimestamp() Returns the timestamp when the transaction was created. This is taken from the transaction ChannelHeader, therefore it will indicate the client's timestamp, and will have the same value across all endorsers. Object returned: { seconds: [Long] { low: [int32], high: [int32], unsigned: [bool] }, nanos: [int32] } &lt;async&gt; invokeChaincode(chaincodeName, args, channel) Locally calls the specified chaincode invoke() using the same transaction context; that is, chaincode calling chaincode doesn't create a new transaction message. If the called chaincode is on the same channel, it simply adds the called chaincode read set and write set to the calling transaction. If the called chaincode is on a different channel, only the Response is returned to the calling chaincode; any PutState calls from the called chaincode will not have any effect on the ledger; that is, the called chaincode on a different channel will not have its read set and write set applied to the transaction. Only the calling chaincode's read set and write set will be applied to the transaction. Effectively the called chaincode on a different channel is a `Query`, which does not participate in state validation checks in subsequent commit phase. If `channel` is empty, the caller's channel is assumed. Parameters: Name Type Description chaincodeName string Name of the chaincode to call args Array.&lt;string&gt; List of arguments to pass to the called chaincode channel string Name of the channel where the target chaincode is active Returns: Promise for a Response object returned by the called chaincode Type Promise &lt;async&gt; purgePrivateData(collection, key) PurgePrivateData records the specified `key` to be purged in the private writeset of the transaction. Note that only hash of the private writeset goes into the transaction proposal response (which is sent to the client who issued the transaction) and the actual private writeset gets temporarily stored in a transient store. The `key` and its value will be deleted from the collection when the transaction is validated and successfully committed, and will subsequently be completely removed from the private data store (that maintains the historical versions of private writesets) as a background operation. Parameters: Name Type Description collection string The collection name key string Private data variable key to delete from the state store &lt;async&gt; putPrivateData(collection, key, value) putPrivateData puts the specified `key` and `value` into the transaction's private writeSet. Note that only hash of the private writeSet goes into the transaction proposal response (which is sent to the client who issued the transaction) and the actual private writeSet gets temporarily stored in a transient store. PutPrivateData doesn't effect the `collection` until the transaction is validated and successfully committed. Simple keys must not be an empty string and must not start with null character (0x00), in order to avoid range query collisions with composite keys, which internally get prefixed with 0x00 as composite key namespace. Parameters: Name Type Description collection string The collection name key string Private data variable key to set the value for value string | Array.&lt;byte&gt; Private data variable value &lt;async&gt; putState(key, value) Writes the state variable key of value value to the state store. If the variable already exists, the value will be overwritten. Parameters: Name Type Description key string State variable key to set the value for value Array.&lt;byte&gt; | string State variable value Returns: Promise will be resolved when the peer has successfully handled the state update request or rejected if any errors Type Promise setEvent(name, payload) Allows the chaincode to propose an event on the transaction proposal response. When the transaction is included in a block and the block is successfully committed to the ledger, the block event (including transaction level chaincode events) will be delivered to the current client application event listeners that have been registered with the peer's event producer. Consult each SDK's documentation for details. Only a single chaincode event can be included in a transaction. If setEvent() is called multiple times only the last event will be included in the transaction. The event must originate from the outer-most invoked chaincode in chaincode-to-chaincode scenarios. The marshaled ChaincodeEvent will be available in the transaction's ChaincodeAction.events field. Parameters: Name Type Description name string Name of the event payload Array.&lt;byte&gt; A payload can be used to include data about the event &lt;async&gt; setPrivateDataValidationParameter(collection, key, ep) SetPrivateDataValidationParameter sets the key-level endorsement policy for the private data specified by `key`. Parameters: Name Type Description collection string The collection name for this private data key string Private data variable key to set endorsement policy ep Buffer endorsement policy &lt;async&gt; setStateValidationParameter(key, ep) Sets the key-level endorsement policy for `key` Parameters: Name Type Description key string State variable key to set endorsement policy ep Buffer endorsement policy splitCompositeKey(compositeKey) Splits the specified key into attributes on which the composite key was formed. Composite keys found during range queries or partial composite key queries can therefore be split into their original composite parts, essentially recovering the values of the attributes. Parameters: Name Type Description compositeKey string The composite key to split Returns: An object which has properties of 'objectType' (string) and 'attributes' (string[]) Type Object × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.ChannelHeader.html":{"id":"fabric-shim.ChannelHeader.html","title":"Class: ChannelHeader","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: ChannelHeader ChannelHeader new ChannelHeader() Channel header identifies the destination channel of the invocation request and the type of request etc. Properties: Name Type Description type number Any of the following: MESSAGE = 0; // Used for messages which are signed but opaque CONFIG = 1; // Used for messages which express the channel config CONFIG_UPDATE = 2; // Used for transactions which update the channel config ENDORSER_TRANSACTION = 3; // Used by the SDK to submit endorser based transactions ORDERER_TRANSACTION = 4; // Used internally by the orderer for management DELIVER_SEEK_INFO = 5; // Used as the type for Envelope messages submitted to instruct the Deliver API to seek CHAINCODE_PACKAGE = 6; // Used for packaging chaincode artifacts for install version number timestamp google.protobuf.Timestamp The local time when the message was created by the submitter channel_id string Identifier of the channel that this message bound for tx_id string Unique identifier used to track the transaction throughout the proposal endorsement, ordering, validation and committing to the ledger epoch number × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.ClientIdentity.html":{"id":"fabric-shim.ClientIdentity.html","title":"Class: ClientIdentity","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: ClientIdentity ClientIdentity ClientIdentity represents information about the identity that submitted the transaction. Chaincodes can use this class to obtain information about the submitting identity including a unique ID, the MSP (Membership Service Provider) ID, and attributes. Such information is useful in enforcing access control by the chaincode. new ClientIdentity(This) Returns a new instance of ClientIdentity Parameters: Name Type Description This ChaincodeStub is the stub object passed to Init() and Invoke() methods Example Check if the submitter is an auditor const ClientIdentity = require('fabric-shim').ClientIdentity; let cid = new ClientIdentity(stub); // \"stub\" is the ChaincodeStub object passed to Init() and Invoke() methods if (cid.assertAttributeValue('hf.role', 'auditor')) { // proceed to carry out auditing } Methods assertAttributeValue(attrName, attrValue) assertAttributeValue verifies that the invoking identity has the attribute named `attrName` with a value of `attrValue`. Parameters: Name Type Description attrName string Name of the attribute to retrieve the value from the identity's credentials (such as X.509 certificate for PKI-based MSPs) attrValue string Expected value of the attribute Returns: True if the invoking identity possesses the attribute and the attribute value matches the expected value. Otherwise, returns false. Type boolean getAttributeValue(attrName) getAttributeValue returns the value of the client's attribute named `attrName`. If the invoking identity possesses the attribute, returns the value of the attribute. If the invoking identity does not possess the attribute, returns null. Parameters: Name Type Description attrName string Name of the attribute to retrieve the value from the identity's credentials (such as X.509 certificate for PKI-based MSPs). Returns: Value of the attribute or null if the invoking identity does not possess the attribute. Type string | null getID() getID returns the ID associated with the invoking identity. This ID is guaranteed to be unique within the MSP. Returns: A string in the format: \"x509::{subject DN}::{issuer DN}\" Type string getIDBytes() getIDBytes returns the ID bytes associated with the invoking identity. If the MSP is implemented with X.509 certificates, then these ID bytes will be those of the X.509 certificate. If you wish to inspect the contents of the X.509 certificate, then you must use an X.509 parsing library (for example, jsrsasign or @fidm/x509) to decode these ID bytes. Returns: Type Uint8Array getMSPID() Returns the MSP ID of the invoking identity. Returns: Type string × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.CommonIterator.html":{"id":"fabric-shim.CommonIterator.html","title":"Class: CommonIterator","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: CommonIterator CommonIterator CommonIterator allows a chaincode to check whether any more result(s) need to be fetched from an iterator and close it when done. new CommonIterator(handler, channel_id, txID, response) constructor Note that the decoded payload will be a protobuf of type fabprotos.protos.QueryResponse Parameters: Name Type Description handler ChaincodeSupportClient client handler channel_id string channel id txID string transaction id response object decoded payload Methods &lt;async&gt; close() close the iterator. Returns: A promise that is resolved with the close payload or rejected if there is a problem Type promise &lt;async&gt; next() Get the next value and return it through a promise. Returns: a promise that is fulfilled with an object { value: (next value) }, is fulfilled with an object { done: true } if there is no more value, or is rejected if any error occurs. Type promise × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.ErrorResponse.html":{"id":"fabric-shim.ErrorResponse.html","title":"Class: ErrorResponse","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: ErrorResponse ErrorResponse new ErrorResponse() Properties: Name Type Description status number Value is always set to 500 to indicate error message string Optional error message returned by the chaincode × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.FunctionAndParameters.html":{"id":"fabric-shim.FunctionAndParameters.html","title":"Class: FunctionAndParameters","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: FunctionAndParameters FunctionAndParameters new FunctionAndParameters() Properties: Name Type Description fcn string The function name, which by chaincode programming convention is the first argument in the array of arguments params Array.&lt;string&gt; The rest of the arguments, as array of strings × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.Header.html":{"id":"fabric-shim.Header.html","title":"Class: Header","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: Header Header new Header() Properties: Name Type Description channel_header ChannelHeader Channel header identifies the destination channel of the invocation request and the type of request etc. signature_header SignatureHeader Signature header has replay prevention and message authentication features × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.HistoryQueryIterator.html":{"id":"fabric-shim.HistoryQueryIterator.html","title":"Class: HistoryQueryIterator","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: HistoryQueryIterator HistoryQueryIterator A History Query iterator allows a chaincode to iterate over a set of key/value pairs returned by a history query new HistoryQueryIterator() Extends CommonIterator × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.PaginationQueryResponse.html":{"id":"fabric-shim.PaginationQueryResponse.html","title":"Class: PaginationQueryResponse","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: PaginationQueryResponse PaginationQueryResponse new PaginationQueryResponse() Properties: Name Type Description iterator StateQueryIterator the iterator which provices access to the returned data metadata QueryResponseMetadata the pagination metadata × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.PrivateQueryResponse.html":{"id":"fabric-shim.PrivateQueryResponse.html","title":"Class: PrivateQueryResponse","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: PrivateQueryResponse PrivateQueryResponse new PrivateQueryResponse() Properties: Name Type Description iterator StateQueryIterator the iterator which provices access to the returned data × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.Proposal.html":{"id":"fabric-shim.Proposal.html","title":"Class: Proposal","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: Proposal Proposal new Proposal() The essential content of the chaincode invocation request Properties: Name Type Description header Header The header object contains metadata describing key aspects of the invocation request such as target channel, transaction ID, and submitter identity etc. payload ChaincodeProposalPayload The payload object contains actual content of the invocation request × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.ProposalCreator.html":{"id":"fabric-shim.ProposalCreator.html","title":"Class: ProposalCreator","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: ProposalCreator ProposalCreator new ProposalCreator() This object contains the essential identity information of the chaincode invocation's submitter, including its organizational affiliation (mspid) and certificate (id_bytes) Properties: Name Type Description mspid string The unique ID of the Membership Service Provider instance that is associated to the identity's organization and is able to perform digital signing and signature verification × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.QueryResponseMetadata.html":{"id":"fabric-shim.QueryResponseMetadata.html","title":"Class: QueryResponseMetadata","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: QueryResponseMetadata QueryResponseMetadata new QueryResponseMetadata() Properties: Name Type Description fetched_records_count number number of records fetched bookmark string the current bookmark to be used on the next pagination query × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.Response.html":{"id":"fabric-shim.Response.html","title":"Class: Response","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: Response Response new Response() A Response object is returned from a chaincode invocation Properties: Name Type Description status number A status code that follows the HTTP status codes message string A message associated with the response code payload Array.&lt;byte&gt; A payload that can be used to include metadata with this response × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.Shim.html":{"id":"fabric-shim.Shim.html","title":"Class: Shim","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: Shim Shim The shim class provides the service to register the chaincode with the target peer, and listen for incoming requests from the peer to dispatch to the chaincode in order to process transaction proposals or execute queries. new Shim() Methods &lt;static&gt; error(msg) Returns a standard response object with status code 200 and an optional payload Parameters: Name Type Description msg string A message describing the error Returns: Type ErrorResponse &lt;static&gt; newLogger(name) Returns a winston logger named after name Parameters: Name Type Description name string Logger name used to label log messages produced by the returned logger Returns: winston based logger. See winston documentation for usage details Type Object &lt;static&gt; server(chaincode, serverOpts) Returns a new Chaincode server. Should be called when the chaincode is launched in a server mode. Parameters: Name Type Description chaincode ChaincodeInterface User-provided object that must implement ChaincodeInterface serverOpts ChaincodeServerOpts Chaincode server options &lt;static&gt; start(chaincode) Call this method to start the chaincode process. After constructing a chaincode object, pass the object to this function which will initiate a request to register the chaincode with the target peer. The address of the target peer must be provided via a program argument --peer.address Parameters: Name Type Description chaincode ChaincodeInterface User-provided object that must implement the ChaincodeInterface &lt;static&gt; success(payload) Returns a standard response object with status code 200 and an optional payload Parameters: Name Type Description payload Buffer Can be any content the chaincode wish to return to the client Returns: Type SuccessResponse × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.SignatureHeader.html":{"id":"fabric-shim.SignatureHeader.html","title":"Class: SignatureHeader","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: SignatureHeader SignatureHeader new SignatureHeader() Properties: Name Type Description creator ProposalCreator The submitter of the chaincode invocation request nonce Buffer Arbitrary number that may only be used once. Can be used to detect replay attacks. × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.SignedProposal.html":{"id":"fabric-shim.SignedProposal.html","title":"Class: SignedProposal","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: SignedProposal SignedProposal new SignedProposal() The SignedProposal object represents the request object sent by the client application to the chaincode. Properties: Name Type Description signature Buffer The signature over the proposal. This signature is to be verified against the ProposalCreator returned by getCreator(). The signature will have already been verified by the peer before the invocation request reaches the chaincode. proposal Proposal The object containing the chaincode invocation request and metadata about the request × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.StateQueryIterator.html":{"id":"fabric-shim.StateQueryIterator.html","title":"Class: StateQueryIterator","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: StateQueryIterator StateQueryIterator A State Query iterator allows a chaincode to iterate over a set of key/value pairs returned by range and execute queries new StateQueryIterator() Extends CommonIterator × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"fabric-shim.SuccessResponse.html":{"id":"fabric-shim.SuccessResponse.html","title":"Class: SuccessResponse","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: SuccessResponse SuccessResponse new SuccessResponse() Properties: Name Type Description status number Value is always set to 200 to indicate success payload Buffer Optional custom content returned by the chaincode × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"GRPCOptions.html":{"id":"GRPCOptions.html","title":"Interface: GRPCOptions","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Interface: GRPCOptions GRPCOptions ChannelOptions on \"@grpc/grpc-js\". For a complete list, refer to @grpc/grpc-js Documentation Properties: Name Type Argument Description 'grpc.${string}' Array.&lt;unknown&gt; &lt;optional&gt; Connection options defined on \"@grpc/grpc-js\" × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"module.exports.html":{"id":"module.exports.html","title":"Class: exports","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Class: exports exports Uses the standard JSON serialization methods for converting to and from JSON strings (and buffers). Buffers are converted to the format of {type:'Buffer', data:xxxxx } If a object has a toJSON() method then that will be used - as this uses the stadnard JSON.stringify() approach new exports() Methods fromBuffer(data) Inflates the data to the object or other type If on inflation the object has a type field that will throw an error if it is not 'Buffer' Parameters: Name Type Description data Buffer byte buffer containing the data Returns: the resulting type Type Object toBuffer(result) Takes the result and produces a buffer that matches this serialization format Parameters: Name Type Description result Object to be converted Returns: container the encoded data Type Buffer × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"tutorial-annotated-contract-metadata.html":{"id":"tutorial-annotated-contract-metadata.html","title":"Tutorial: Walkthrough of annotated metadata.json","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Walkthrough of annotated metadata.json Annotated Contract Metadata The Contract Metadata can be supplied either by the Contract developer or it can be inferred from the source code. Depending on the source language used, and the amount of annotations (if permitted by the language) you may need to augment the metadata that is generated. Metadata Schema The metadata itself is in JSON, and there is a JSON-Schema definition that defines the contents; this schema is available online at https://hyperledger.github.io/fabric-chaincode-node/main/api/contract-schema.json This is the latest ga copy of the schema. Specific version can be obtained using urls https://hyperledger.github.io/fabric-chaincode-node/{release}/api/contract-schema.json where releases matches the release name, for example main release-1.4. Note that metadata was first introduced at v1.4. A lot of the elements of this metadata are heavily inspired from the OpenAPI v3.0 specification and JSON Schema Adding a reference at the top of the metadata file to this schema, permits editors and tools to be able to perform validation on the JSON at the point of editing. { \"$schema\": \"https://hyperledger.github.io/fabric-chaincode-node/main/api/contract-schema.json\", } If within the contract metadata is supplied, then this will be validated against the schema (even if the $schema field is not set). If this fails then the instantiating of the contract will fail. Supplying your own metadata If you wish to supply your own metadata, the following rules apply it must be in a file called metadata.json this must be in a directory called META-INF (alternatively, it can be in the contract-metadata directory as well) this directory must be a peer of the package.json file of your contract metadata.json primarily should be supplied in META-INF directory, but if it's not found in META-INF, it will be checked for in the contract-metadata directory. Depending on the language and implementation, you may only need to augment the metadata. For example, with Typescript the types of arguments can be derived. Typically a full 'info' section may be the only thing that needs augmenting. Therefore it is not required to specific all elements of the metadata The metadata consists of three top level objects, 'info' 'contracts' and 'components'; you can supply all or none of these elements. (Supplying none is not considered an error, but has no practical effect) The contents of each of these top level elements in your own metadata are used in preference to any that can be automatically inferred. It is a programming error to have logical inconsistencies between the 'contracts' and 'components' section.This could arise in the cases where the 'contracts' you specified is different from the automatically created 'components' section Overall structure The metadata consists of three top level objects, 'info' 'contracts' and 'components' Info Purpose: To represent information about all the contracts defined in this chaincode module. Full Example: \"info\": { \"title\": \"Commercial Paper Smart Contract\", \"description\": \"Smart Contract definitions for Commercial Paper, issuing and trading\", \"termsOfService\": \"http://example.com/terms/\", \"contact\": { \"name\": \"Peso Phillips\", \"url\": \"http://www.example.com/support\", \"email\": \"peso.phillips@example.com\" }, \"license\": { \"name\": \"Apache 2.0\", \"url\": \"http://www.apache.org/licenses/LICENSE-2.0.html\" }, \"version\": \"1.0.1\" } Minimal Example: \"info\": { \"title\": \"Commercial Paper Smart Contract\", \"version\": \"1.0.1\" } Structure: This has exactly the same elements, and requirements as OpenAPI's info object. Contracts Purpose: This represents each contract class. So for example the contracts object could be \"contracts\": { \"initUpgrade\": { ... }, \"purchasing\":{ ... }, \"query\": { ... } } Contract Object Purpose: Individual Contract object Structure: Each contract object has the following structure \"CommercialPaper\":{ \"name\": \"CommercialPaper\", \"info\": { ... }, \"transactions\":[ ... ] } The name is the name of the contract, and is also the key value of the object. 'info' is the same OpenAPI info object as used at the top level of the metadata. It is not expected that the full form of this will be used with individual contracts. Each 'transaction' represents the transaction functions within the contract (and will map, therefore, to a specific function in the code). A starting example is a very simple transaction function. \"transactions\": [ { \"name\": \"setGreetingText\", \"tag\": [ \"SUBMIT\", \"submitTx\" ], \"parameters\": [ { \"name\": \"text\", \"description\": \"\", \"schema\": { \"type\": \"string\" } }, { \"name\": \"value\", \"schema\": { \"$ref\": \"#/components/schemas/Greeting\" } } ] } ] the name of the function is 'setGreetingText' it has tags of 'SUBMIT' and 'submitTx' that means that this transaction is intended to be submitted with the 'submitTransaction' sdk function. The implication is that this is then submitted to the orderder. If this is not present, then the function will be 'evaluated', not submitted to the order so in effect a query-style operation. the parameters of the function are defined in 'parameters' as an array of parameter definitions. (each of which follows the parameterObject of OpenAPI) typically a parameter will contain a 'name', optional 'description' and critically the 'schema' again 'schema' comes from OpenAPI schemaObject In this example, there are two parameters one is a simple string, and the schema uses type to refer to this simply \"schema\": { \"type\": \"string\" } Where as the second uses the concept of references to permit a more complex object definition. Components This section defines the more complex components that can occur in functions. This is typicaly used to represent objects or similar in the contract. They are generated for example from the @object annotation. In the above example, the schema is defined as \"schema\": { \"$ref\": \"#/components/schemas/Greeting\" } The #/components/schemas/Greeting is a JSON pointer to the following element: \"components\": { \"schemas\": { \"Greeting\": { \"$id\": \"Greeting\", \"type\": \"object\", \"additionalProperties\": false, \"properties\": [ { \"name\": \"text\", \"schema\": { \"type\": \"string\" } } ] } } } Schema validation The schemas section is an object listing the schemas (the key and $id element match). Each of these has the specification from the OpenAPI schemaObject At runtime, any object that is supplied as one of the parameters matching a defined schema (in this case the Greeting object), has to match this supplied schema. The 'serializer' within the contract-api will produce a JSON representation of the object that is validated against this schema. In this case for example, only the field 'text' is permitted - as additionalProperties is false. And has to be a string. An other example would be to have a numeric value and limit its range. \"age\": { \"type\": \"integer\", \"format\": \"int32\", \"minimum\": 0 } Individual elements of an object can refer to other objects for example, and the overall object can define required fields. This example is defining the concept of a person; who has a name, address and an age. The name is mandatory and has to exist, additional properties not listed here will be accepted. The address is defined elsewhere, and the age has to be at least 0 \"person\" : { \"$id\":\"person\", \"type\": \"object\", \"required\": [ \"name\" ], \"properties\": { \"name\": { \"type\": \"string\" }, \"address\": { \"$ref\": \"#/components/schemas/Address\" }, \"age\": { \"type\": \"integer\", \"format\": \"int32\", \"minimum\": 0 } } } String and Number validation Strict semantic checking can be performed on strings and numbers. As an example consider this extract of metadata describing the parameters of a function \"parameters\": [ { \"name\": \"pupilName\", \"description\": \"\", \"required\": true, \"schema\": { \"type\": \"string\" } }, { \"name\": \"formId\", \"description\": \"\", \"required\": true, \"schema\": { \"type\": \"string\", \"pattern\": \"^[a-zA-Z0-9]+$\" } }, { \"name\": \"description\", \"description\": \"\", \"required\": true, \"schema\": { \"type\": \"string\", \"maxLength\": 100 } }, { \"name\": \"lifetime\", \"description\": \"days this is valid for (30 if not given)\", \"required\": false, \"schema\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 30 } }, { \"name\": \"startDate\", \"description\": \"Start date yyyy-mm-dd, today if not specified\", \"required\": false, \"schema\": { \"type\": \"string\", \"format\": \"date\" } } ] Note: The required tag at present is not enforced by the node chaincode. Pupilname this is a string, but has no restrictions placed up on it. formId a string, but has to matched the regular expression. In this case it has to be exactly composed of lower or upcase letters and numbers description a string, with the restriction that it can't be more than 100 characters in length lifetime an integer with minimum value of 1 and maxiomum of 30 startDate an string but has to contain a date (As defined by full-date - RFC3339). The alternative to format:date is format:dateTime ... the string here has to confirmed to date-time defined in RFC3339 × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"tutorial-data-types-and-contracts.html":{"id":"tutorial-data-types-and-contracts.html","title":"Tutorial: Details of type handling","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Details of type handling How are data types handling with Contracts? This document deals with JavaScript and TypeScript contracts Function parameters JavaScript - no metadata This is the lowest common denominator; all data that is sent to the transaction function from the client is represented as strings. Therefore the conversion that takes place in the lack of any metadata is json = JSON.parse(data.toString()); If the json has a property of 'type' and that equals 'Buffer' then a byte buffer is constructed. The standard JSON.stringify() form of a byte buffer is to add the type field. It is then left to JavaScript to be able to coerce the data as per standard language rules JavaScript - with metadata If the metadata for the property specifies a String or a Number, then conversion to a String or Number takes place. Otherwise, the same conversion takes place as with 'no-metadata' Typescript Typescript needs to have no annotations for types, (other than arrays). The metadata is inferred with sufficient detail. For arrays, the @Param(&lt;name&gt;,&lt;array type&gt;,[&lt;description&gt;]) needs to be used to mark the type that is in the array. Return types A transaction function is free to return anything it wishes. (Strictly speaking it must return a promise, and that can be resolved or rejected with anything). With the Node.js runtime, either JavaScript or TypeScript can be used. For both languages you can supply additional metadata, either as annotations, or as a JSON file. JavaScript - no metadata This is the lowest common denominator; if no metadata is either provided by annotations, file, or inferred by introspection this is behaviour. All return values will be processed as follows: Buffer.from(JSON.stringify(functionsReturnValue)) The data will be stringified, then converted to a buffer to be returned. The buffer conversion is required by the shim api to communicate with the peer. This will be 'reversed' in the client SDK so that clients are given a string. JavaScript with metadata It is beneficial to supply metadata; specifically in the case of JavaScript to identify strings and numbers from objects. By doing this means that the transaction functions can Return strings and numbers directly. Numbers are converted to their textual form eg 42 becomes \"42\" Anything else is returned by being stringified first Typescript Without the '@return' annotations and/or metadata Typescript introspection can not provide enough details about the return type. Primarily as this is a Promise that resolves a type introspection only indicates the promise aspect. Metadata can be explicitly provided or the @Returns(&lt;string of type name&gt;) can be used to indicate the type. The annotation needs to have the type name specified as a string value. × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"tutorial-deep-dive-contract-interface.html":{"id":"tutorial-deep-dive-contract-interface.html","title":"Tutorial: Deep dive on Contract Interface","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Deep dive on Contract Interface Details on the programming model Smart Contract packages consist of a set of code that contains the implementations of the code you want to run. Taken as a whole Hyperledger refers to this code as chaincode; a single chaincode is run within a docker container that is created and started by each peer. Depending on the language, a nodejs, Java or Go runtime might be used within the docker containers. Node.js project structure Each Smart Contract package is, from a node perspective, a NPM module. package.json This needs to import the fabric-contract-api and fabric-shim npm modules The 'start' script must be set to fabric-chaincode-node-start - this has to be present for the peer to call the node module to start It is recommended to have a 'start:dev' script that can be used for development (details on this later) A 'main' entry to point to your index.js file contain the exports of the node module index.js It is mandatory to have a contracts element exported that is a array of classes. Each of these classes must extend the Contract class from the fabric-contract-api module Optionally, a custom serializer may be defined to control how data is converted for transmission between chaincode, peer and ultimately client applications (in future this could also include serialization to the ledger state). JavaScript example index.js const cpcontract = require('./lib/papernet/papercontract.js'); module.exports.contracts = [cpcontract]; module.exports.CommercialPaper = require('./lib/papernet/paper.js'); TypeScript example index.ts import { GreetingContract } from './greetingcontract'; export { GreetingContract } from './greetingcontract'; export const contracts: any[] = [ GreetingContract ]; META-INF/metadata.json (alternatively contract-metadata/metadata.json) This file describes the external api that is exposed from these Smart Contracts; these are the functions that can be invoked by client applications. It describes all details about what is callable, and the datatypes of parameter and return values. It can also include information about documentation and licensing. It describes the callable interface, and does not make any assertions about how the code is implemented. Defining your contract classes The node module must export an array of one or more contract classes in the contracts property. Each of these class must extend the correct type. At runtime each of these will have a single instance created, and will persist for the lifetime of the chaincode container. Each function MUST NOT use the instance to store data; all data MUST be stored within either the ledger, or within the transaction context import { Contract } from 'fabric-contract-api'; export class GreetingContract extends Contract { public constructor() { super('Greeting'); } } The constructor must call super, the argument is optional but is used to name this instance, and is used to refer to this instance when it is called by client . applications. If no argument is supplied, then the name of the class is used (in this case GreetingContract ). If an empty string is supplied that is valid, but not recommended. It is not recommended to supply the same name, the behaviour if function names within the two contracts overlap is undefined. Transaction Functions Within each contract instance, you may has few or many functions as you wish. Each of them is eligible to a transaction function that is callable by applications. If a function name is prefixed with a _ it will be ignored. For Javascript all the functions will be eligible, but for Typescript the functions that are required must have a @Transaction() decorator Each transaction must take as it's first parameter the transaction context Context The first parameter is the 'transaction context' - it is quite plausible for several transactions to be invoked concurrently; the transaction context is required to give information specific to the transaction that is currently being executed. Currently the 'stub' api for handling world state, and the 'Client Identity' is available from the context. Each contract has a 'createContext' method that can be overridden by specific implementations to provide specific control to add information to the Before, After, Around and Unknown Functions The Contract class defines three functions that can be overridden by specific implementations. async beforeTransaction(ctx) { // default implementation is do nothing } async afterTransaction(ctx, result) { // default implementation is do nothing } async aroundTransaction(ctx, fn, parameters) { // default implementation invokes `fn` } Before is called immediately before the transaction function, and after immediately afterwards. Note that before does not get the arguments to the function (note this was the subject of debate, opinions welcomed). After gets the result from the transaction function (this is the result returned from transaction function without any processing). Around is the one responsible for invoking the trancaction function, and allows you to wrap all of them into a code block. If the transaction function throws an Error then the whole transaction fails, likewise if the before or after throws an Error then the transaction fails. (note that if say before throws an error the transaction function is never called, nor the after. Similarly if transaction function throws an Error, after is not called. ) Typical use cases of these functions would be logging of the functions called checks of the identity of the caller wrap all functions into a try/catch The unknown function is called if the requested function is not known; the default implementation is to throw an error. You've asked to invoke a function that does not exist: {requested function} However you can implement an unkownTransition function - this can return a successful or throw an error as you wish. async unknownTransaction(ctx) { // throw an error here or return succesfully if you wish } Metadata Supplying your own metadata A correctly specified metadata file, at the top level has this structure { \"$schema\" : \"https://hyperledger.github.io/fabric-chaincode-node/main/api/contract-schema.json\", \"info\" : { }, \"contracts\" : { }, \"components\" : { } } The metadata file that the user specifies has precedence over the information generated from the code, on a per section basis. If the user has not specified any of the above sections, then the 'gap' will be filled with auto generated values. × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"tutorial-using-chaincodeinterface.html":{"id":"tutorial-using-chaincodeinterface.html","title":"Tutorial: Using the Chaincode Interface","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Using the Chaincode Interface Writing your own chaincode To write your own chaincode is very easy. Create a file named mychaincode.js anywhere in the file system. cd ~ mkdir mycc cd mycc // create a new node project npm init // install fabric-shim at main branch npm install fabric-shim@2.5.0 // or using the released version npm install fabric-shim touch mychaincode.js Put the following minimum implementation to mychaincode.js: const shim = require('fabric-shim'); const util = require('util'); var Chaincode = class { Init(stub) { return stub.putState('dummyKey', Buffer.from('dummyValue')) .then(() =&gt; { console.info('Chaincode instantiation is successful'); return shim.success(); }, () =&gt; { return shim.error(); }); } Invoke(stub) { console.info('Transaction ID: ' + stub.getTxID()); console.info(util.format('Args: %j', stub.getArgs())); let ret = stub.getFunctionAndParameters(); console.info('Calling function: ' + ret.fcn); return stub.getState('dummyKey') .then((value) =&gt; { if (value.toString() === 'dummyValue') { console.info(util.format('successfully retrieved value \"%j\" for the key \"dummyKey\"', value )); return shim.success(); } else { console.error('Failed to retrieve dummyKey or the retrieved value is not expected: ' + value); return shim.error(); } }); } }; shim.start(new Chaincode()); Finally, update the \"start\" script in package.json to \"node mychaincode.js\": { \"name\": \"mychaincode\", \"version\": \"1.0.0\", \"description\": \"My first exciting chaincode implemented in node.js\", \"engines\": { \"node\": \"^&gt;=18\" }, \"scripts\": { \"start\" : \"node mychaincode.js\" }, \"engine-strict\": true, \"engineStrict\": true, \"license\": \"Apache-2.0\", \"dependencies\": { \"fabric-shim\": \"~2.5\" } } Now you need to restart the peer in \"network\" mode instead of \"dev\" mode. Using Docker If you used 'gulp channel-init', change directory to the fabric-chaincode-node, set an environment variable \"DEVMODE=false\" and run the command again. cd fabric-chaincode-node DEVMODE=false gulp channel-init Next, copy a chaincode to the folder mounted on CLI container and enter the CLI container. cp -r ~/mycc /tmp/fabric-shim/chaincode docker exec -it cli bash Install the chaincode. The peer CLI will package the node.js chaincode source, without the \"node_modules\" folder, and send to the peer to install. peer chaincode install -l node -n mycc -p /opt/gopath/src/github.com/mycc -v v0 Upon successful response, instantiate the chaincode on the \"mychannel\" channel created above: peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -l node -n mycc -v v0 -c '{\"Args\":[\"init\"]}' -P 'OR (\"Org1MSP.member\")' This will take a while to complete as the peer must perform npm install in order to build a custom docker image to launch the chaincode. When successfully completed, you should see in peer's log message confirmation of committing a new block. This new block contains the transaction to instantiate the chaincode \"mycc:v0\". To further inspect the result of the chaincode instantiate command, run docker images and you will see a new image listed at the top of the list with the name starting with dev-. You can inspect the content of this image by running the following command: docker exec -it dev-peer0.org1.example.com-mycc-v0 bash root@c188ae089ee5:/# ls /usr/local/src chaincode.js fabric-shim node_modules package.json root@c188ae089ee5:/# Once the chaincode instantiation has completely successfully, you can send transaction proposals to it with the following commands. peer chaincode invoke -o orderer.example.com:7050 -C mychannel -c '{\"Args\":[\"dummy\"]}' -n mycc × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"tutorial-using-contractinterface.html":{"id":"tutorial-using-contractinterface.html","title":"Tutorial: Using the Contract Interface","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Using the Contract Interface This outlines the theory of the how the new node module works; with the fabric samples project you will find scenario-based approaches. Writing the chaincode 1: Chaincode is created as an npm module. An initial package.json is as follows; The dependencies of fabric-contract-api and fabric-shim will be required. { \"name\": \"chaincode\", \"description\": \"My first exciting chaincode implemented in node.js\", \"engines\": { \"node\": \"&gt;=18\" }, \"scripts\": { \"test\":\"mocha..... }, \"engine-strict\": true, \"engineStrict\": true, \"version\": \"1.0.0\", \"main\": \"index.js\", \"author\": \"\", \"license\": \"Apache-2.0\", \"dependencies\": { \"fabric-contract-api\": \"~2.5\", \"fabric-shim\": \"~2.5\" } } Remember to add in any additional business logic, and testing libraries needed Adding fabric-shim as a dependency, gives a command fabric-chaincode-node that is the script to run for npm start. \"scripts\": { \"start\": \"fabric-chaincode-node start\", \"test\": \"nyc mocha test\", .... }, 2: How is chaincode deployed? Chaincode is deployed by the peer in response to issuing a number of (usually CLI) commands. For node.js chaincode the location of the chaincode npm project is required (the directory that the package.json is in). This does not need to be an installed project, but has to have all the code, and the package.json. A docker image is built for this chaincode, the package.json and code copied in. and npm install run. After the install there is a 'bootstrap' process that starts the chaincode up (more details later). The constructors of the exported Contracts will be run at this point; these constructors are for setting the name and optional setup of the 'error/monitoring functions', (again more later). This instance of the contract will existing whilst this chaincode docker image is up. When chaincode is instantiated or updated, the init() function is the chaincode is called. As with the invoke() call from the client, a fn name and parameters can be passed. Remember therefore to have specific functions to call on init() and update() in order to do any data initialisation or migration that might be needed. These two functions have been abstracted away to focus on specific function implementations. It is strongly recommended to use the npm shrinkwrap mechanism so the versions of the modules that are used are fixed. Within the class you can defined as many or functions as you wish. These transaction functions will form the basis of the business logic you contract needs to execute. These are async functions, and can take parameters and return values. There is a single mandatory parameter of the 'transaction context'; this represents the currently executing transaction and is the way functions can access the world state, and other APIs. 3: What needs to be exported? Node states that module exports are defined in index.js In this example we have a single value that can be queried and updated. This has been split into to parts for demonstration purposes. // index.js 'use strict'; const UpdateValues = require('./updatevalues') const RemoveValues = require('./removevalues') module.exports.contracts = [UpdateValues,RemoveValues]; This exports two classes that together form the Contract. There can be other code that within the model that is used in a support role. Note that the 'contracts' word is mandatory. 4: What do these classes need to contain? As an example the updatevalues will look like this (with the function bodies remove for clarity) // updatevalues.js 'use strict'; // SDK Library to asset with writing the logic const { Contract } = require('fabric-contract-api'); // Business logic (well just util but still it's general purpose logic) const util = require('util'); /** * Support the Updating of values within the SmartContract */ class UpdateValues extends Contract constructor(){ super('UpdateValuesContract'); } async instantiate(ctx){ // ..... } async setNewAssetValue(ctx, newValue) { // ..... } async doubleAssetValue(ctx) { // ..... } }; module.exports = UpdateValues; Note that ALL the functions defined in these modules will be called by the client SDK. There are 3 functions setup setNewAssetValue and doubleAssetValue that can be called by issuing the appropriate invoke client side The ctx in the function is a transaction context; each time a invoke is called this will be a new instance that can be used by the function implementation to access apis such as the world state of information on invoking identity. The arguments are split out from the array passed on the invoke. The constructor contains a 'name' to help identify the sets of functions Running chaincode in development mode This is quite easy - as you need to run the startChaincode command. $ $(npm bin)/fabric-chaincode-node start --peer.address localhost:7052 --chaincode-id-name \"mycontract:v0\" (this is actually what the peer does; this does mean that any chaincode that is written using the existing chaincode interface will continue to work as is.) Using this chaincode Each of the functions can be invoked with arbitrary arguments. The name of the function is of the format [name:]functionname If a name is given in the constructor then it will be prefixed separated by a : (colon) assuming that you have a fabric up and running with the appropriate environment variables set $ peer chaincode install --lang node --name mycontract --version v0 --path ~/chaincode-examples $ peer chaincode instantiate --orderer localhost:7050 --channelID mychannel --lang node --name mycontract --version v0 -c '{\"Args\":[\"UpdateValuesContract:setup\"]}' Will get things working... Then you can invoke the chaincode via this command. $ peer chaincode invoke --orderer localhost:7050 --channelID mychannel -c '{\"Args\":[\"UpdateValuesContract:getAssetValue\"]}' -n mycontract4 Additional support provided by the SmartContract class In the case where you ask for a function to be executed, it could be the case that this doesn't exist. You can provide you own function to be executed in this case, the default is to throw and error but you're able to customise this if you wish. For example /** * Sets a name so that the functions in this particular class can * be separated from others. */ constructor() { super('UpdateValuesContract'); } /** The function to invoke if something unkown comes in. * */ async unknownTransaction(ctx){ throw new Error('a custom error message') } async beforeTransaction(ctx){ console.info(`Transaction ID: ${ctx.stub.getTxID()}`); } async afterTransaction(ctx,result){ // log result to preferred log implementation // emit events etc... } async aroundTransaction(ctx, fn, parameters) { try { // don't forget to call super, or your transaction function won't run! super.aroundTransaction(ctx, fn, parameters) } catch (error) { // do something with the error, then rethrow throw error } } Structure of the Transaction Context In Fabric, there is a stub api that provides chaincode with functionality. No functionality has been removed, but a new approach to providing abstractions on this to facilitate programming. user additions: additional properties can be added to the object to support for example common handling of the data serialization. The context object contains ctx.stub the same stub instance as in earlier versions for compatibility ctx.identity and instance of the Client Identity object You are at liberty to create a subclass of the Context to provide additional functions, or per-transaction context storage. For example /** * Custom context for use within this contract */ createContext(){ return new ScenarioContext(); } and the Context class itself is const { Context } = require('fabric-contract-api'); class ScenarioContext extends Context{ constructor(){ super(); } generateKey(){ return this.stub.createCompositeKey('type',['keyvalue']); } } Node.js Chaincode API rules Definitions as per https://www.ietf.org/rfc/rfc2119.txt All the functions that are present in the prototype of a class that extends Contract will be invokable The exports from the node module MUST include contracts that is an array of constructors (1 or more) Each class MAY call in it's constructor pass a name. This is prefixed to each of the function names by an _ (underscore) Each class MAY define functions that are executed before and functions that are executed after the invoked function. These are part of the same fabric transaction They are scoped per name Each class MAY define a function that would be executed if a matching function name does not exist; otherwise a 'no function exists' error will be thrown If too many parameters are passed, they will be discarded If too few parameters are passed, then the remainder will be set to undefined as per node.js language standard Duplicate function names in a single class is an error Any function that is dynamically added will not be registered as an invokable function There are no specific function that is invoked per Fabric's init chaincode spi. The instantiate flow can pass function name and parameters; therefore consider a dedicated function that will be called for new chaincode deployments, and for upgrade deployments. Restrictions on programming in side a Contract function Hyperledger Fabric's consensus algorithm permits the ability to use general purpose languages; rather than a more restrictive language. But the following restrictions apply Functions should not create random variables, or use any function whose return values are functions of the current time or location of execution i.e. the function will be executed in another context (i.e. peer process). This could potentially be in a different time zone in a different locale. Functions should be away that they may read state, and write state. But they are producing a set of changes that will be applied to the state. The implication is that updates to the state may not be read back. let v1 = getState(\"key\") v1==\"hello\" // is true putState(\"key\",\"world\") let v2 = getState(\"key\") v2==\"world\" // is false, v2 is \"hello\" In any subsequent invocation, the value would be seen to be updated. Note that if you have use any Flux architecture implications such as Redux, the above restrictions will be familiar. × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"tutorial-using-iterators.html":{"id":"tutorial-using-iterators.html","title":"Tutorial: Working with apis that return iterators","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Working with apis that return iterators Working with iterators The fabric-shim api provides capability to retrieve blocks of information. Information such as the history of a key, a set of keys and their values from a range of keys and also a set of keys and values when performing a rich query if your network is using couchdb to manage the world state. An example of these apis (but may not be a complete list) is given here History getHistoryForKey Private data getPrivateDataByPartialCompositeKey getPrivateDataByRange getPrivateDataQueryResult Rich query getQueryResult getQueryResultWithPagination Range queries getStateByPartialCompositeKey getStateByPartialCompositeKeyWithPagination getStateByRange getStateByRangeWithPagination These apis are a request to return a set of data for which you need to iterate over using the provided iterator. Some of these apis will return the iterator directly and others return an iterator as part of an object property. In previous versions of the fabric-shim api you would need to know which ones did that and handle it appropriately and you need to check the documentation, but the rules are all private data range queries return an object with just an iterator property containing the iterator all Pagination queries return an object with an iterator property and metadata property all other rich/range/history queries return just the iterator itself. These iterators were essentially asynchronous iterators (the next and close methods returned promises) but you couldn't use standard iterator capabilities such as for/of constructs in node because node could not work with the concept of asynchronous iterators. From fabric v2.x onwards, node chaincode will be using node 12 and this has added support for asynchronous iterators. Also in fabric v2.x onwards, fabric-shim has added support to enable it's asynchronous iterators so that for/of can now be used, but note that they don't have full support, so should not be used in generator functions. As a comparison, let's present first how you would use iterators in previous releases and then show the new way. How to use, the old way In the past, you might have coded something like this to process an iterator: async function getAllResults(iterator) { const allResults = []; while (true) { const res = await iterator.next(); if (res.value) { // if not a getHistoryForKey iterator then key is contained in res.value.key allResults.push(res.value.value.toString('utf8')); } // check to see if we have reached then end if (res.done) { // explicitly close the iterator await iterator.close(); return allResults; } } } as iterator.next() returned an object of the form {value: KV|KeyModification object done: true|false} and the structures of the value property are best described by the typescript definitions interface KV { key: string; value: Buffer; getKey(): string; getValue(): ProtobufBytes; } interface KeyModification { isDelete: boolean; value: ProtobufBytes; timestamp: Timestamp; txId: string; getIsDelete(): boolean; getValue(): ProtobufBytes; getTimestamp(): Timestamp; getTxId(): string; } and you would obtain an iterator as follows (depending on the api you are calling) // use await to get the iterator and pass it to getAllResults const iterator = await ctx.stub.getStateByRange(startKey, endKey); let results = await getAllResults(iterator); // use await to get the object containing the iterator and metadata and // pass it to getAllResults. All Pagination type queries return an object // with iterator and metadata properties let response = await ctx.stub.getQueryResultWithPagination(JSON.stringify(query), 2); const {iterator, metadata} = response; let results = await getAllResults(iterator); // use await to get the object containing the iterator and metadata and // pass it to getAllResults. All Private Data type queries return an object // with only an iterator property let response = await ctx.stub.getPrivateDataByRange(collection, startKey, endKey); let results = await getAllResults(response.iterator); How to use, the new way The new way of using for/await/of in node.js makes things much easier. You don't have to worry about each of the api's returning a different value (is it an iterator or is it an object with an iterator in the iterator property). You also don't have to explicitly close the iterator any more. Here is a re-implementation of the getAllResults function async function getAllResults(promiseOfIterator) { const allResults = []; for await (const res of promiseOfIterator) { // no more res.value.value ... // if not a getHistoryForKey iterator then key is contained in res.key allResults.push(res.value.toString('utf8')); } // iterator will be automatically closed on exit from the loop // either by reaching the end, or a break or throw terminated the loop return allResults; } It's more concise, the only difference between the 2 signatures of the old versus the new is what you pass to it. Previously you passed the actual iterator but in the new version you pass the promise that will resolve to either an iterator or an object containing the iterator. So if we take the 3 previous calls to the various apis, how do they look now. // use await to get the iterator and pass it to getAllResults const promiseOfIterator = ctx.stub.getStateByRange(startKey, endKey); let results await getAllResults(promiseOfIterator); // use await to get the object containing the iterator and metadata and // pass it to getAllResults. All Pagination type queries return an object // with iterator and metadata properties let promiseOfIterator = ctx.stub.getQueryResultWithPagination(JSON.stringify(query), 2); let results = await getAllResults(promiseOfIterator); const metadata = (await promiseOfIterator).metadata; // use await to get the object containing the iterator and metadata and // pass it to getAllResults. All Private Data type queries return an object // with only an iterator property let promiseOfIterator = ctx.stub.getPrivateDataByRange(collection, startKey, endKey); let results = await getAllResults(promiseOfIterator); Lets note the differences You do not use await when invoking the stub function. This means it will return a promise You don't have to worry about whether the promise will resolve to an iterator or an object containing the iterator. The returned value is handled in the same way in all cases In the case of pagination apis it's still easy to get the required metadata response. example of getHistoryForKey All the functions that return a set of data, except one, return data in the KV structure format. The exception is getHistoryForKey whose dataset is of the form KeyModification. Below is a simple example of using getHistoryForKey. const promiseOfIterator = ctx.stub.getHistoryForKey(key); const results = []; for await (const keyMod of promiseOfIterator) { const resp = { timestamp: keyMod.timestamp, txid: keyMod.txId } if (keyMod.isDelete) { resp.data = 'KEY DELETED'; } else { resp.data = keyMod.value.toString('utf8'); } results.push(resp); } // results array contains the key history × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "},"tutorial-using-typescript-decorators.html":{"id":"tutorial-using-typescript-decorators.html","title":"Tutorial: Using TypeScript Decorators","body":" Hyperledger Fabric Contract API Classes fabric-contract-api.Contextfabric-contract-api.Contractfabric-shim.ChaincodeInterfacefabric-shim.ChaincodeProposalPayloadfabric-shim.ChaincodeStubfabric-shim.ChannelHeaderfabric-shim.ClientIdentityfabric-shim.CommonIteratorfabric-shim.ErrorResponsefabric-shim.FunctionAndParametersfabric-shim.Headerfabric-shim.HistoryQueryIteratorfabric-shim.PaginationQueryResponsefabric-shim.PrivateQueryResponsefabric-shim.Proposalfabric-shim.ProposalCreatorfabric-shim.QueryResponseMetadatafabric-shim.Responsefabric-shim.Shimfabric-shim.SignatureHeaderfabric-shim.SignedProposalfabric-shim.StateQueryIteratorfabric-shim.SuccessResponsemodule.exports Interfaces ChaincodeServerOptsChaincodeServerTLSPropertiesGRPCOptions Tutorials Walkthrough of annotated metadata.jsonDetails of type handlingDeep dive on Contract InterfaceUsing the Chaincode InterfaceUsing the Contract InterfaceWorking with apis that return iteratorsUsing TypeScript Decorators Using TypeScript Decorators Summary of the Typescript Decorators When using Typescript to code the Contract implementations, Typescript Decorators can be used to provide additional metadata; together with the type information that can be introspected, a very detailed set of metadata can be put within the source code directly. Decorators available @Info Supplies information about the following contract such as license terms or author. This takes as a parameter an object that has the key-value pairs as defined on the OpenAPI v3 Info object spec @Transaction Defines the following function to be a callable transaction function Takes a boolean parameter; true indicates that this function is intended to be called with the 'submit' semantics, false indicates that this is intended to be called with the evaluate semantics. (Submit means submit to the orderer to be recorded on the ledger) Default is true @Returns Takes a string that is the name of the type that is being returned by this function This is present as required as Typescript does not give back the complete return type @Object Defines the class that represents one of the complex types that can be returned or passed to the transaction functions @Property Defines a property of the a class (identified by @Object) that should be passed within the object @Param Permits additional information such as a type and description to provided for parameters. (Note type is only useful in weakly typed languages) Note that emitDecoratorMetadata property in tsconfig.json file is mandatory. × Search results Close Documentation generated by JSDoc 3.6.10 on 2025-02-04T14:27:54-05:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
